<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="ModuleScript" referent="RBXECB43D17D9A743F3823F7BD01DDE1CBD">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">MainModule</string>
			<string name="ScriptGuid">{101547FB-726A-44BA-981B-92FC2A41042D}</string>
			<ProtectedString name="Source"><![CDATA[--Wraps the Nexus VR Character Model main module for loading.
--When required with an id, the main module's source isn't
--included, which makes the client see an empty script.

return require(script:WaitForChild("NexusVRCharacterModel"))]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBXF48BC761D8B2448799E28B5A6E4F76B0">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">NexusVRCharacterModel</string>
				<string name="ScriptGuid">{DED128A9-F2C8-40AE-BD5A-DB96A439AD04}</string>
				<ProtectedString name="Source"><![CDATA[--Loads Nexus VR Character Model.
--!strict

--Version information should be set right before distribution (not committed).
local VERSION_TAG = "2.14.1"
local VERSION_COMMIT = "d414d83"

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")

local BufferedRemoteEventSender = require(script:WaitForChild("NexusBufferedReplication"):WaitForChild("Sender"):WaitForChild("BufferedRemoteEventSender"))
local EnrollableRemoteEvent = require(script:WaitForChild("NexusBufferedReplication"):WaitForChild("Sender"):WaitForChild("EnrollableRemoteEvent"))
local Settings = require(script:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local BufferProtocol = require(script:WaitForChild("Util"):WaitForChild("BufferProtocol"))

local NexusVRCharacterModel = {}

export type NexusVRCharacterModel = typeof(NexusVRCharacterModel)



--[[
Sets the configuration to use. Intended to be
run once by the server.
--]]
function NexusVRCharacterModel.SetConfiguration(self: NexusVRCharacterModel, Configuration: any): ()
    --Create the value.
    local ConfigurationValue = script:FindFirstChild("Configuration") :: StringValue
    if not ConfigurationValue then
        local NewConfigurationValue = Instance.new("StringValue")
        NewConfigurationValue.Name = "Configuration"
        NewConfigurationValue.Parent = script
        ConfigurationValue = NewConfigurationValue
    end

    --Add the version.
    local HideVersion = false
    if Configuration.Extra then
        HideVersion = (Configuration.Extra.HideVersion == true)
    end
    if not Configuration.Version then
        Configuration.Version = {}
    end
    if not Configuration.Version.Tag then
        Configuration.Version.Tag = (HideVersion and "Hidden" or VERSION_TAG)
    end
    if not Configuration.Version.Commit then
        Configuration.Version.Commit = (HideVersion and "Hidden" or VERSION_COMMIT)
    end

    --Store the configuration.
    ConfigurationValue.Value = HttpService:JSONEncode(Configuration)
    Settings:SetDefaults(Configuration)
end

--[[
Loads Nexus VR Character Model.
--]]
function NexusVRCharacterModel.Load(self: NexusVRCharacterModel): ()
    --Return if a version is already loaded.
    if ReplicatedStorage:FindFirstChild("NexusVRCharacterModel") then
        return
    end

    --Rename and move the script to ReplicatedStorage.
    script.Name = "NexusVRCharacterModel"
    script.Parent = ReplicatedStorage

    --Copy Nexus VR Core.
    if not ReplicatedStorage:FindFirstChild("NexusVRCore") then
        script:WaitForChild("NexusVRCore"):Clone().Parent = ReplicatedStorage
    end

    --Output any warnings.
    (require(ReplicatedStorage:WaitForChild("NexusVRCharacterModel"):WaitForChild("Util"):WaitForChild("Warnings")) :: any)()

    --Set up the client scripts.
    script:WaitForChild("NexusVRCharacterModelClientLoader").Parent = ReplicatedStorage

    --Set up replication.
    local UpdateInputsEvent = Instance.new("UnreliableRemoteEvent")
    UpdateInputsEvent.Name = "UpdateInputs"
    UpdateInputsEvent.Parent = script

    local ReplicationReadyEvent = Instance.new("RemoteEvent")
    ReplicationReadyEvent.Name = "ReplicationReady"
    ReplicationReadyEvent.Parent = script

    local EnrollableUpdateInputsEvent = EnrollableRemoteEvent.new(UpdateInputsEvent)
    local UpdateInputsBufferedRemoteEventSender = BufferedRemoteEventSender.WithPlayerKeys(EnrollableUpdateInputsEvent :: any, function(Data: BufferProtocol.BufferProtocolData)
        return BufferProtocol.Serialize(Data)
    end)
    UpdateInputsBufferedRemoteEventSender:StartDataSendingWithDelay(1 / 30)

    UpdateInputsEvent.OnServerEvent:Connect(function(Player, Data: BufferProtocol.BufferProtocolData)
        if typeof(Data) ~= "table" then return end
        UpdateInputsBufferedRemoteEventSender:QueueData(Player, Data)
    end)

    ReplicationReadyEvent.OnServerEvent:Connect(function(Player)
        EnrollableUpdateInputsEvent:EnrollPlayer(Player)
    end)

    --Load Nexus VR Backpack.
    if Settings:GetSetting("Extra.NexusVRBackpackEnabled") ~= false then
        (require(10728805649) :: any)()
    end
end




NexusVRCharacterModel.Api = (require(script:WaitForChild("Api")) :: any)()
return NexusVRCharacterModel]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXA43C5DB4EA354C95AD2B68D63CDCF21E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Api</string>
					<string name="ScriptGuid">{F2A7A194-2543-4B0C-B0E3-2AB64E030009}</string>
					<ProtectedString name="Source"><![CDATA[--Main module for creating the usable API.
--!strict

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")



return function()
    local NexusVRCharacterModel = script.Parent
    local TypedEvent = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("Event"):WaitForChild("TypedEvent"))
    local API = {} :: any
    API.Registered = TypedEvent.new()

    --[[
    Stores an API that can be referenced. If the API is already stored,
    an error will be thrown.
    --]]
    function API:Register(ApiName: string, Api: any): ()
        if self[ApiName] ~= nil then
            error(`API already registered: {ApiName}`)
        end
        self[ApiName] = Api
        self.Registered:Fire(ApiName)
    end

    --[[
    Waits for an API to be registered and returns the API. If it was
    already registered, it returns the API without waiting. Similar
    to instances, this would be treated like WaitForChild where the
    usage is optional instead of indexing (ex: API:WaitFor("MyApi")
    vs API.MyApi) as long as the consequences of an API not
    being registered are accepted.
    --]]
    function API:WaitFor(ApiName: string): any
        while not self[ApiName] do
            self.Registered:Wait()
        end
        return self[ApiName]
    end

    --[[
    Invokes a callback when an API is registered with a given
    name. If it is already registered, the callback will run
    asynchronously. This is intended for setting up an API
    call without blocking for WaitFor.
    --]]
    function API:OnRegistered(ApiName: string, RegisteredCallback: (any) -> ()): ()
        --Run the callback immediately if the API is loaded.
        if self[ApiName] then
            task.spawn(function()
                RegisteredCallback(self[ApiName])
            end)
            return
        end

        --Connect the registered event.
        self.Registered:Connect(function(RegisteredFunctionName)
            if ApiName ~= RegisteredFunctionName then return end
            RegisteredCallback(self[ApiName])
        end)
    end

    --Create the client API.
    --Done in a task to resolve recurisve requiring.
    if RunService:IsClient() then
        task.defer(function()
            --Create the camera API.
            local CameraService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CameraService")).GetInstance()
            local CameraAPI = {}
            function CameraAPI:SetActiveCamera(Name: string): ()
                CameraService:SetActiveCamera(Name)
            end
            function CameraAPI:GetActiveCamera(): string
                return CameraService.ActiveCamera
            end
            API:Register("Camera", CameraAPI)

            --Create the controller API.
            local ActiveControllers = {}
            local ControlService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("ControlService")).GetInstance()
            local ControllerAPI = {}
            function ControllerAPI:SetActiveController(Name: string): ()
                ControlService:SetActiveController(Name)
            end
            function ControllerAPI:GetActiveController(): (string)
                return ControlService.ActiveController
            end
            function ControllerAPI:SetControllerInputEnabled(Hand: Enum.UserCFrame, Enabled: boolean): ()
                if Hand ~= Enum.UserCFrame.LeftHand and Hand ~= Enum.UserCFrame.RightHand then
                    error(`The following UserCFrame is invalid and can't be disabled: {Hand}`)
                end
                ActiveControllers[Hand] = (Enabled ~= false)
            end
            function ControllerAPI:EnableControllerInput(Hand: Enum.UserCFrame): ()
                self:SetControllerInputEnabled(Hand, true)
            end
            function ControllerAPI:DisableControllerInput(Hand: Enum.UserCFrame): ()
                self:SetControllerInputEnabled(Hand, false)
            end
            function ControllerAPI:IsControllerInputEnabled(Hand: Enum.UserCFrame): boolean
                if Hand ~= Enum.UserCFrame.LeftHand and Hand ~= Enum.UserCFrame.RightHand then
                    error(`The following UserCFrame is invalid and can't be disabled: {Hand}`)
                end
                return ActiveControllers[Hand] ~= false
            end
            API:Register("Controller", ControllerAPI)

            --Create the input API.
            local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()
            local InputAPI = {}
            InputAPI.Recentered = VRInputService.Recentered
            InputAPI.EyeLevelSet = VRInputService.EyeLevelSet
            function InputAPI:Recenter(): ()
                VRInputService:Recenter()
            end
            function InputAPI:SetEyeLevel(): ()
                VRInputService:SetEyeLevel()
            end
            API:Register("Input", InputAPI)

            --Create the Menu API.
            --The Menu API does not work outside of VR.
            --Release 454 and later has/had a bug that made VREnabled false on start. This mitigates that now and in the future if VR loads dynamically.
            local MenuAPI = {} :: any
            local function GetMainMenu(): any
                if not MenuAPI.Enabled then
                    error("Menu API is not enabled for non-VR players. Check Api.Menu.Enabled before calling.")
                end
                return require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("MainMenu")).GetInstance()
            end
            if UserInputService.VREnabled then
                MenuAPI.Enabled = true
            else
                MenuAPI.Enabled = false
                UserInputService:GetPropertyChangedSignal("VREnabled"):Connect(function()
                    MenuAPI.Enabled = UserInputService.VREnabled
                end)
            end

            MenuAPI.CreateView = function(_, ...)
                return GetMainMenu():CreateView(...)
            end
            MenuAPI.IsOpen = function()
                return GetMainMenu().ScreenGui.Enabled
            end
            MenuAPI.Open = function(self)
                if self:IsOpen() then return end
                GetMainMenu():Toggle()
            end
            MenuAPI.Close = function(self)
                if not self:IsOpen() then return end
                GetMainMenu():Toggle()
            end
            API:Register("Menu", MenuAPI)

            --Create the settings API.
            local SettingsService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
            local SettingsAPI = {}
            function SettingsAPI:GetSetting(Setting: string): any
                return SettingsService:GetSetting(Setting)
            end
            function SettingsAPI:SetSetting(Setting: string, Value: any): ()
                SettingsService:SetSetting(Setting, Value)
            end
            function SettingsAPI:GetSettingsChangedSignal(Setting: string)
                return SettingsService:GetSettingsChangedSignal(Setting)
            end
            API:Register("Settings", SettingsAPI)
        end)
    end

    --Return the APIs.
    return API
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX43867F33DAA445FD92CBDD8297AE7EFE">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Character</string>
					<string name="ScriptGuid">{D21CE38C-15E6-4E69-A8D8-753A74DE12A3}</string>
					<ProtectedString name="Source"><![CDATA[--Manipulates a character model.
--!strict

local SMOOTHING_DURATION_SECONDS = 1 / 30

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local VRService = game:GetService("VRService")

local NexusVRCharacterModel = script.Parent
local Head = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Head"))
local Torso = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Torso"))
local AppendageLegacy = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Appendage"))
local Appendage = require(NexusVRCharacterModel:WaitForChild("NexusAppendage"):WaitForChild("Appendage"))
local FootPlanter = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("FootPlanter"))
local EnigmaService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("EnigmaService")).GetInstance()
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()
local UpdateInputs = NexusVRCharacterModel:WaitForChild("UpdateInputs") :: UnreliableRemoteEvent

local Character = {}
Character.__index = Character

export type Character = {
    CharacterModel: Model,
    Humanoid: Humanoid,
    Head: Head.Head,
    Torso: Torso.Torso,
    LeftArm: Appendage.Appendage,
    RightArm: Appendage.Appendage,
    LeftLeg: Appendage.Appendage,
    RightLeg: Appendage.Appendage,
    FootPlanter: any,
    CurrentWalkspeed: number,
    TweenComponents: boolean,
    UseIKControl: boolean,
    PreventArmDisconnection: boolean,
    Parts: {[string]: BasePart},
    Motors: {[string]: Motor6D},
    Attachments: {[string]: {[string]: Attachment}},
    CurrentMotor6DTransforms: {[Motor6D]: CFrame},
    LastMotor6DTransforms: {[Motor6D]: CFrame},
    LastRefreshTime: number,
    ReplicationCFrames: {[string]: CFrame}?,
    LastReplicationCFrames: {[string]: CFrame}?,
    ReplicationTrackerData: {[string]: CFrame}?,
    LastReplicationTrackerData: {[string]: CFrame}?,
    AppearanceChangedConnection: RBXScriptConnection?,
} & typeof(setmetatable({}, Character))



--[[
Creates a character.
--]]
function Character.new(CharacterModel: Model): Character
    local self = setmetatable({
        CharacterModel = CharacterModel,
        TweenComponents = (CharacterModel ~= Players.LocalPlayer.Character),
        UseIKControl = Settings:GetSetting("Extra.TEMPORARY_UseIKControl"),
    }, Character) :: Character

    --Determine if the arms can be disconnected.
    --Checking for the setting to be explicitly false is done in case the setting is undefined (default is true).
    local PreventArmDisconnection = false
    if Players.LocalPlayer and Players.LocalPlayer.Character == CharacterModel then
        local Setting = Settings:GetSetting("Appearance.LocalAllowArmDisconnection")
        if Setting == false then
            PreventArmDisconnection = true
        end
    else
        local Setting = Settings:GetSetting("Appearance.NonLocalAllowArmDisconnection")
        if Setting == false then
            PreventArmDisconnection = true
        end
    end

    --Store the body parts.
    self.Humanoid = CharacterModel:WaitForChild("Humanoid") :: Humanoid
    self.CurrentWalkspeed = 0
    self.Humanoid.Running:Connect(function(WalkSpeed)
        if VRService.AvatarGestures and VRInputService:GetThumbstickPosition(Enum.KeyCode.Thumbstick1).Magnitude < 0.2 then
            WalkSpeed = 0
        end
        self.CurrentWalkspeed = WalkSpeed
    end)

    --Set up the character parts.
    self.PreventArmDisconnection = PreventArmDisconnection
    self:SetUpVRParts()

    --Set up a connection for Character Appearance changes.
    self.AppearanceChangedConnection = nil :: RBXScriptConnection?
    self:SetUpAppearanceChanged()

    self.CurrentMotor6DTransforms = {}
    self.LastMotor6DTransforms = {}
    self.LastRefreshTime = tick()

    --Set up replication at 30hz.
    if Players.LocalPlayer and Players.LocalPlayer.Character == CharacterModel then
        task.spawn(function()
            while (self.Humanoid :: Humanoid).Health > 0 do
                --Send the new CFrames if the CFrames changed.
                local ReplicationCFrames = self.ReplicationCFrames
                local ReplicationTrackerData = self.ReplicationTrackerData
                if ReplicationCFrames and self.LastReplicationCFrames ~= ReplicationCFrames and self.LastReplicationTrackerData ~= ReplicationTrackerData then
                    self.LastReplicationCFrames = ReplicationCFrames
                    self.LastReplicationTrackerData = ReplicationTrackerData
                    local NewTrackerData = {
                        UpdateTime = tick(),
                        CurrentWalkspeed = self.CurrentWalkspeed,
                        LeftFootCFrame = ReplicationTrackerData and ReplicationTrackerData.LeftFoot,
                        RightFootCFrame = ReplicationTrackerData and ReplicationTrackerData.RightFoot,
                    }
                    if not VRService.AvatarGestures then
                        NewTrackerData.HeadCFrame = ReplicationCFrames.HeadCFrame
                        NewTrackerData.LeftHandCFrame = ReplicationCFrames.LeftHandCFrame
                        NewTrackerData.RightHandCFrame = ReplicationCFrames.RightHandCFrame
                    end
                    UpdateInputs:FireServer(NewTrackerData)
                end

                --Wait 1/30th of a second to send the next set of CFrames.
                task.wait(1 / 30)
            end
        end)
    end

    return self
end

--[[
Set up Character Parts for VR.
This is also used, to refresh character parts.
--]]
function Character.SetUpVRParts(self: Character): ()
    local CharacterModel = self.CharacterModel
    local PreventArmDisconnection = self.PreventArmDisconnection

    self.Parts = {
        Head = CharacterModel:WaitForChild("Head") :: BasePart,
        UpperTorso = CharacterModel:WaitForChild("UpperTorso") :: BasePart,
        LowerTorso = CharacterModel:WaitForChild("LowerTorso") :: BasePart,
        HumanoidRootPart = CharacterModel:WaitForChild("HumanoidRootPart") :: BasePart,
        RightUpperArm = CharacterModel:WaitForChild("RightUpperArm") :: BasePart,
        RightLowerArm = CharacterModel:WaitForChild("RightLowerArm") :: BasePart,
        RightHand = CharacterModel:WaitForChild("RightHand") :: BasePart,
        LeftUpperArm = CharacterModel:WaitForChild("LeftUpperArm") :: BasePart,
        LeftLowerArm = CharacterModel:WaitForChild("LeftLowerArm") :: BasePart,
        LeftHand = CharacterModel:WaitForChild("LeftHand") :: BasePart,
        RightUpperLeg = CharacterModel:WaitForChild("RightUpperLeg") :: BasePart,
        RightLowerLeg = CharacterModel:WaitForChild("RightLowerLeg") :: BasePart,
        RightFoot = CharacterModel:WaitForChild("RightFoot") :: BasePart,
        LeftUpperLeg = CharacterModel:WaitForChild("LeftUpperLeg") :: BasePart,
        LeftLowerLeg = CharacterModel:WaitForChild("LeftLowerLeg") :: BasePart,
        LeftFoot = CharacterModel:WaitForChild("LeftFoot") :: BasePart,
    }
    self.Motors = {
        Neck = self.Parts.Head:WaitForChild("Neck") :: Motor6D,
        Waist = self.Parts.UpperTorso:WaitForChild("Waist") :: Motor6D,
        Root = self.Parts.LowerTorso:WaitForChild("Root") :: Motor6D,
        RightShoulder = self.Parts.RightUpperArm:WaitForChild("RightShoulder") :: Motor6D,
        RightElbow = self.Parts.RightLowerArm:WaitForChild("RightElbow") :: Motor6D,
        RightWrist = self.Parts.RightHand:WaitForChild("RightWrist") :: Motor6D,
        LeftShoulder = self.Parts.LeftUpperArm:WaitForChild("LeftShoulder") :: Motor6D,
        LeftElbow = self.Parts.LeftLowerArm:WaitForChild("LeftElbow") :: Motor6D,
        LeftWrist = self.Parts.LeftHand:WaitForChild("LeftWrist") :: Motor6D,
        RightHip = self.Parts.RightUpperLeg:WaitForChild("RightHip") :: Motor6D,
        RightKnee = self.Parts.RightLowerLeg:WaitForChild("RightKnee") :: Motor6D,
        RightAnkle = self.Parts.RightFoot:WaitForChild("RightAnkle") :: Motor6D,
        LeftHip = self.Parts.LeftUpperLeg:WaitForChild("LeftHip") :: Motor6D,
        LeftKnee = self.Parts.LeftLowerLeg:WaitForChild("LeftKnee") :: Motor6D,
        LeftAnkle = self.Parts.LeftFoot:WaitForChild("LeftAnkle") :: Motor6D,
    }
    self.Attachments = {
        Head = {
            NeckRigAttachment = self.Parts.Head:WaitForChild("NeckRigAttachment") :: Attachment,
        },
        UpperTorso = {
            NeckRigAttachment = self.Parts.UpperTorso:WaitForChild("NeckRigAttachment") :: Attachment,
            LeftShoulderRigAttachment = self.Parts.UpperTorso:WaitForChild("LeftShoulderRigAttachment") :: Attachment,
            RightShoulderRigAttachment = self.Parts.UpperTorso:WaitForChild("RightShoulderRigAttachment") :: Attachment,
            WaistRigAttachment = self.Parts.UpperTorso:WaitForChild("WaistRigAttachment") :: Attachment,
        },
        LowerTorso = {
            WaistRigAttachment = self.Parts.LowerTorso:WaitForChild("WaistRigAttachment") :: Attachment,
            LeftHipRigAttachment = self.Parts.LowerTorso:WaitForChild("LeftHipRigAttachment") :: Attachment,
            RightHipRigAttachment = self.Parts.LowerTorso:WaitForChild("RightHipRigAttachment") :: Attachment,
            RootRigAttachment = self.Parts.LowerTorso:WaitForChild("RootRigAttachment") :: Attachment,
        },
        HumanoidRootPart = {
            RootRigAttachment = self.Parts.HumanoidRootPart:WaitForChild("RootRigAttachment") :: Attachment,
        },
        RightUpperArm = {
            RightShoulderRigAttachment = self.Parts.RightUpperArm:WaitForChild("RightShoulderRigAttachment") :: Attachment,
            RightElbowRigAttachment = self.Parts.RightUpperArm:WaitForChild("RightElbowRigAttachment") :: Attachment,
        },
        RightLowerArm = {
            RightElbowRigAttachment = self.Parts.RightLowerArm:WaitForChild("RightElbowRigAttachment") :: Attachment,
            RightWristRigAttachment = self.Parts.RightLowerArm:WaitForChild("RightWristRigAttachment") :: Attachment,
        },
        RightHand = {
            RightWristRigAttachment = self.Parts.RightHand:WaitForChild("RightWristRigAttachment") :: Attachment,
        },
        LeftUpperArm = {
            LeftShoulderRigAttachment = self.Parts.LeftUpperArm:WaitForChild("LeftShoulderRigAttachment") :: Attachment,
            LeftElbowRigAttachment = self.Parts.LeftUpperArm:WaitForChild("LeftElbowRigAttachment") :: Attachment,
        },
        LeftLowerArm = {
            LeftElbowRigAttachment = self.Parts.LeftLowerArm:WaitForChild("LeftElbowRigAttachment") :: Attachment,
            LeftWristRigAttachment = self.Parts.LeftLowerArm:WaitForChild("LeftWristRigAttachment") :: Attachment,
        },
        LeftHand = {
            LeftWristRigAttachment = self.Parts.LeftHand:WaitForChild("LeftWristRigAttachment") :: Attachment,
        },
        RightUpperLeg = {
            RightHipRigAttachment = self.Parts.RightUpperLeg:WaitForChild("RightHipRigAttachment") :: Attachment,
            RightKneeRigAttachment = self.Parts.RightUpperLeg:WaitForChild("RightKneeRigAttachment") :: Attachment,
        },
        RightLowerLeg = {
            RightKneeRigAttachment = self.Parts.RightLowerLeg:WaitForChild("RightKneeRigAttachment") :: Attachment,
            RightAnkleRigAttachment = self.Parts.RightLowerLeg:WaitForChild("RightAnkleRigAttachment") :: Attachment,
        },
        RightFoot = {
            RightAnkleRigAttachment = self.Parts.RightFoot:WaitForChild("RightAnkleRigAttachment") :: Attachment,
            RightFootAttachment = self.Parts.RightFoot:FindFirstChild("RightFootAttachment") :: Attachment,
        },
        LeftUpperLeg = {
            LeftHipRigAttachment = self.Parts.LeftUpperLeg:WaitForChild("LeftHipRigAttachment") :: Attachment,
            LeftKneeRigAttachment = self.Parts.LeftUpperLeg:WaitForChild("LeftKneeRigAttachment") :: Attachment,
        },
        LeftLowerLeg = {
            LeftKneeRigAttachment = self.Parts.LeftLowerLeg:WaitForChild("LeftKneeRigAttachment") :: Attachment,
            LeftAnkleRigAttachment = self.Parts.LeftLowerLeg:WaitForChild("LeftAnkleRigAttachment") :: Attachment,
        },
        LeftFoot = {
            LeftAnkleRigAttachment = self.Parts.LeftFoot:WaitForChild("LeftAnkleRigAttachment") :: Attachment,
            LeftFootAttachment = self.Parts.LeftFoot:FindFirstChild("LeftFootAttachment") :: Attachment,
        },
    }

    --Force IKControl when AnimationConstraints is active.
    if not self.Motors.Neck:IsA("Motor6D") then
        self.UseIKControl = true
    end

    --Add the missing attachments that not all rigs have.
    if not self.Attachments.RightFoot.RightFootAttachment then
        local NewAttachment = Instance.new("Attachment")
        NewAttachment.Position = Vector3.new(0, -(self.Parts.RightFoot :: BasePart).Size.Y / 2, 0)
        NewAttachment.Name = "RightFootAttachment"

        local OriginalPositionValue = Instance.new("Vector3Value")
        OriginalPositionValue.Name = "OriginalPosition"
        OriginalPositionValue.Value = NewAttachment.Position
        OriginalPositionValue.Parent = NewAttachment
        NewAttachment.Parent = self.Parts.RightFoot
        self.Attachments.RightFoot.RightFootAttachment = NewAttachment
    end
    if not self.Attachments.LeftFoot.LeftFootAttachment then
        local NewAttachment = Instance.new("Attachment")
        NewAttachment.Position = Vector3.new(0, -(self.Parts.LeftFoot :: BasePart).Size.Y / 2, 0)
        NewAttachment.Name = "LeftFootAttachment"

        local OriginalPositionValue = Instance.new("Vector3Value")
        OriginalPositionValue.Name = "OriginalPosition"
        OriginalPositionValue.Value = NewAttachment.Position
        OriginalPositionValue.Parent = NewAttachment
        NewAttachment.Parent = self.Parts.LeftFoot
        self.Attachments.LeftFoot.LeftFootAttachment = NewAttachment
    end

    --Store the limbs.
    self.Head = Head.new(self.Parts.Head :: BasePart)
    self.Torso = Torso.new(self.Parts.LowerTorso :: BasePart, self.Parts.UpperTorso :: BasePart)
    if self.UseIKControl then
        self.LeftArm = Appendage.FromPreset("LeftArm", CharacterModel, not PreventArmDisconnection, self.TweenComponents and 0.1 or 0)
        self.RightArm = Appendage.FromPreset("RightArm", CharacterModel, not PreventArmDisconnection, self.TweenComponents and 0.1 or 0)
        self.LeftLeg = Appendage.FromPreset("LeftLeg", CharacterModel, false, self.TweenComponents and 0.1 or 0)
        self.RightLeg = Appendage.FromPreset("RightLeg", CharacterModel, false, self.TweenComponents and 0.1 or 0)
    else
        local LeftArm = AppendageLegacy.new(CharacterModel:WaitForChild("LeftUpperArm") :: BasePart, CharacterModel:WaitForChild("LeftLowerArm") :: BasePart, CharacterModel:WaitForChild("LeftHand") :: BasePart, "LeftShoulderRigAttachment", "LeftElbowRigAttachment", "LeftWristRigAttachment", "LeftGripAttachment", PreventArmDisconnection)
        local RightArm = AppendageLegacy.new(CharacterModel:WaitForChild("RightUpperArm") :: BasePart, CharacterModel:WaitForChild("RightLowerArm") :: BasePart, CharacterModel:WaitForChild("RightHand") :: BasePart, "RightShoulderRigAttachment", "RightElbowRigAttachment", "RightWristRigAttachment", "RightGripAttachment", PreventArmDisconnection)
        local LeftLeg = AppendageLegacy.new(CharacterModel:WaitForChild("LeftUpperLeg") :: BasePart, CharacterModel:WaitForChild("LeftLowerLeg") :: BasePart, CharacterModel:WaitForChild("LeftFoot") :: BasePart, "LeftHipRigAttachment", "LeftKneeRigAttachment", "LeftAnkleRigAttachment", "LeftFootAttachment", true)
        LeftLeg.InvertBendDirection = true
        local RightLeg = AppendageLegacy.new(CharacterModel:WaitForChild("RightUpperLeg") :: BasePart, CharacterModel:WaitForChild("RightLowerLeg") :: BasePart, CharacterModel:WaitForChild("RightFoot") :: BasePart, "RightHipRigAttachment", "RightKneeRigAttachment", "RightAnkleRigAttachment", "RightFootAttachment", true)
        RightLeg.InvertBendDirection = true
        self.LeftArm = LeftArm :: any
        self.RightArm = RightArm :: any
        self.LeftLeg = LeftLeg :: any
        self.RightLeg = RightLeg :: any
    end
    self.FootPlanter = FootPlanter:CreateSolver(CharacterModel:WaitForChild("LowerTorso"), self.Humanoid:FindFirstChild("BodyHeightScale"))
end

--[[
This sets up a connection that fires when HumanoidDescription is added
under a Humanoid, to listen for appearance changes to refresh the character parts.
--]]
function Character.SetUpAppearanceChanged(self: Character): ()
    local CharacterModel = self.CharacterModel
    local Humanoid = CharacterModel:WaitForChild("Humanoid") :: Humanoid

    --Reset connection if it already exists
    if self.AppearanceChangedConnection then
        self.AppearanceChangedConnection:Disconnect()
        self.AppearanceChangedConnection = nil
    end

    self.AppearanceChangedConnection = Humanoid.ChildAdded:Connect(function(Child)
        --If a new HumanoidDescription appeared, then something changed on the avatar.
        --We should re-ensure that everything is still connected to NexusVR.
        if Child:IsA("HumanoidDescription") then
            --Refresh character parts
            self:SetUpVRParts()
        end
    end)    
end

--[[
Returns the scale value of the humanoid, or the default value.
--]]
function Character.GetHumanoidScale(self: Character, ScaleName: string): number
    local Value = self.Humanoid:FindFirstChild(ScaleName) :: NumberValue
    if Value then
        return Value.Value
    end
    return (ScaleName == "BodyTypeScale" and 0 or 1)
end

--[[
Returns the SeatPart of the humanoid.
SeatPart is not replicated to new players, which results in
strange movements of character.
https://devforum.roblox.com/t/seat-occupant-and-humanoid-seatpart-not-replicating-to-new-players-to-a-server/261545
--]]
function Character.GetHumanoidSeatPart(self: Character): BasePart?
    --Return nil if the Humanoid is not sitting.
    if not self.Humanoid.Sit then
        return nil
    end

    --Return if the seat part is defined.
    if self.Humanoid.SeatPart then
        return self.Humanoid.SeatPart
    end

    --Iterated through the connected parts and return if a seat exists.
    --While SeatPart may not be set, a SeatWeld does exist.
    for _, ConnectedPart in self.Parts.HumanoidRootPart:GetConnectedParts() do
        if ConnectedPart:IsA("Seat") or ConnectedPart:IsA("VehicleSeat") then
            return ConnectedPart
        end
    end
    return nil
end

--[[
Sets a property. The property will either be
set instantly or tweened depending on how
it is configured.
--]]
function Character.SetCFrameProperty(self: Character, Object: Instance, PropertyName: string, PropertyValue: any): ()
    if self.TweenComponents and PropertyName ~= "Transform" then
        TweenService:Create(
            Object,
            TweenInfo.new(SMOOTHING_DURATION_SECONDS, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {
                [PropertyName] = PropertyValue,
            }
        ):Play()
    else
        (Object :: any)[PropertyName] = PropertyValue
    end
    if PropertyName == "Transform" then
        self.CurrentMotor6DTransforms[Object :: Motor6D] = PropertyValue
    end
end

--[[
Sets the transform of a motor.
--]]
function Character.SetTransform(self: Character, MotorName: string, AttachmentName: string, StartLimbName: string, EndLimbName: string, StartCFrame: CFrame, EndCFrame: CFrame): ()
    self:SetCFrameProperty(self.Motors[MotorName], "Transform", (StartCFrame * self.Attachments[StartLimbName][AttachmentName].CFrame):Inverse() * (EndCFrame * self.Attachments[EndLimbName][AttachmentName].CFrame))
end

--[[
Refreshes the Motor6D Transforms.
Intended to be run for the local character after Stepped to override the animations.
--]]
function Character.RefreshCharacter(self: Character): ()
    if self.TweenComponents then
        local CurrentRefreshTime = tick()
        local SmoothRatio = math.min((CurrentRefreshTime - self.LastRefreshTime) / SMOOTHING_DURATION_SECONDS, 1)
        for Motor6D, Transform in self.CurrentMotor6DTransforms do
            local LastTransform = self.LastMotor6DTransforms[Motor6D]
            if LastTransform then
                Motor6D.Transform = LastTransform:Lerp(Transform, SmoothRatio)
            else
                Motor6D.Transform = Transform
            end
        end
    else
        for Motor6D, Transform in self.CurrentMotor6DTransforms do
            Motor6D.Transform = Transform
        end
    end
end

--[[
Updates the character from the inputs.
--]]
function Character.UpdateFromInputs(self: Character, HeadControllerCFrame: CFrame?, LeftHandControllerCFrame: CFrame?, RightHandControllerCFrame: CFrame?, CurrentWalkspeed: number?, TrackerData: {[string]: CFrame}?): ()
    --Return if the humanoid is dead.
    if self.Humanoid.Health <= 0 then
        return
    end

    --Call the other method if there is a SeatPart.
    --The math below is not used while in seats due to assumptions made while standing.
    --The CFrames will already be in local space from the replication.
    local SeatPart = self:GetHumanoidSeatPart()
    if SeatPart then
        self:UpdateFromInputsSeated(HeadControllerCFrame, LeftHandControllerCFrame, RightHandControllerCFrame)
        return
    end

    --Store the current Motor6D transforms.
    for Motor6D, _ in self.CurrentMotor6DTransforms do
        self.LastMotor6DTransforms[Motor6D] = Motor6D.Transform
    end
    self.LastRefreshTime = tick()

    --Get the CFrames.
    local CurrentHeadControllerCFrame = HeadControllerCFrame or (self.Parts.Head.CFrame * self.Head:GetEyesOffset())
    local HeadCFrame = self.Head:GetHeadCFrame(CurrentHeadControllerCFrame)
    local NeckCFrame = self.Head:GetNeckCFrame(CurrentHeadControllerCFrame)
    local LowerTorsoCFrame: CFrame, UpperTorsoCFrame = self.Torso:GetTorsoCFrames(NeckCFrame)
    local JointCFrames = self.Torso:GetAppendageJointCFrames(LowerTorsoCFrame, UpperTorsoCFrame)

    --Get the tracker CFrames from Enigma and fallback feet CFrames.
    local IsLocalCharacter = (Players.LocalPlayer and Players.LocalPlayer.Character == self.CharacterModel)
    local LeftFoot: CFrame, RightFoot: CFrame = self.FootPlanter:GetFeetCFrames()
    local LeftFootTrackerActive, RightFootTrackerActive = false, false
    if TrackerData and TrackerData.LeftFoot then
        LeftFoot = TrackerData.LeftFoot
        LeftFootTrackerActive = true
    else
        LeftFoot = LeftFoot * CFrame.Angles(0, math.pi, 0)
    end
    if TrackerData and TrackerData.RightFoot then
        RightFoot = TrackerData.RightFoot
        RightFootTrackerActive = true
    else
        RightFoot = RightFoot * CFrame.Angles(0, math.pi, 0)
    end
    if IsLocalCharacter then
        local NewTrackerCFrames = EnigmaService:GetCFrames(self)
        if NewTrackerCFrames.LeftFoot then
            LeftFoot = NewTrackerCFrames.LeftFoot
            LeftFootTrackerActive = true
        end
        if NewTrackerCFrames.RightFoot then
            RightFoot = NewTrackerCFrames.RightFoot
            RightFootTrackerActive = true
        end
        self.ReplicationTrackerData = {
            LeftFoot = NewTrackerCFrames.LeftFoot,
            RightFoot = NewTrackerCFrames.RightFoot,
        } :: {[string]: CFrame}
    end

    --Set the character CFrames.
    --HumanoidRootParts must always face up. This makes the math more complicated.
    --Setting the CFrame directly to something not facing directly up will result in the physics
    --attempting to correct that within the next frame, causing the character to appear to move.
    local AvatarGesturesEnabled = VRService.AvatarGestures
    local IsWalking = ((CurrentWalkspeed or self.CurrentWalkspeed) > 0.1)
    local TargetHumanoidRootPartCFrame = LowerTorsoCFrame * self.Attachments.LowerTorso.RootRigAttachment.CFrame * self.Attachments.HumanoidRootPart.RootRigAttachment.CFrame:Inverse()
    local ActualHumanoidRootPartCFrame: CFrame = self.Parts.HumanoidRootPart.CFrame
    local HumanoidRootPartHeightDifference = ActualHumanoidRootPartCFrame.Y - TargetHumanoidRootPartCFrame.Y
    local NewTargetHumanoidRootPartCFrame = CFrame.new(TargetHumanoidRootPartCFrame.Position) * CFrame.Angles(0, math.atan2(TargetHumanoidRootPartCFrame.LookVector.X, TargetHumanoidRootPartCFrame.LookVector.Z) + math.pi, 0)
    if not AvatarGesturesEnabled then
        self:SetCFrameProperty(self.Parts.HumanoidRootPart, "CFrame", CFrame.new(0, HumanoidRootPartHeightDifference, 0) * NewTargetHumanoidRootPartCFrame)
        self:SetCFrameProperty(self.Motors.Root, "Transform", CFrame.new(0, -HumanoidRootPartHeightDifference, 0) * (NewTargetHumanoidRootPartCFrame * self.Attachments.HumanoidRootPart.RootRigAttachment.CFrame):Inverse() * LowerTorsoCFrame * self.Attachments.LowerTorso.RootRigAttachment.CFrame)
        self:SetTransform("Neck", "NeckRigAttachment", "UpperTorso", "Head", UpperTorsoCFrame, HeadCFrame)
        self:SetTransform("Waist", "WaistRigAttachment", "LowerTorso", "UpperTorso", LowerTorsoCFrame, UpperTorsoCFrame)
    end
    if self.UseIKControl then
        if not AvatarGesturesEnabled and LeftHandControllerCFrame and RightHandControllerCFrame then --CFrames aren't send with AvatarGestures. Checks included for typing.
            self.LeftArm:MoveToWorld(LeftHandControllerCFrame)
            self.RightArm:MoveToWorld(RightHandControllerCFrame)
        end
        if not IsWalking and (not AvatarGesturesEnabled or LeftFootTrackerActive) then
            self.LeftLeg:MoveToWorld(LeftFoot)
            self.LeftLeg:Enable()
        else
            self.LeftLeg:Disable()
        end
        if not IsWalking and (not AvatarGesturesEnabled or RightFootTrackerActive) then
            self.RightLeg:MoveToWorld(RightFoot)
            self.RightLeg:Enable()
        else
            self.RightLeg:Disable()
        end
    else
        if not AvatarGesturesEnabled then
            local LeftUpperArmCFrame, LeftLowerArmCFrame, LeftHandCFrame = (self.LeftArm :: any):GetAppendageCFrames(JointCFrames["LeftShoulder"], LeftHandControllerCFrame)
            local RightUpperArmCFrame, RightLowerArmCFrame, RightHandCFrame = (self.RightArm :: any):GetAppendageCFrames(JointCFrames["RightShoulder"], RightHandControllerCFrame)
            self:SetTransform("RightShoulder", "RightShoulderRigAttachment", "UpperTorso", "RightUpperArm", UpperTorsoCFrame, RightUpperArmCFrame)
            self:SetTransform("RightElbow", "RightElbowRigAttachment", "RightUpperArm", "RightLowerArm", RightUpperArmCFrame, RightLowerArmCFrame)
            self:SetTransform("RightWrist", "RightWristRigAttachment", "RightLowerArm", "RightHand", RightLowerArmCFrame, RightHandCFrame)
            self:SetTransform("LeftShoulder", "LeftShoulderRigAttachment", "UpperTorso", "LeftUpperArm", UpperTorsoCFrame, LeftUpperArmCFrame)
            self:SetTransform("LeftElbow", "LeftElbowRigAttachment", "LeftUpperArm", "LeftLowerArm", LeftUpperArmCFrame, LeftLowerArmCFrame)
            self:SetTransform("LeftWrist", "LeftWristRigAttachment", "LeftLowerArm", "LeftHand", LeftLowerArmCFrame, LeftHandCFrame)
        end
        if not IsWalking and (not AvatarGesturesEnabled or LeftFootTrackerActive) then
            local LeftUpperLegCFrame, LeftLowerLegCFrame, LeftFootCFrame = (self.LeftLeg :: any):GetAppendageCFrames(JointCFrames["LeftHip"], LeftFoot)
            self:SetTransform("LeftHip", "LeftHipRigAttachment", "LowerTorso", "LeftUpperLeg", LowerTorsoCFrame, LeftUpperLegCFrame)
            self:SetTransform("LeftKnee", "LeftKneeRigAttachment", "LeftUpperLeg", "LeftLowerLeg", LeftUpperLegCFrame, LeftLowerLegCFrame)
            self:SetTransform("LeftAnkle", "LeftAnkleRigAttachment", "LeftLowerLeg", "LeftFoot", LeftLowerLegCFrame, LeftFootCFrame)
        else
            self.CurrentMotor6DTransforms[self.Motors.LeftHip] = nil
            self.CurrentMotor6DTransforms[self.Motors.LeftKnee] = nil
            self.CurrentMotor6DTransforms[self.Motors.LeftAnkle] = nil
        end
        if not IsWalking and (not AvatarGesturesEnabled or RightFootTrackerActive) then
            local RightUpperLegCFrame, RightLowerLegCFrame, RightFootCFrame = (self.RightLeg :: any):GetAppendageCFrames(JointCFrames["RightHip"], RightFoot)
            self:SetTransform("RightHip", "RightHipRigAttachment", "LowerTorso", "RightUpperLeg", LowerTorsoCFrame, RightUpperLegCFrame)
            self:SetTransform("RightKnee", "RightKneeRigAttachment", "RightUpperLeg", "RightLowerLeg", RightUpperLegCFrame, RightLowerLegCFrame)
            self:SetTransform("RightAnkle", "RightAnkleRigAttachment", "RightLowerLeg", "RightFoot", RightLowerLegCFrame, RightFootCFrame)
        else
            self.CurrentMotor6DTransforms[self.Motors.RightHip] = nil
            self.CurrentMotor6DTransforms[self.Motors.RightKnee] = nil
            self.CurrentMotor6DTransforms[self.Motors.RightAnkle] = nil
        end
    end

    --Replicate the changes to the server.
    if IsLocalCharacter then
        self.ReplicationCFrames = {
            HeadCFrame = HeadControllerCFrame :: CFrame,
            LeftHandCFrame = LeftHandControllerCFrame :: CFrame,
            RightHandCFrame = RightHandControllerCFrame :: CFrame,
        }
    end
end

--[[
Updates the character from the inputs while seated.
The CFrames are in the local space instead of global space
since the seat maintains the global space.
--]]
function Character.UpdateFromInputsSeated(self: Character, HeadControllerCFrame: CFrame?, LeftHandControllerCFrame: CFrame?, RightHandControllerCFrame: CFrame?): ()
    --Return if the humanoid is dead.
    if self.Humanoid.Health <= 0 then
        return
    end
    if VRService.AvatarGestures or not HeadControllerCFrame or not LeftHandControllerCFrame or not RightHandControllerCFrame then --CFrames aren't send with AvatarGestures. Checks included for typing.
        return
    end

    --Get the CFrames.
    local HeadCFrame = self.Head:GetHeadCFrame(HeadControllerCFrame)
    local NeckCFrame = self.Head:GetNeckCFrame(HeadControllerCFrame,0)
    local LowerTorsoCFrame, UpperTorsoCFrame = self.Torso:GetTorsoCFrames(NeckCFrame)
    local JointCFrames = self.Torso:GetAppendageJointCFrames(LowerTorsoCFrame,UpperTorsoCFrame)
    local EyesOffset = self.Head:GetEyesOffset()
    local HeightOffset = CFrame.new(0, (CFrame.new(0, EyesOffset.Y, 0) * (HeadControllerCFrame * EyesOffset:Inverse())).Y, 0)

    --Set the head, toros, and arm CFrames.
    self:SetCFrameProperty(self.Motors.Root, "Transform", HeightOffset * CFrame.new(0, -LowerTorsoCFrame.Y, 0) * LowerTorsoCFrame)
    self:SetTransform("Neck", "NeckRigAttachment", "UpperTorso", "Head", UpperTorsoCFrame, HeadCFrame)
    self:SetTransform("Waist", "WaistRigAttachment", "LowerTorso", "UpperTorso", LowerTorsoCFrame, UpperTorsoCFrame)
    if self.UseIKControl then
        local HeadWorldSpaceCFrame = (self.Parts.Head.CFrame :: CFrame) * EyesOffset
        self.LeftArm:MoveToWorld(HeadWorldSpaceCFrame * HeadControllerCFrame:Inverse() * LeftHandControllerCFrame)
        self.RightArm:MoveToWorld(HeadWorldSpaceCFrame * HeadControllerCFrame:Inverse() * RightHandControllerCFrame)
        self.LeftLeg:Disable()
        self.RightLeg:Disable()
    else
        local LeftUpperArmCFrame, LeftLowerArmCFrame, LeftHandCFrame = (self.LeftArm:: any):GetAppendageCFrames(JointCFrames["LeftShoulder"], LeftHandControllerCFrame)
        local RightUpperArmCFrame, RightLowerArmCFrame, RightHandCFrame = (self.RightArm:: any):GetAppendageCFrames(JointCFrames["RightShoulder"], RightHandControllerCFrame)
        self:SetTransform("RightShoulder", "RightShoulderRigAttachment", "UpperTorso", "RightUpperArm", UpperTorsoCFrame, RightUpperArmCFrame)
        self:SetTransform("RightElbow", "RightElbowRigAttachment", "RightUpperArm", "RightLowerArm", RightUpperArmCFrame, RightLowerArmCFrame)
        self:SetTransform("RightWrist", "RightWristRigAttachment", "RightLowerArm", "RightHand", RightLowerArmCFrame, RightHandCFrame)
        self:SetTransform("LeftShoulder", "LeftShoulderRigAttachment", "UpperTorso", "LeftUpperArm", UpperTorsoCFrame, LeftUpperArmCFrame)
        self:SetTransform("LeftElbow", "LeftElbowRigAttachment", "LeftUpperArm", "LeftLowerArm", LeftUpperArmCFrame, LeftLowerArmCFrame)
        self:SetTransform("LeftWrist", "LeftWristRigAttachment", "LeftLowerArm", "LeftHand", LeftLowerArmCFrame, LeftHandCFrame)
    end

    --Reset the leg transforms to allow for animations.
    self.CurrentMotor6DTransforms[self.Motors.RightHip] = nil
    self.CurrentMotor6DTransforms[self.Motors.LeftHip] = nil
    self.CurrentMotor6DTransforms[self.Motors.RightKnee] = nil
    self.CurrentMotor6DTransforms[self.Motors.LeftKnee] = nil
    self.CurrentMotor6DTransforms[self.Motors.RightAnkle] = nil
    self.CurrentMotor6DTransforms[self.Motors.LeftAnkle] = nil

    --Replicate the changes to the server.
    if Players.LocalPlayer and Players.LocalPlayer.Character == self.CharacterModel then
        self.ReplicationCFrames = {
            HeadCFrame = HeadControllerCFrame,
            LeftHandCFrame = LeftHandControllerCFrame,
            RightHandCFrame = RightHandControllerCFrame,
        }
    end
end



return Character]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX7DE13CF0381D4676A5F2D3F0D11551E8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Appendage</string>
						<string name="ScriptGuid">{3EC5E49E-9CB0-40B8-9F6E-8B79DB8DAE43}</string>
						<ProtectedString name="Source"><![CDATA[ --Stores information about an appendage, such as an arm or a leg.
--!strict

local Limb = require(script.Parent.Parent:WaitForChild("NexusAppendage"):WaitForChild("Limb"))

local Appendage = {}
Appendage.__index = Appendage
setmetatable(Appendage, Limb)

export type Appendage = {
    UpperLimb: BasePart,
    LowerLimb: BasePart,
    LimbEnd: BasePart,
    StartAttachment: string,
    LimbJointAttachment: string,
    LimbEndAttachment: string,
    LimbHoldAttachment: string,
    InvertBendDirection: boolean,
    PreventDisconnection: boolean, 
} & typeof(setmetatable({}, Appendage)) & Limb.Limb


--[[
Creates an appendage.
--]]
function Appendage.new(UpperLimb: BasePart, LowerLimb: BasePart, LimbEnd: BasePart, StartAttachment: string, LimbJointAttachment: string, LimbEndAttachment: string, LimbHoldAttachment: string, PreventDisconnection: boolean?): Appendage
    local self = setmetatable(Limb.new() :: any, Appendage)
    self.UpperLimb = UpperLimb
    self.LowerLimb = LowerLimb
    self.LimbEnd = LimbEnd
    self.StartAttachment = StartAttachment
    self.LimbJointAttachment = LimbJointAttachment
    self.LimbEndAttachment = LimbEndAttachment
    self.LimbHoldAttachment = LimbHoldAttachment
    self.InvertBendDirection = false
    self.PreventDisconnection = PreventDisconnection or false
    return setmetatable(self, Appendage)
end

--[[
Attempts to solve a joint. This uses
the "naive" approach for inverse kinematics.
--]]
function Appendage.SolveJoint(self: Appendage, OriginCFrame: CFrame, TargetPosition: Vector3, Length1: number, Length2: number): (CFrame, number, number)
    local LocalizedPosition = OriginCFrame:PointToObjectSpace(TargetPosition)
    local LocalizedUnit = LocalizedPosition.Unit
    local Hypotenuse = LocalizedPosition.Magnitude

    --Get the axis and correct it if it is 0.
    local Axis = Vector3.new(0, 0, -1):Cross(LocalizedUnit)
    if Axis == Vector3.new(0, 0, 0) then
        if LocalizedPosition.Z < 0 then
            Axis = Vector3.new(0, 0, 0.001)
        else
            Axis = Vector3.new(0, 0, -0.001)
        end
    end

    --Calculate and return the angles.
    local PlaneRotation = math.acos(-LocalizedUnit.Z)
    local PlaneCFrame = OriginCFrame * CFrame.fromAxisAngle(Axis, PlaneRotation)
    if Hypotenuse < math.max(Length2, Length1) - math.min(Length2, Length1) then
        local ShoulderAngle, ElbowAngle = -math.pi / 2, math.pi
        if self.PreventDisconnection then
            return PlaneCFrame, ShoulderAngle, ElbowAngle
        else
            return PlaneCFrame * CFrame.new(0, 0, math.max(Length2, Length1) - math.min(Length2, Length1) - Hypotenuse), ShoulderAngle, ElbowAngle
        end
    elseif Hypotenuse > Length1 + Length2 then
        local ShoulderAngle, ElbowAngle = math.pi / 2, 0
        if self.PreventDisconnection then
            return PlaneCFrame, ShoulderAngle, ElbowAngle
        else
            return PlaneCFrame * CFrame.new(0, 0, Length1 + Length2 - Hypotenuse), ShoulderAngle, ElbowAngle
        end
    else
        local Angle1 = -math.acos((-(Length2 * Length2) + (Length1 * Length1) + (Hypotenuse * Hypotenuse)) / (2 * Length1 * Hypotenuse))
        local Angle2 = math.acos(((Length2  * Length2) - (Length1 * Length1) + (Hypotenuse * Hypotenuse)) / (2 * Length2 * Hypotenuse))
        if self.InvertBendDirection then
            Angle1 = -Angle1
            Angle2 = -Angle2
        end
        return PlaneCFrame , Angle1 + math.pi / 2, Angle2 - Angle1
    end
end

--[[
Returns the rotation offset relative to the Y axis
to an end CFrame.
--]]
function Appendage.RotationTo(self: Appendage, StartCFrame: CFrame, EndCFrame: CFrame): CFrame
	local Offset = (StartCFrame:Inverse() * EndCFrame).Position
	return CFrame.Angles(math.atan2(Offset.Z, Offset.Y), 0, -math.atan2(Offset.X, Offset.Y))
end

--[[
Returns the CFrames of the appendage for
the starting and holding CFrames. The implementation
works, but could be improved.
--]]
function Appendage.GetAppendageCFrames(self: Appendage, StartCFrame: CFrame, HoldCFrame: CFrame): (CFrame, CFrame, CFrame)
    --Get the attachment CFrames.
    local LimbHoldCFrame = self:GetAttachmentCFrame(self.LimbEnd, self.LimbHoldAttachment)
    local LimbEndCFrame = self:GetAttachmentCFrame(self.LimbEnd, self.LimbEndAttachment)
    local UpperLimbStartCFrame = self:GetAttachmentCFrame(self.UpperLimb, self.StartAttachment)
    local UpperLimbJointCFrame = self:GetAttachmentCFrame(self.UpperLimb, self.LimbJointAttachment)
    local LowerLimbJointCFrame = self:GetAttachmentCFrame(self.LowerLimb, self.LimbJointAttachment)
    local LowerLimbEndCFrame = self:GetAttachmentCFrame(self.LowerLimb, self.LimbEndAttachment)

    --Calculate the appendage lengths.
    local UpperLimbLength = (UpperLimbStartCFrame.Position - UpperLimbJointCFrame.Position).Magnitude
    local LowerLimbLength = (LowerLimbJointCFrame.Position - LowerLimbEndCFrame.Position).Magnitude

    --Calculate the end point of the limb.
    local AppendageEndJointCFrame = HoldCFrame * LimbHoldCFrame:Inverse() * LimbEndCFrame

    --Solve the join.
    local PlaneCFrame,UpperAngle,CenterAngle = self:SolveJoint(StartCFrame, AppendageEndJointCFrame.Position, UpperLimbLength, LowerLimbLength)

    --Calculate the CFrame of the limb join before and after the center angle.
    local JointUpperCFrame = PlaneCFrame * CFrame.Angles(UpperAngle, 0, 0) * CFrame.new(0, -UpperLimbLength, 0)
    local JointLowerCFrame = JointUpperCFrame * CFrame.Angles(CenterAngle, 0, 0)

    --Calculate the part CFrames.
    --The appendage end is not calculated with hold CFrame directly since it can ignore PreventDisconnection = true.
    local UpperLimbCFrame = JointUpperCFrame * self:RotationTo(UpperLimbJointCFrame, UpperLimbStartCFrame):Inverse() * UpperLimbJointCFrame:Inverse()
    local LowerLimbCFrame = JointLowerCFrame * self:RotationTo(LowerLimbEndCFrame, LowerLimbJointCFrame):Inverse() * LowerLimbJointCFrame:Inverse()
    local AppendageEndCFrame = CFrame.new((LowerLimbCFrame * LowerLimbEndCFrame).Position) * (CFrame.new(-AppendageEndJointCFrame.Position) * AppendageEndJointCFrame) * LimbEndCFrame:Inverse()

    --Return the part CFrames.
    return UpperLimbCFrame, LowerLimbCFrame, AppendageEndCFrame
end



return Appendage]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBXD2AF2164D3684EF9949F359273DE6FA2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Camera</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX40BA0752DE5E4941A1628087E2904F30">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CommonCamera</string>
							<string name="ScriptGuid">{D90EC1BE-58D0-47FD-9CDB-6B773F59C6C7}</string>
							<ProtectedString name="Source"><![CDATA[--Common camera functionality.
--!strict

local Workspace = game:GetService("Workspace")
local VRService = game:GetService("VRService")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()

local CommonCamera = {}
CommonCamera.__index = CommonCamera

export type CommonCamera = typeof(setmetatable({}, CommonCamera))



--[[
Creates the common camera.
--]]
function CommonCamera.new(): CommonCamera
    return setmetatable({}, CommonCamera)
end

--[[
Enables the camera.
--]]
function CommonCamera.Enable(self: CommonCamera): ()

end

--[[
Disables the camera.
--]]
function CommonCamera.Disable(self: CommonCamera): ()

end

--[[
Updates the camera.
--]]
function CommonCamera.UpdateCamera(self: CommonCamera, HeadsetCFrameWorld: CFrame): ()

end

--[[
Sets the camera CFrame.
--]]
function CommonCamera.SetCFrame(self: CommonCamera, HeadsetCFrameWorld: CFrame): ()
    --Lock HeadLocked to false.
    --The default behavior is to do it for backwards compatibility with 2.6.0 and earlier.
    local Camera = Workspace.CurrentCamera
    if Settings:GetSetting("Camera.DisableHeadLocked") ~= false then
        Camera.HeadLocked = false
    end

    --Set the camera CFrame.
    local TargetCFrame = HeadsetCFrameWorld
    if Camera.HeadLocked then
        local HeadCFrame = VRService:GetUserCFrame(Enum.UserCFrame.Head)
        TargetCFrame = HeadsetCFrameWorld * (CFrame.new(HeadCFrame.Position * (Workspace.CurrentCamera.HeadScale - 1)) * HeadCFrame):Inverse()
        Camera.VRTiltAndRollEnabled = true
    end
    Camera.CameraType = Enum.CameraType.Scriptable
    Camera.CFrame = TargetCFrame
    Camera.Focus = TargetCFrame
end



return CommonCamera]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX9BC6A821813C411CA108C01C7207E401">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">DefaultCamera</string>
							<string name="ScriptGuid">{9534FFCB-559A-497B-9E19-978A24DD65A5}</string>
							<ProtectedString name="Source"><![CDATA[--Default camera that follows the character.
--!strict

local BUMP_DEFAULT_TRANSPARENCY_WORKAROUND = true
local HIDDEN_ACCESSORIES = {
    [Enum.AccessoryType.Hat] = true;
    [Enum.AccessoryType.Hair] = true;
    [Enum.AccessoryType.Face] = true;
    [Enum.AccessoryType.Eyebrow] = true;
    [Enum.AccessoryType.Eyelash] = true;
}

local Players = game:GetService("Players")
local VRService = game:GetService("VRService")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local CommonCamera = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Camera"):WaitForChild("CommonCamera"))
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()

local DefaultCamera = {}
DefaultCamera.__index = DefaultCamera
setmetatable(DefaultCamera, CommonCamera)

export type DefaultCamera = {
    TransparencyEvents: {RBXScriptConnection}?,
} & typeof(setmetatable({}, DefaultCamera)) & CommonCamera.CommonCamera



--[[
Returns true if the provided part should be hidden in first person.
--]]
function DefaultCamera.ShouldHidePart(Part: BasePart): boolean
    local Parent: Instance? = Part.Parent
    if Parent then
        if Parent:IsA("Accessory") then
            local AccessoryType = Parent.AccessoryType
            return HIDDEN_ACCESSORIES[AccessoryType] or false
        elseif Parent:IsA("Model") then
            return false
        else
            return not Parent:IsA("Tool")
        end
    end

    if Part:FindFirstChildWhichIsA("WrapLayer") then
        return false
    end

    return true
end

--[[
Creates a default camera object.
--]]
function DefaultCamera.new(): DefaultCamera
    return setmetatable(CommonCamera.new() :: any, DefaultCamera) :: DefaultCamera
end

--[[
Enables the camera.
--]]
function DefaultCamera.Enable(self: DefaultCamera): ()
    local TransparencyEvents = {}
    self.TransparencyEvents = TransparencyEvents

    if Players.LocalPlayer.Character then
        --Connect children being added.
        local Transparency = Settings:GetSetting("Appearance.LocalCharacterTransparency")
        if BUMP_DEFAULT_TRANSPARENCY_WORKAROUND then
            if Transparency == 0.5 then
                Transparency = 0.501
            elseif Transparency < 0.5 then
                warn("Values of <0.5 with Appearance.LocalCharacterTransparency are currently known to cause black screen issues. This will hopefully be resolved by Roblox in a future update: https://devforum.roblox.com/t/vr-screen-becomes-black-due-to-non-transparent-character/2215099")
            end
        end
        table.insert(TransparencyEvents, Players.LocalPlayer.Character.DescendantAdded:Connect(function(Part: BasePart)
            if Part:IsA("BasePart") then
                local PartTransparency = Transparency
                if Part:FindFirstAncestorOfClass("Tool") then
                    PartTransparency = 0
                elseif DefaultCamera.ShouldHidePart(Part) then
                    PartTransparency = 1
                end

                Part.LocalTransparencyModifier = PartTransparency
                table.insert(TransparencyEvents, Part:GetPropertyChangedSignal("LocalTransparencyModifier"):Connect(function()
                    Part.LocalTransparencyModifier = PartTransparency
                end))
            end
        end))
        for _, Part in Players.LocalPlayer.Character:GetDescendants() do
            if Part:IsA("BasePart") then
                local PartTransparency = Transparency
                if Part:FindFirstAncestorOfClass("Tool") then
                    PartTransparency = 0
                elseif DefaultCamera.ShouldHidePart(Part) then
                    PartTransparency = 1
                end
                
                Part.LocalTransparencyModifier = PartTransparency
                table.insert(TransparencyEvents, Part:GetPropertyChangedSignal("LocalTransparencyModifier"):Connect(function()
                    Part.LocalTransparencyModifier = PartTransparency
                end))
            end
        end
    end

    --Connect the character and local transparency changing.
    table.insert(TransparencyEvents, Players.LocalPlayer:GetPropertyChangedSignal("Character"):Connect(function()
        self:Disable()
        self:Enable()
    end))
    table.insert(TransparencyEvents, Settings:GetSettingsChangedSignal("Appearance.LocalCharacterTransparency"):Connect(function()
        self:Disable()
        self:Enable()
    end) :: any)

    --Keep the camera in first person.
    if VRService.AvatarGestures then
        Players.LocalPlayer.CameraMaxZoomDistance = Players.LocalPlayer.CameraMinZoomDistance
    end
end

--[[
Disables the camera.
--]]
function DefaultCamera.Disable(self: DefaultCamera): ()
    --Disconnect the character events.
    if self.TransparencyEvents then
        for _, Event in self.TransparencyEvents do
            Event:Disconnect()
        end
        self.TransparencyEvents = {}
    end

    --Reset the local transparency modifiers.
    if Players.LocalPlayer.Character then
        for _, Part in Players.LocalPlayer.Character:GetDescendants() do
            if Part:IsA("BasePart") then
                Part.LocalTransparencyModifier = 0
            end
        end
    end
end

--[[
Updates the camera.
--]]
function DefaultCamera.UpdateCamera(self: DefaultCamera, HeadsetCFrameWorld: CFrame): ()
    if VRService.AvatarGestures then return end
    self:SetCFrame(HeadsetCFrameWorld)
end



return DefaultCamera]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX11C5A774C5B144BE9764E0593007049A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ThirdPersonTrackCamera</string>
							<string name="ScriptGuid">{AFB69696-AEA3-4470-8E24-8E387C9AEF2E}</string>
							<ProtectedString name="Source"><![CDATA[--Third person camera that moves with the player.
--!strict

local THIRD_PERSON_ZOOM = 10

local Players = game:GetService("Players")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local CommonCamera = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Camera"):WaitForChild("CommonCamera"))

local ThirdPersonTrackCamera = {}
ThirdPersonTrackCamera.__index = ThirdPersonTrackCamera
setmetatable(ThirdPersonTrackCamera, CommonCamera)

export type ThirdPersonTrackCamera = {
    FetchInitialCFrame: boolean?,
    BaseFaceAngleY: number?,
    BaseCFrame: CFrame?,
} & typeof(setmetatable({}, ThirdPersonTrackCamera)) & CommonCamera.CommonCamera


--[[
Creates a third-person camera object.
--]]
function ThirdPersonTrackCamera.new(): ThirdPersonTrackCamera
    return setmetatable(CommonCamera.new() :: any, ThirdPersonTrackCamera) :: ThirdPersonTrackCamera
end

--[[
Enables the camera.
--]]
function ThirdPersonTrackCamera.Enable(self: ThirdPersonTrackCamera): ()
    self.FetchInitialCFrame = true
end

--[[
Disables the camera.
--]]
function ThirdPersonTrackCamera.Disable(self: ThirdPersonTrackCamera): ()
    self.FetchInitialCFrame = nil
end

--[[
Updates the camera.
--]]
function ThirdPersonTrackCamera.UpdateCamera(self: ThirdPersonTrackCamera, HeadsetCFrameWorld: CFrame): ()
    --Set the initial CFrame to use.
    if self.FetchInitialCFrame then
        local BaseFaceAngleY = math.atan2(-HeadsetCFrameWorld.LookVector.X, -HeadsetCFrameWorld.LookVector.Z)
        self.BaseFaceAngleY = BaseFaceAngleY
        self.BaseCFrame = CFrame.new(HeadsetCFrameWorld.Position) * CFrame.Angles(0, BaseFaceAngleY, 0)
        self.FetchInitialCFrame = nil
    end

    --Get the scale.
    local Scale = 1
    local Character = Players.LocalPlayer.Character
    if Character then
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        if Humanoid then
            local BodyHeightScale = Humanoid:FindFirstChild("BodyHeightScale")
            if BodyHeightScale then
                Scale = BodyHeightScale.Value
            end
        end
    end

    --Calculate the third person CFrame.
    local BaseCFrame = self.BaseCFrame :: CFrame
    local HeadsetRelative = BaseCFrame:Inverse() * HeadsetCFrameWorld
    local TargetCFrame = BaseCFrame * CFrame.new(0, 0, -THIRD_PERSON_ZOOM * Scale) * CFrame.Angles(0, math.pi, 0) * HeadsetRelative

    --Update the camera.
    self:SetCFrame(TargetCFrame)
end



return ThirdPersonTrackCamera]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXE6A1ED8DD203495E93957BC301427C6E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Controller</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX564C2FB067A8440EB8F21A0A01374F2B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BaseController</string>
							<string name="ScriptGuid">{87170241-D7CD-4669-B637-E6C961277BF5}</string>
							<ProtectedString name="Source"><![CDATA[ --Base class for controlling the local character.
--!strict

local THUMBSTICK_INPUT_START_RADIUS = 0.6
local THUMBSTICK_INPUT_RELEASE_RADIUS = 0.4
local THUMBSTICK_SNAP_ROTATION_ANGLE = math.rad(30) --Roblox's snap rotation is 30 degrees.
local THUMBSTICK_SMOOTH_LOCOMOTION_DEADZONE = 0.2
local THUMBSTICK_MANUAL_SMOOTH_ROTATION_RATE = math.rad(360) --May or may not be accurate for Roblox's player scripts.
local BLUR_TWEEN_INFO = TweenInfo.new(0.25, Enum.EasingStyle.Quad)
local USER_CFRAME_TO_THUMBSTICK = {
    [Enum.UserCFrame.LeftHand] = Enum.KeyCode.Thumbstick1,
    [Enum.UserCFrame.RightHand] = Enum.KeyCode.Thumbstick2,
}

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local ContextActionService = game:GetService("ContextActionService")
local TweenService = game:GetService("TweenService")
local VRService = game:GetService("VRService")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local NexusVRCharacterModelApi = require(NexusVRCharacterModel).Api
local Character = require(NexusVRCharacterModel:WaitForChild("Character"))
local CameraService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CameraService")).GetInstance()
local CharacterService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CharacterService")).GetInstance()
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()

local BaseController = {}
BaseController.__index = BaseController

export type BaseController = {
    Active: boolean,
    ActionsToLock: {Enum.KeyCode},
    ActionsToUnbind: {Enum.KeyCode}?,
    Character: Character.Character?,
    Connections: {RBXScriptConnection}?,
    LastHeadCFrame: CFrame?,
    LastRotationUpdateTick: number?,
} & typeof(setmetatable({}, BaseController))



--[[
Returns the Y-axis angle of the given CFrame.
--]]
local function GetAngleToGlobalY(CF: CFrame): number
    return math.atan2(-CF.LookVector.X, -CF.LookVector.Z)
end

--[[
Creates a base controller object.
--]]
function BaseController.new(): BaseController
    return setmetatable({
        Active = false,
        ActionsToLock = {Enum.KeyCode.ButtonR3},
    }, BaseController) :: BaseController
end

--[[
Updates the character. Returns if it changed.
--]]
function BaseController.UpdateCharacterReference(self: BaseController): boolean
    local LastCharacter = self.Character
    self.Character = CharacterService:GetCharacter(Players.LocalPlayer)
    if not self.Character then
        return false
    end
    return LastCharacter ~= self.Character
end

--[[
Enables the controller.
--]]
function BaseController.Enable(self: BaseController): ()
    if not self.Connections then self.Connections = {} end
    self.Active = true

    --Bind the actions to sink inputs from the PlayerScripts.
    if not self.ActionsToUnbind then self.ActionsToUnbind = {} end
    for _, KeyCode in self.ActionsToLock do
        local ActionName = HttpService:GenerateGUID()
        ContextActionService:BindActionAtPriority(ActionName, function()
            return self.Active and Enum.ContextActionResult.Sink or Enum.ContextActionResult.Pass
        end, false, Enum.ContextActionPriority.High.Value, KeyCode)
        table.insert(self.ActionsToUnbind :: {Enum.KeyCode}, ActionName)
    end

    --Update the character and return if the character is nil.
    self:UpdateCharacterReference()
    if not self.Character then
        return
    end

    --Connect the eye level being set.
    local Connections = self.Connections :: {RBXScriptConnection}
    table.insert(Connections, VRInputService.EyeLevelSet:Connect(function()
        local LastHeadCFrame = self.LastHeadCFrame
        if LastHeadCFrame and LastHeadCFrame.Y > 0 then
            self.LastHeadCFrame = CFrame.new(0, -LastHeadCFrame.Y, 0) * LastHeadCFrame
        end
    end) :: any)

    --Connect the character entering a seat.
    table.insert(Connections, self.Character.Humanoid:GetPropertyChangedSignal("SeatPart"):Connect(function()
        local SeatPart = self.Character:GetHumanoidSeatPart()
        if SeatPart then
            self:PlayBlur()
            VRInputService:Recenter()
        end
    end))

    --Disable auto rotate so that the default controls work.
    self.Character.Humanoid.AutoRotate = false
end

--[[
Disables the controller.
--]]
function BaseController.Disable(self: BaseController): ()
    self.Active = false
    self.Character = nil
    self.LastHeadCFrame = nil
    self.LastRotationUpdateTick = nil
    if self.Connections then
        for _, Connection in self.Connections do
            Connection:Disconnect()
        end
    end
    if self.ActionsToUnbind then
        for _, ActionName in self.ActionsToUnbind do
            ContextActionService:UnbindAction(ActionName)
        end
    end
    self.Connections = nil
end

--[[
Scales the local-space input CFrame based on
the height multiplier of the character.
--]]
function BaseController.ScaleInput(self: BaseController, InputCFrame: CFrame): CFrame
    --Return the original CFrame if there is no character.
    if not self.Character or not InputCFrame then
        return InputCFrame
    end

    --Return the modified CFrame.
    return CFrame.new(InputCFrame.Position * (self.Character:GetHumanoidScale("BodyHeightScale") - 1)) * InputCFrame
end

--[[
Updates the provided 'Store' table with the state of its
Thumbstick (Enum.KeyCode.ThumbstickX) field. Returns the
direction state, radius state, and overall state change.
--]]
function BaseController.GetJoystickState(self: BaseController, Store: any): (string, string, string)
    local InputPosition = VRInputService:GetThumbstickPosition(Store.Thumbstick)
    local InputRadius = ((InputPosition.X ^ 2) + (InputPosition.Y ^ 2)) ^ 0.5
    local InputAngle = math.atan2(InputPosition.X, InputPosition.Y)

    local DirectionState, RadiusState
    if InputAngle >= math.rad(-135) and InputAngle <= math.rad(-45) then
        DirectionState = "Left"
    elseif InputAngle >= math.rad(-45) and InputAngle <= math.rad(45) then
        DirectionState = "Forward"
    elseif InputAngle >= math.rad(45) and InputAngle <= math.rad(135) then
        DirectionState = "Right"
    end
    if InputRadius >= THUMBSTICK_INPUT_START_RADIUS then
        RadiusState = "Extended"
    elseif InputRadius <= THUMBSTICK_INPUT_RELEASE_RADIUS then
        RadiusState = "Released"
    else
        RadiusState = "InBetween"
    end

    --Update the stored state.
    local StateChange = nil
    if RadiusState == "Released" then
        if Store.RadiusState == "Extended" then
            StateChange = "Released"
        end
        Store.RadiusState = "Released"
        Store.DirectionState = nil
    elseif RadiusState == "Extended" then
        if Store.RadiusState == nil or Store.RadiusState == "Released" then
            if Store.RadiusState ~= "Extended" then
                StateChange = "Extended"
            end
            Store.RadiusState = "Extended"
            Store.DirectionState = DirectionState
        elseif Store.DirectionState ~= DirectionState then
            if Store.RadiusState ~= "Cancelled" then
                StateChange = "Cancel"
            end
            Store.RadiusState = "Cancelled"
            Store.DirectionState = nil
        end
    end

    return DirectionState, RadiusState, StateChange
end

--[[
Plays a temporary blur effect to make
teleports and snap turns less jarring.
]]--
function BaseController.PlayBlur(self: BaseController): ()
    local SnapTeleportBlur = Settings:GetSetting("Movement.SnapTeleportBlur")
    SnapTeleportBlur = (if SnapTeleportBlur == nil then true else SnapTeleportBlur)

    if not SnapTeleportBlur then
        return
    end

    local Blur = Instance.new("BlurEffect")
    Blur.Parent = workspace.CurrentCamera
    Blur.Size = 56

    local BlurTween = TweenService:Create(Blur, BLUR_TWEEN_INFO, { Size = 0 })
    BlurTween:Play()

    BlurTween.Completed:Connect(function()
        Blur:Destroy()
    end)
end

--[[
Updates the reference world CFrame.
--]]
function BaseController.UpdateCharacter(self: BaseController): ()
    --Return if the character is nil.
    local CharacterChanged = self:UpdateCharacterReference()
    if not self.Character then
        return
    end
    if CharacterChanged then
        self:Enable()
    end

    --Get the VR inputs.
    local VRInputs = VRInputService:GetVRInputs()
    local VRHeadCFrame = self:ScaleInput(VRInputs[Enum.UserCFrame.Head])
    local VRLeftHandCFrame,VRRightHandCFrame = self:ScaleInput(VRInputs[Enum.UserCFrame.LeftHand]), self:ScaleInput(VRInputs[Enum.UserCFrame.RightHand])
    local HeadToLeftHandCFrame = VRHeadCFrame:Inverse() * VRLeftHandCFrame
    local HeadToRightHandCFrame = VRHeadCFrame:Inverse() * VRRightHandCFrame

    --Update the character.
    local SeatPart = self.Character:GetHumanoidSeatPart()
    if not SeatPart then
        --Offset the character by the change in the head input.
        if self.LastHeadCFrame then
            --Get the eye CFrame of the current character, except the Y offset from the HumanoidRootPart.
            --The Y position will be added absolutely since doing it relatively will result in floating or short characters.
            local HumanoidRootPartCFrame = self.Character.Parts.HumanoidRootPart.CFrame
            local LowerTorsoCFrame = HumanoidRootPartCFrame * self.Character.Attachments.HumanoidRootPart.RootRigAttachment.CFrame * CFrame.new(0, -self.Character.Motors.Root.Transform.Position.Y, 0) * self.Character.Motors.Root.Transform * self.Character.Attachments.LowerTorso.RootRigAttachment.CFrame:Inverse()
            local UpperTorsoCFrame = LowerTorsoCFrame * self.Character.Attachments.LowerTorso.WaistRigAttachment.CFrame * self.Character.Motors.Waist.Transform * self.Character.Attachments.UpperTorso.WaistRigAttachment.CFrame:Inverse()
            local HeadCFrame = UpperTorsoCFrame * self.Character.Attachments.UpperTorso.NeckRigAttachment.CFrame * self.Character.Motors.Neck.Transform * self.Character.Attachments.Head.NeckRigAttachment.CFrame:Inverse()
            local EyesOffset = self.Character.Head:GetEyesOffset()
            local CharacterEyeCFrame = HeadCFrame * EyesOffset

            --Determine the input components.
            local InputDelta = self.LastHeadCFrame:Inverse() * VRHeadCFrame
            if VRHeadCFrame.UpVector.Y < 0 then
                InputDelta = CFrame.Angles(0,math.pi,0) * InputDelta
            end
            local HeadRotationXZ = (CFrame.new(VRHeadCFrame.Position) * CFrame.Angles(0, math.atan2(-VRHeadCFrame.LookVector.X, -VRHeadCFrame.LookVector.Z), 0)):Inverse() * VRHeadCFrame
            local LastHeadAngleY = GetAngleToGlobalY(self.LastHeadCFrame)
            local HeadAngleY = GetAngleToGlobalY(VRHeadCFrame)
            local HeightOffset = CFrame.new(0, (CFrame.new(0, EyesOffset.Y, 0) * (VRHeadCFrame * EyesOffset:Inverse())).Y, 0)

            --Offset the character eyes for the current input.
            local CurrentCharacterAngleY = GetAngleToGlobalY(CharacterEyeCFrame)
            local RotationY = CFrame.Angles(0, CurrentCharacterAngleY + (HeadAngleY - LastHeadAngleY), 0)
            local NewCharacterEyePosition = (HeightOffset *  CFrame.new((RotationY * CFrame.new(InputDelta.X, 0, InputDelta.Z)).Position) * CharacterEyeCFrame).Position
            local NewCharacterEyeCFrame = CFrame.new(NewCharacterEyePosition) * RotationY * HeadRotationXZ

            --Update the character.
            self.Character:UpdateFromInputs(NewCharacterEyeCFrame, NewCharacterEyeCFrame * HeadToLeftHandCFrame,NewCharacterEyeCFrame * HeadToRightHandCFrame)
        end
    else
        --Set the absolute positions of the character.
        self.Character:UpdateFromInputsSeated(VRHeadCFrame, VRHeadCFrame * HeadToLeftHandCFrame,VRHeadCFrame * HeadToRightHandCFrame)
    end

    --Update the camera.
    if self.Character.Parts.HumanoidRootPart:IsDescendantOf(Workspace) and self.Character.Humanoid.Health > 0 then
        --Update the camera based on the character.
        --Done based on the HumanoidRootPart instead of the Head because of Motors not updating the same frame, leading to a delay.
        local HumanoidRootPartCFrame = self.Character.Parts.HumanoidRootPart.CFrame
        local LowerTorsoCFrame = HumanoidRootPartCFrame * self.Character.Attachments.HumanoidRootPart.RootRigAttachment.CFrame * self.Character.Motors.Root.Transform * self.Character.Attachments.LowerTorso.RootRigAttachment.CFrame:Inverse()
        local UpperTorsoCFrame = LowerTorsoCFrame * self.Character.Attachments.LowerTorso.WaistRigAttachment.CFrame * self.Character.Motors.Waist.Transform * self.Character.Attachments.UpperTorso.WaistRigAttachment.CFrame:Inverse()
        local HeadCFrame = UpperTorsoCFrame * self.Character.Attachments.UpperTorso.NeckRigAttachment.CFrame * self.Character.Motors.Neck.Transform * self.Character.Attachments.Head.NeckRigAttachment.CFrame:Inverse()
        CameraService:UpdateCamera(HeadCFrame * self.Character.Head:GetEyesOffset())
        self.LastHeadCFrame = VRHeadCFrame
    elseif not Workspace.CurrentCamera.HeadLocked then
        --Update the camera based on the last CFrame if the motors can't update (not in Workspace).
        local CurrentCameraCFrame = Workspace.CurrentCamera:GetRenderCFrame()
        local LastHeadCFrame = self.LastHeadCFrame or CFrame.new()
        local HeadCFrame = self:ScaleInput(VRInputService:GetVRInputs()[Enum.UserCFrame.Head])
        CameraService:UpdateCamera(CurrentCameraCFrame * LastHeadCFrame:Inverse() * HeadCFrame)
        self.LastHeadCFrame = HeadCFrame
    end
end

--[[
Performs snap or smooth rotating based on the thumbstick input.
--]]
function BaseController.UpdateRotating(self: BaseController, Hand: Enum.UserCFrame, Direction: string, StateChange: string): ()
    if VRService.AvatarGestures then
        self.LastRotationUpdateTick = nil
        return
    end
    if not self.Character or self.Character.Humanoid.Sit then
        self.LastRotationUpdateTick = nil
        return
    end
    if Direction ~= "Left" and Direction ~= "Right" then
        self.LastRotationUpdateTick = nil
        return
    end

    --Return if the input is inactive.
    if NexusVRCharacterModelApi.Controller and not NexusVRCharacterModelApi.Controller:IsControllerInputEnabled(Hand) then
        return
    end

    --Rotate the character.
    local HumanoidRootPart = self.Character.Parts.HumanoidRootPart
    if UserSettings():GetService("UserGameSettings").VRSmoothRotationEnabled then
        --Smoothly rotate the character.
        local InputPosition = VRInputService:GetThumbstickPosition(USER_CFRAME_TO_THUMBSTICK[Hand])
        if math.abs(InputPosition.X) >= THUMBSTICK_SMOOTH_LOCOMOTION_DEADZONE then
            local LastRotationUpdateTick = self.LastRotationUpdateTick or tick()
            local CurrentRotationUpdateTick = tick()
            local RotationUpdateDeltaTime = (CurrentRotationUpdateTick - LastRotationUpdateTick)
            HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position) * CFrame.Angles(0, -InputPosition.X * THUMBSTICK_MANUAL_SMOOTH_ROTATION_RATE * RotationUpdateDeltaTime, 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
            self.LastRotationUpdateTick = CurrentRotationUpdateTick
        else
            self.LastRotationUpdateTick = nil
        end
    else
        --Snap rotate the character.
        if StateChange == "Extended" then
            if Direction == "Left" then
                --Turn the player to the left.
                self:PlayBlur()
                HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position) * CFrame.Angles(0, THUMBSTICK_SNAP_ROTATION_ANGLE, 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
            elseif Direction == "Right" then
                --Turn the player to the right.
                self:PlayBlur()
                HumanoidRootPart.CFrame = CFrame.new(HumanoidRootPart.Position) * CFrame.Angles(0, -THUMBSTICK_SNAP_ROTATION_ANGLE, 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
            end
        end
    end
end



return BaseController]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB1B290FD9A89400CAAC3E9AE168D5886">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SmoothLocomotionController</string>
							<string name="ScriptGuid">{D7630374-9B98-49C0-9EC4-385EB77223C0}</string>
							<ProtectedString name="Source"><![CDATA[--Local character controller using teleporting.
--!strict

local BaseController = require(script.Parent:WaitForChild("BaseController"))

local SmoothLocomotionController = {}
SmoothLocomotionController.__index = SmoothLocomotionController
setmetatable(SmoothLocomotionController, BaseController)

export type SmoothLocomotionController = {
    JoystickState: {[string]: Enum.KeyCode}?,
} & typeof(setmetatable({}, SmoothLocomotionController)) & BaseController.BaseController


--[[
Creates a smooth locomotion controller object.
--]]
function SmoothLocomotionController.new(): SmoothLocomotionController
    return setmetatable(BaseController.new(), SmoothLocomotionController) :: SmoothLocomotionController
end

--[[
Enables the controller.
--]]
function SmoothLocomotionController.Enable(self: SmoothLocomotionController): ()
    BaseController.Enable(self)
    self.JoystickState = {Thumbstick = Enum.KeyCode.Thumbstick2}
end

--[[
Disables the controller.
--]]
function SmoothLocomotionController.Disable(self: SmoothLocomotionController): ()
    BaseController.Disable(self)
    self.JoystickState = nil
end

--[[
Updates the local character. Must also update the camara.
--]]
function SmoothLocomotionController.UpdateCharacter(self: SmoothLocomotionController): ()
    --Update the base character.
    BaseController.UpdateCharacter(self)
    if not self.Character then
        return
    end

    --Rotate the character.
    local DirectionState, _, StateChange = self:GetJoystickState(self.JoystickState)
    self:UpdateRotating(Enum.UserCFrame.RightHand, DirectionState, StateChange)
end



return SmoothLocomotionController]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX479F7B2263AA4970A06D608D880B71E2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TeleportController</string>
							<string name="ScriptGuid">{5F7242D4-3E6B-413B-89B3-090D3101E224}</string>
							<ProtectedString name="Source"><![CDATA[ --Local character controller using teleporting.
--!strict

local Workspace = game:GetService("Workspace")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local NexusVRCharacterModelApi = require(NexusVRCharacterModel).Api
local BaseController = require(script.Parent:WaitForChild("BaseController"))
local ArcWithBeacon = require(script.Parent:WaitForChild("Visual"):WaitForChild("ArcWithBeacon"))
local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()

local TeleportController = {}
TeleportController.__index = TeleportController
setmetatable(TeleportController, BaseController)

export type TeleportController = {
    LeftArc: ArcWithBeacon.ArcWithBeacon,
    RightArc: ArcWithBeacon.ArcWithBeacon,
    ArcControls: {
        {
            Thumbstick: Enum.KeyCode,
            UserCFrame: Enum.UserCFrame,
            Arc: ArcWithBeacon.ArcWithBeacon,
            WaitForRelease: boolean?,
            RadiusState: ("Forward" | "Released")?,
            LastHitPart: BasePart?,
            LastHitPosition: Vector3?,
        }
    },
    IgnoreNextExternalTeleport: boolean?,
} & typeof(setmetatable({}, TeleportController)) & BaseController.BaseController



--[[
Creates a teleport controller object.
--]]
function TeleportController.new(): TeleportController
    local self = setmetatable(BaseController.new(), TeleportController) :: TeleportController
    self.ActionsToLock = {Enum.KeyCode.Thumbstick1, Enum.KeyCode.ButtonR3}
    return self
end

--[[
Enables the controller.
--]]
function TeleportController.Enable(self: TeleportController): ()
    BaseController.Enable(self)

    --Create the arcs.
    self.LeftArc = ArcWithBeacon.new()
    self.RightArc = ArcWithBeacon.new()
    self.ArcControls = {
        {
            Thumbstick = Enum.KeyCode.Thumbstick1,
            UserCFrame = Enum.UserCFrame.LeftHand,
            Arc = self.LeftArc,
        },
        {
            Thumbstick = Enum.KeyCode.Thumbstick2,
            UserCFrame = Enum.UserCFrame.RightHand,
            Arc = self.RightArc,
        },
    }
end

--[[
Disables the controller.
--]]
function TeleportController.Disable(self: TeleportController): ()
    BaseController.Disable(self)

    --Destroy the arcs.
    self.LeftArc:Destroy()
    self.RightArc:Destroy()
end

--[[
Updates the local character. Must also update the camara.
--]]
function TeleportController.UpdateCharacter(self: TeleportController): ()
    --Update the base character.
    BaseController.UpdateCharacter(self)
    if not self.Character then
        return
    end

    --Get the VR inputs.
    local VRInputs = VRInputService:GetVRInputs()
    for _, InputEnum in Enum.UserCFrame:GetEnumItems() do
        VRInputs[InputEnum] = self:ScaleInput(VRInputs[InputEnum])
    end

    --Update the arcs.
    local SeatPart = self.Character:GetHumanoidSeatPart()
    for _, ArcData in self.ArcControls do
        --Reset the left arc if the player is in a vehicle seat.
        if ArcData.Thumbstick == Enum.KeyCode.Thumbstick1 and SeatPart and SeatPart:IsA("VehicleSeat") then
            ArcData.Arc:Hide()
            continue
        end

        --Update and fetch the current state.
        local InputActive = (not NexusVRCharacterModelApi.Controller or NexusVRCharacterModelApi.Controller:IsControllerInputEnabled(ArcData.UserCFrame))
        local DirectionState, RadiusState, StateChange = self:GetJoystickState(ArcData)
        if not InputActive then
            ArcData.Arc:Hide()
            ArcData.WaitForRelease = false
            ArcData.RadiusState = nil
            continue
        end

        --Update from the state.
        local HumanoidRootPart = self.Character.Parts.HumanoidRootPart
        if DirectionState ~= "Forward" or RadiusState == "Released" then
            ArcData.Arc:Hide()
        end
        if StateChange == "Released" then
            ArcData.Arc:Hide()
            if DirectionState == "Forward" then
                --Teleport the player.
                local LastHitPart = ArcData.LastHitPart
                if LastHitPart and ArcData.LastHitPosition then
                    --Unsit the player.
                    --The teleport event is set to ignored since the CFrame will be different when the player gets out of the seat.
                    local WasSitting = false
                    self:PlayBlur()

                    if SeatPart then
                        WasSitting = true
                        self.IgnoreNextExternalTeleport = true
                        self.Character.Humanoid.Sit = false
                    end

                    if (LastHitPart:IsA("Seat") or LastHitPart:IsA("VehicleSeat")) and not LastHitPart.Occupant and not LastHitPart.Disabled then
                        --Sit in the seat.
                        --Waiting is done if the player was in an existing seat because the player no longer sitting will prevent sitting.
                        local LastHitSeat = (LastHitPart :: Seat)
                        if WasSitting then
                            task.spawn(function()
                                while self.Character.Humanoid.SeatPart do task.wait() end
                                LastHitSeat:Sit(self.Character.Humanoid)
                            end)
                        else
                            LastHitSeat:Sit(self.Character.Humanoid)
                        end
                    else
                        --Teleport the player.
                        --Waiting is done if the player was in an existing seat because the player will teleport the seat.
                        if WasSitting then
                            task.spawn(function()
                                while self.Character.Humanoid.SeatPart do task.wait() end
                                HumanoidRootPart.CFrame = CFrame.new(ArcData.LastHitPosition) * CFrame.new(0, 4.5 * self.Character:GetHumanoidScale("BodyHeightScale"), 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
                            end)
                        else
                            HumanoidRootPart.CFrame = CFrame.new(ArcData.LastHitPosition) * CFrame.new(0, 4.5 * self.Character:GetHumanoidScale("BodyHeightScale"), 0) * (CFrame.new(-HumanoidRootPart.Position) * HumanoidRootPart.CFrame)
                        end
                    end
                end
            end
        elseif StateChange == "Cancel" then
            ArcData.Arc:Hide()
        elseif DirectionState == "Forward" and RadiusState == "Extended" then
            ArcData.LastHitPart, ArcData.LastHitPosition = ArcData.Arc:Update(Workspace.CurrentCamera:GetRenderCFrame() * VRInputs[Enum.UserCFrame.Head]:Inverse() * VRInputs[ArcData.UserCFrame])
        end

        --Rotate the character.
        self:UpdateRotating(ArcData.UserCFrame, DirectionState, StateChange)
    end
end



return TeleportController]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXBC7E81EE44A34F048CA0EFA07AD45FAF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Visual</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX72D7CBB47AB24661B547F1753E833814">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Arc</string>
								<string name="ScriptGuid">{DBA53050-FDF0-4E66-A716-C6C73FCDFB11}</string>
								<ProtectedString name="Source"><![CDATA[--Visual indicator aiming with an arc.
--!strict

local MAX_SEGMENTS = 100
local SEGMENT_SEPARATION = 2
local BASE_POINTER_ANGLE = math.rad(60)
local POINTER_PARABOLA_HEIGHT_MULTIPLIER = -0.2

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

local NexusVRCharacterModel = script.Parent.Parent.Parent.Parent
local FindCollidablePartOnRay = require(NexusVRCharacterModel:WaitForChild("Util"):WaitForChild("FindCollidablePartOnRay"))

local Arc = {}
Arc.__index = Arc

export type Arc = {
    BeamParts: {BasePart},
} & typeof(setmetatable({}, Arc))



--[[
Creates an arc.
--]]
function Arc.new(): Arc
    local self = setmetatable({
        BeamParts = {},
    }, Arc) :: Arc
    self:Hide()
    return self
end

--[[
Updates the arc. Returns the part and
position that were hit.
--]]
function Arc.Update(self: Arc, StartCFrame: CFrame): (BasePart?, Vector3?)
    --Calculate the starting angle.
    local StartPosition = StartCFrame.Position
    local FaceAngle = math.atan2(-StartCFrame.LookVector.X, -StartCFrame.LookVector.Z)
    local StartAngle = math.asin(StartCFrame.LookVector.Y)
    StartAngle = StartAngle + (BASE_POINTER_ANGLE * ((math.pi / 2) - math.abs(StartAngle)) / (math.pi / 2))

    --Calculate the start CFrame and start offset of the parabola.
    --The start is the where the derivative of POINTER_PARABOLA_HEIGHT_MULTIPLIER * x^2 is tan(StartAngle).
    local StartCF = CFrame.new(StartPosition) * CFrame.Angles(0, FaceAngle, 0)
    local StartOffset = math.tan(StartAngle) / (POINTER_PARABOLA_HEIGHT_MULTIPLIER * 2)
    local StartValue = POINTER_PARABOLA_HEIGHT_MULTIPLIER * (StartOffset ^ 2)

    --Create the parts until the limit is reached.
    for i = 0, MAX_SEGMENTS - 1 do
        --Calculate the current and next position.
        local SegmentStartPosition = (StartCF * CFrame.new(0, POINTER_PARABOLA_HEIGHT_MULTIPLIER * ((i + StartOffset) ^ 2) - StartValue, -SEGMENT_SEPARATION * i)).Position
        local SegmentEndPosition = (StartCF * CFrame.new(0, POINTER_PARABOLA_HEIGHT_MULTIPLIER * ((i + 1 + StartOffset) ^ 2) - StartValue, -SEGMENT_SEPARATION * (i + 1))).Position

        --Create the parts if they don't exist.
        if not self.BeamParts[i] then
            self.BeamParts[i] = Instance.new("Part")
            self.BeamParts[i].Transparency = 1
            self.BeamParts[i].Size = Vector3.new(0, 0, 0)
            self.BeamParts[i].Anchored = true
            self.BeamParts[i].CanCollide = false
            self.BeamParts[i].CanQuery = false
            self.BeamParts[i].Parent = Workspace.CurrentCamera

            local Attachment = Instance.new("Attachment")
            Attachment.Name = "BeamAttachment"
            Attachment.CFrame = CFrame.Angles(0, 0, math.pi / 2)
            Attachment.Parent = self.BeamParts[i]
        end
        if not self.BeamParts[i + 1] then
            --Create the part and attachment.
            self.BeamParts[i + 1] = Instance.new("Part")
            self.BeamParts[i + 1].Transparency = 1
            self.BeamParts[i + 1].Size = Vector3.new(0, 0, 0)
            self.BeamParts[i + 1].Anchored = true
            self.BeamParts[i + 1].CanCollide = false
            self.BeamParts[i + 1].CanQuery = false
            self.BeamParts[i + 1].Parent = Workspace.CurrentCamera

            local Attachment = Instance.new("Attachment")
            Attachment.Name = "BeamAttachment"
            Attachment.CFrame = CFrame.Angles(0, 0, math.pi / 2)
            Attachment.Parent = self.BeamParts[i + 1]

            --Create the beam.
            local Beam = Instance.new("Beam")
            Beam.Name = "Beam"
            Beam.Attachment0 = (self.BeamParts[i] :: any).BeamAttachment
            Beam.Attachment1 = Attachment
            Beam.Segments = 1
            Beam.Width0 = 0.1
            Beam.Width1 = 0.1
            Beam.Parent = self.BeamParts[i + 1]
        end

        --Cast the ray to the end.
        --Return if an end was hit and make the arc blue.
        local HitPart, HitPosition = FindCollidablePartOnRay(SegmentStartPosition, SegmentEndPosition - SegmentStartPosition, Players.LocalPlayer and Players.LocalPlayer.Character,Players.LocalPlayer and Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart"))
        self.BeamParts[i].CFrame = CFrame.new(SegmentStartPosition) * CFrame.Angles(0, FaceAngle, 0);
        (self.BeamParts[i + 1] :: any).Beam.Enabled = true
        if HitPart then
            self.BeamParts[i + 1].CFrame = CFrame.new(HitPosition)
            for j = 0, i do
                (self.BeamParts[j + 1] :: any).Beam.Color = ColorSequence.new(Color3.fromRGB(0, 170, 255))
            end
            for j = i + 1, #self.BeamParts - 1 do
                (self.BeamParts[j + 1] :: any).Beam.Enabled = false
            end
            return HitPart, HitPosition
        else
            self.BeamParts[i + 1].CFrame = CFrame.new(SegmentEndPosition)
        end
    end

    --Set the beams to red.
    for i = 0, #self.BeamParts - 1 do
        (self.BeamParts[i + 1] :: any).Beam.Color = ColorSequence.new(Color3.fromRGB(200, 0, 0))
    end
    return nil, nil
end

--[[
Hides the arc.
--]]
function Arc.Hide(self: Arc): ()
    for i = 0, #self.BeamParts - 1 do
        (self.BeamParts[i + 1] :: any).Beam.Enabled = false
    end
end

--[[
Destroys the arc.
--]]
function Arc.Destroy(self: Arc): ()
    for _, BeamPart in self.BeamParts do
        BeamPart:Destroy()
    end
    self.BeamParts = {}
end



return Arc]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX7C38203F6CA749D49DB702ED2B1466E3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ArcWithBeacon</string>
								<string name="ScriptGuid">{B8EF229C-2351-4A64-82C3-99D94953FD3F}</string>
								<ProtectedString name="Source"><![CDATA[--Extension of the arc to add a beacon.
--!strict

local Arc = require(script.Parent:WaitForChild("Arc"))
local Beacon = require(script.Parent:WaitForChild("Beacon"))

local ArcWithBeacon = {}
ArcWithBeacon.__index = ArcWithBeacon
setmetatable(ArcWithBeacon, Arc)

export type ArcWithBeacon = {
    Beacon: Beacon.Beacon,
} & typeof(setmetatable({}, ArcWithBeacon)) & Arc.Arc



--[[
Creates an arc.
--]]
function ArcWithBeacon.new(): ArcWithBeacon
    local self = setmetatable(Arc.new() :: any, ArcWithBeacon) :: ArcWithBeacon
    self.Beacon = Beacon.new()
    self:Hide()
    return self :: ArcWithBeacon
end

--[[
Updates the arc. Returns the part and
position that were hit.
--]]
function ArcWithBeacon.Update(self: ArcWithBeacon, StartCFrame: CFrame): (BasePart?, Vector3?)
    --Update the arc.
    local HitPart, HitPosition = Arc.Update(self, StartCFrame)

    --Update the beacon.
    local Beacon = (self :: any).Beacon :: Beacon.Beacon
    if HitPart then
        Beacon:Update(CFrame.new(HitPosition :: Vector3) * CFrame.new(0, 0.001, 0), HitPart)
    else
        Beacon:Hide()
    end

    --Return the arc's returns.
    return HitPart, HitPosition
end

--[[
Hides the arc.
--]]
function ArcWithBeacon.Hide(self: ArcWithBeacon): ()
    Arc.Hide(self);
    self.Beacon:Hide()
end

--[[
Destroys the arc.
--]]
function ArcWithBeacon.Destroy(self: ArcWithBeacon): ()
    Arc.Destroy(self);
    self.Beacon:Destroy()
end



return ArcWithBeacon]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX110037A117C84EEBB6AC06D56746D05E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Beacon</string>
								<string name="ScriptGuid">{7B0D9190-B1D8-435E-88CD-3D21E95EAB8F}</string>
								<ProtectedString name="Source"><![CDATA[--Visual indicator for the end of aiming.
--!strict

local BEACON_SPEED_MULTIPLIER = 2

local Workspace = game:GetService("Workspace")

local Beacon = {}
Beacon.__index = Beacon

export type Beacon = {
    Sphere: Part,
    ConstantRing: ImageHandleAdornment,
    MovingRing: ImageHandleAdornment,
} & typeof(setmetatable({}, Beacon))



--[[
Creates a beacon.
--]]
function Beacon.new(): Beacon
    --Create the object.
    local self = {}
    setmetatable(self, Beacon)

    --Create the parts.
    local Sphere = Instance.new("Part")
    Sphere.Transparency = 1
    Sphere.Material = Enum.Material.Neon
    Sphere.Anchored = true
    Sphere.CanCollide = false
    Sphere.CanQuery = false
    Sphere.Size = Vector3.new(0.5, 0.5, 0.5)
    Sphere.Shape = Enum.PartType.Ball
    Sphere.Parent = Workspace.CurrentCamera

    local ConstantRing = Instance.new("ImageHandleAdornment")
    ConstantRing.Adornee = Sphere
    ConstantRing.Size = Vector2.new(2, 2)
    ConstantRing.Image = "rbxasset://textures/ui/VR/VRPointerDiscBlue.png"
    ConstantRing.Visible = false
    ConstantRing.Parent = Sphere

    local MovingRing = Instance.new("ImageHandleAdornment")
    MovingRing.Adornee = Sphere
    MovingRing.Size = Vector2.new(2, 2)
    MovingRing.Image = "rbxasset://textures/ui/VR/VRPointerDiscBlue.png"
    MovingRing.Visible = false
    MovingRing.Parent = Sphere

    --Return the object.
    return setmetatable({
        Sphere = Sphere,
        ConstantRing = ConstantRing,
        MovingRing = MovingRing,
    }, Beacon) :: Beacon
end

--[[
Updates the beacon at a given CFrame.
--]]
function Beacon.Update(self: Beacon, CenterCFrame: CFrame, HoverPart: BasePart): ()
    --Calculate the size for the current time.
    local Height = 0.4 + (-math.cos(tick() * 2 * BEACON_SPEED_MULTIPLIER) / 8)
    local BeaconSize = 2 * ((tick() * BEACON_SPEED_MULTIPLIER) % math.pi) / math.pi

    --Update the size and position of the beacon.
    self.Sphere.CFrame = CenterCFrame * CFrame.new(0, Height, 0)
    self.ConstantRing.CFrame = CFrame.new(0, -Height, 0) * CFrame.Angles(math.pi / 2, 0, 0)
    self.MovingRing.CFrame = CFrame.new(0, -Height, 0) * CFrame.Angles(math.pi / 2, 0, 0)
    self.MovingRing.Transparency = BeaconSize / 2
    self.MovingRing.Size = Vector2.new(BeaconSize, BeaconSize)

    --Update the beacon color.
    local BeaconColor = Color3.fromRGB(0, 170, 0)
    if HoverPart then
        local VRBeaconColor = HoverPart:FindFirstChild("VRBeaconColor") :: Color3Value
        if VRBeaconColor then
            BeaconColor = VRBeaconColor.Value
        elseif (HoverPart:IsA("Seat") or HoverPart:IsA("VehicleSeat")) and not HoverPart.Disabled then
            BeaconColor = Color3.fromRGB(0, 170, 255)
        end
    end
    self.Sphere.Color = BeaconColor

    --Show the beacon.
    self.Sphere.Transparency = 0
    self.ConstantRing.Visible = true
    self.MovingRing.Visible = true
end

--[[
Hides the beacon.
--]]
function Beacon.Hide(self: Beacon): ()
    --Hide the beacon.
    self.Sphere.Transparency = 1
    self.ConstantRing.Visible = false
    self.MovingRing.Visible = false
end

--[[
Destroys the beacon.
--]]
function Beacon.Destroy(self: Beacon): ()
    self.Sphere:Destroy()
end



return Beacon]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXDFE2D24DD0E84D17960BFED77DDFE3A7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">FootPlanter</string>
						<string name="ScriptGuid">{BDFB448F-97B1-4089-BFC2-9422459C5298}</string>
						<ProtectedString name="Source"><![CDATA[--[[
Attempts to solve footplanting.
This code is heavily "zombified" off of a project by
Stravant, and is taken from Nexus VR Character Model V1
with minimal changes. It really needs to be replaced by
someone who better unstands foot placement. No automated
tests are done on this code.
--]]

local FootPlanter = {}


local CFnew,CFAngles = CFrame.new,CFrame.Angles
local V3new = Vector3.new
local rad,atan2,acos = math.rad,math.atan2,math.acos
local min,max,abs,log = math.min,math.max,math.abs,math.log



function FootPlanter:CreateSolver(CenterPart,ScaleValue)
	--Heavily modified code from Stravant
	local FootPlanterClass = {}
	
	local ignoreModel = CenterPart.Parent
	
	local LEG_GAP = 1.2
	--
	local STRIDE_FORWARD = 1.7 / 2
	local STRIDE_BACKWARD = 3.3 / 2
	local STRIDE_HEIGHT = 0.6
	local STRIDE_RESTING = 1
	--
	local WALK_SPEED_VR_THRESHOLD = 2
	local FOOT_MAX_SPEED_FACTOR = 2
	--
	local WALK_CYCLE_POWER = 1
	--
	local FOOT_ANGLE = rad(5)
	
	
	
	local function flatten(CF)
		local X,Y,Z = CF.X,CF.Y,CF.Z
		local LX,LZ = CF.lookVector.X,CF.lookVector.Z
		
		return CFnew(X,Y,Z) * CFAngles(0,atan2(LX,LZ),0)
	end
	
	local lastPosition,lastPollTime
	local overrideVelocityWithZero = false
	local function getVelocity(CF)
		if overrideVelocityWithZero then
			overrideVelocityWithZero = true
			
			local curTime = tick()
			lastPosition = CF.p
			
			return V3new()
		end
		
		if lastPollTime then
			local curTime = tick()
			local newPosition = CF.p
			
			local velocity = (newPosition - lastPosition) * 1/(curTime - lastPollTime)
			lastPollTime = curTime
			lastPosition = newPosition
			
			return velocity
		else
			lastPollTime = tick()
			lastPosition = CF.p
			
			return V3new()
		end
	end
	
	local function getWalkSpeed(velocity)
		return V3new(velocity.x,0,velocity.z).magnitude
	end
	
	local function getWalkDirection(velocity)
		if velocity.magnitude > 0. then
			return velocity.unit
		else
			return V3new(0,0,-1)
		end
	end
	
	local function isWalking(velocity)
		return getWalkSpeed(velocity) > WALK_SPEED_VR_THRESHOLD
	end

	local CurrentScale = 1
	local function getBaseCFrame()
		return CenterPart.CFrame * CFnew(0,-CenterPart.Size.Y/2 - (CurrentScale * 2),0)
	end
	
	local function getBaseRotationY()
		local lookVector = getBaseCFrame().lookVector
		return atan2(lookVector.X,lookVector.Z)
	end
	
	local FindCollidablePartOnRay = require(script.Parent.Parent:WaitForChild("Util"):WaitForChild("FindCollidablePartOnRay"))
	local function FindPartOnRay(ray,ignore)
		return FindCollidablePartOnRay(ray.Origin,ray.Direction,ignore,CenterPart)
	end
	
	
	
	
	-- Leg data
	local mRightLeg, mLeftLeg, mRightArm, mLeftArm;
	local mLegs = {}
	local lastCF
	local function initLegs()
		local cf = flatten(getBaseCFrame())
		lastCF = cf
		mRightLeg = {
			OffsetModifier = CFnew(-LEG_GAP/2, 0, 0);
			Side = -1;
			--
			StepCycle = 0;
			FootPosition = cf*CFnew(-LEG_GAP/2, 0, 0).p;
			LastStepTo = cf*CFnew(-LEG_GAP/2, 0, 0).p;
			Takeoff = cf*CFnew(-LEG_GAP/2, 0, 0).p;
		}
		mLeftLeg = {
			OffsetModifier = CFnew( LEG_GAP/2, 0, 0);
			Side = 1;
			--
			StepCycle = 0;
			FootPosition = cf*CFnew( LEG_GAP/2, 0, 0).p;
			LastStepTo = cf*CFnew(-LEG_GAP/2, 0, 0).p;
			Takeoff = cf*CFnew(-LEG_GAP/2, 0, 0).p;
		}
		mRightLeg.OtherLeg = mLeftLeg
		mLeftLeg.OtherLeg = mRightLeg
		mLegs = {mLeftLeg, mRightLeg}
	end
	
	local LastScale = 1
	local function UpdateScaling()
		local CurrentScaleValue = (ScaleValue and ScaleValue.Value or 1)
		local Multiplier = CurrentScaleValue / LastScale
		LastScale = CurrentScaleValue

		LEG_GAP = LEG_GAP * Multiplier
		STRIDE_FORWARD = STRIDE_FORWARD * Multiplier
		STRIDE_BACKWARD = STRIDE_BACKWARD * Multiplier
		STRIDE_HEIGHT = STRIDE_HEIGHT * Multiplier
		STRIDE_RESTING = STRIDE_RESTING * Multiplier

		mRightLeg.OffsetModifier = CFnew(-LEG_GAP/2, 0, 0)
		--[[mRightLeg.FootPosition
		mRightLeg.LastStepTo
		mRightLeg.Takeoff
			 = ;
			Side = -1;
			--
			StepCycle = 0;
			 = lastCF*CFnew(-LEG_GAP/2, 0, 0).p;
			 = lastCF*CFnew(-LEG_GAP/2, 0, 0).p;
			 = lastCF*CFnew(-LEG_GAP/2, 0, 0).p;
		}
		mLeftLeg = {
			OffsetModifier = CFnew( LEG_GAP/2, 0, 0);
			Side = 1;
			--
			StepCycle = 0;
			FootPosition = lastCF*CFnew( LEG_GAP/2, 0, 0).p;
			LastStepTo = lastCF*CFnew(-LEG_GAP/2, 0, 0).p;
			Takeoff = lastCF*CFnew(-LEG_GAP/2, 0, 0).p;
		}]]
	end
	if ScaleValue then
		ScaleValue.Changed:Connect(function()
			if mRightLeg then
				UpdateScaling()
			end
		end)
	end


	local mAirborneFraction = 0
	local mLandedFraction = 0
	local mCurrentSpeed = 1
	local mStableStanding = false
	
	local function getStrideForward()
		if mCurrentSpeed > 0 then
			return STRIDE_FORWARD + STRIDE_FORWARD*1*mCurrentSpeed
		else
			return STRIDE_FORWARD + STRIDE_FORWARD*0.5*mCurrentSpeed
		end
	end
	
	local function getStrideFull()
		if mCurrentSpeed > 0 then
			return (STRIDE_FORWARD + STRIDE_BACKWARD) + (STRIDE_FORWARD + STRIDE_BACKWARD)*1.5*mCurrentSpeed
		else
			return (STRIDE_FORWARD + STRIDE_BACKWARD) + (STRIDE_FORWARD + STRIDE_BACKWARD)*0.5*mCurrentSpeed
		end
	end

	local function snapDown(pos)
		local orig, dir = (pos + V3new(0, 2, 0)), V3new(0, -500, 0)
		local hit, at = FindPartOnRay(Ray.new(orig, dir), ignoreModel)
		if hit then
			local hit1, at1 = FindPartOnRay(Ray.new(orig + V3new(0,    0,  0.01), dir), ignoreModel)
			local hit2, at2 = FindPartOnRay(Ray.new(orig + V3new(0,    0, -0.01), dir), ignoreModel)				
			local hit3, at3 = FindPartOnRay(Ray.new(orig + V3new(0.01, 0,  0   ), dir), ignoreModel)
			local norm;
			
			if hit1 and hit2 and hit3 then
				norm = (at1 - at2):Cross(at2 - at3).unit
				if norm.Y < 0 then
					norm = -norm
				end					
			end
			
			return at, norm
		else
			return pos, V3new(0, 1, 0)
		end
	end
	
	local function fixFeetPositionsY()
		for _,leg in pairs(mLegs) do
			local targetPos,norm = snapDown(leg.FootPosition)
			leg.FootPosition = targetPos
		end
	end
	
	local lastTime
	function FootPlanterClass:GetFeetCFrames()
		if not mLeftLeg then
			initLegs()
			UpdateScaling()
		end
		
		local curTime = tick()
		if not lastTime then lastTime = curTime end
		local dt = curTime - lastTime
		lastTime = curTime
		
		local velocity = getVelocity(CenterPart.CFrame)
		local speed = getWalkSpeed(velocity)
		local realBaseCF = flatten(CenterPart.CFrame)
		local baseCF = realBaseCF
		local baseAxis = baseCF.lookVector
		local baseAxisPerp = baseAxis:Cross(V3new(0, 1, 0))
		local walkAxis = getWalkDirection(velocity)
		local walkAxisPerp = walkAxis:Cross(V3new(0, 1, 0))
		
		--
		mCurrentSpeed = max(-1, min(1, log(speed/16)/log(2)))
		--
		local leftStepping = mLeftLeg.StepCycle > 0
		local rightStepping = mRightLeg.StepCycle > 0
		--
				
		local function spline(t2, n, p)
			if n == 1 then
				return p[1]
			else
				local t1 = (1 - t2)
				for i = 1, n-1 do
					p[i] = t1*p[i] + t2*p[i+1]
				end
				return spline(t2, n-1, p)
			end
		end
			
		local function positionFootByCycle(leg, stepTarget)
			local baseVector = stepTarget - leg.Takeoff
			local sideVector = walkAxisPerp*leg.Side
			local baseLen = baseVector.magnitude
			local towardsSide = sideVector*(LEG_GAP/2)*0.3
			local towardsTop = V3new(0, 1.3*STRIDE_HEIGHT*(1 / leg.StepSpeedMod), 0)
			local topPoint = leg.Takeoff + baseVector * 1/2 + towardsTop + towardsSide
			local nextPoint = leg.Takeoff + baseVector * 0.9 + towardsTop + towardsSide
			--local a, b, c = leg.Takeoff, topPoint, stepTarget
			--local fb = leg.StepCycle
			--fb = fb^(_G.A or WALK_CYCLE_POWER)
			--local fa = 1-fb
			--
			--local footDesiredPos = fa*fa*a + 2*fa*fb*b + fb*fb*c
			local fb = leg.StepCycle^(_G.A or WALK_CYCLE_POWER)
			local footDesiredPos = spline(fb, 4, {leg.Takeoff, topPoint, nextPoint, stepTarget})
			--makeP(CFnew(footDesiredPos))
			if (footDesiredPos - leg.FootPosition).magnitude > dt*speed*FOOT_MAX_SPEED_FACTOR then
				local forcePos = (1 - leg.StepCycle) * leg.FootPosition + leg.StepCycle * footDesiredPos
				local movePos = leg.FootPosition + (footDesiredPos - leg.FootPosition).unit * dt*speed*FOOT_MAX_SPEED_FACTOR
				if (forcePos - footDesiredPos).magnitude < (movePos - footDesiredPos).magnitude then
					footDesiredPos = forcePos
				else
					footDesiredPos = movePos
				end
			end
			leg.FootPosition = footDesiredPos
			leg.LastStepTo = stepTarget
		end
		--
		local isCharacterWalking = isWalking(velocity)
		if isCharacterWalking then
			mStableStanding = false
		end
		--
		if isCharacterWalking then
			-- Get the desired ahead step
			local centeringMod = walkAxisPerp * (LEG_GAP/2) * 0.5
			local rightDesiredAheadStep = (baseCF * mRightLeg.OffsetModifier + getStrideForward()*walkAxis - mRightLeg.Side*centeringMod).p
			local leftDesiredAheadStep  = (baseCF *  mLeftLeg.OffsetModifier + getStrideForward()*walkAxis - mLeftLeg.Side*centeringMod).p
			local rightNorm, leftNorm;
			rightDesiredAheadStep, rightNorm = snapDown(rightDesiredAheadStep)
			leftDesiredAheadStep, leftNorm = snapDown(leftDesiredAheadStep)
			if not rightStepping or not mRightLeg.AheadStep or (rightDesiredAheadStep - mRightLeg.AheadStep).magnitude < dt*speed then
				mRightLeg.AheadStep = rightDesiredAheadStep
			else
				mRightLeg.AheadStep = mRightLeg.AheadStep + (rightDesiredAheadStep - mRightLeg.AheadStep).unit * dt*speed*2
			end
			mRightLeg.NormalHint = rightNorm
			if not leftStepping or not mLeftLeg.AheadStep or (leftDesiredAheadStep - mLeftLeg.AheadStep).magnitude < dt*speed then
				mLeftLeg.AheadStep = leftDesiredAheadStep
			else
				mLeftLeg.AheadStep = mLeftLeg.AheadStep + (leftDesiredAheadStep - mLeftLeg.AheadStep).unit * dt*speed*2
			end
			mLeftLeg.NormalHint = leftNorm
			
			local strideFactor = 0.9 - 0.3*max(0, mCurrentSpeed)
			local stepSpeed = speed / getStrideFull() * strideFactor
			
			-- Which legs are stepping?
			if not leftStepping and not rightStepping then
				-- Neither leg is stepping pick up the closer leg into the step
				if mAirborneFraction < 0.8 then -- don't pick up feet if we just landed
					if (mLeftLeg.FootPosition - mLeftLeg.AheadStep).magnitude < (mRightLeg.FootPosition - mRightLeg.AheadStep).magnitude then
						-- step p1
						local fracThere = min(0.9, max(0, (mLeftLeg.FootPosition - mLeftLeg.AheadStep).magnitude / getStrideFull()))
						mLeftLeg.StepSpeedMod = 1 / (1 - fracThere)
						mLeftLeg.StepCycle = dt
						mLeftLeg.Takeoff = mLeftLeg.FootPosition
					else
						-- step p2
						local fracThere = min(0.9, max(0, (mRightLeg.FootPosition - mRightLeg.AheadStep).magnitude / getStrideFull()))
						mRightLeg.StepSpeedMod = 1 / (1 - fracThere)
						mRightLeg.StepCycle = dt
						mRightLeg.Takeoff = mRightLeg.FootPosition
					end
				end
			elseif leftStepping and rightStepping then
				-- Both legs are stepping
				-- just step both legs
				-- The leg closer to |aheadStep| should step there, and the
				-- other leg should 
				for _, leg in pairs(mLegs) do
					leg.StepCycle = min(1, leg.StepCycle + dt*stepSpeed*leg.StepSpeedMod)
					positionFootByCycle(leg, leg.AheadStep)
					if leg.StepCycle == 1 then
						leg.StepCycle = 0
					end
				end
			else
				-- One leg is stepping.
				-- Step the one leg, and see if the other needs to enter a step
				for _, leg in pairs(mLegs) do
					if leg.StepCycle > 0 then
						-- Step this leg
						leg.StepCycle = min(1, leg.StepCycle + dt*stepSpeed*leg.StepSpeedMod)
						positionFootByCycle(leg, leg.AheadStep)
						
						-- Check if leg.Other needs to start a step
						if leg.StepCycle > strideFactor then
							leg.OtherLeg.StepSpeedMod = 1
							leg.OtherLeg.StepCycle = dt
							leg.OtherLeg.Takeoff = leg.OtherLeg.FootPosition
							positionFootByCycle(leg.OtherLeg, leg.AheadStep)
						end
						
						if leg.StepCycle == 1 then
							leg.StepCycle = 0
						end
						
						break
					end
				end
			end
		else
			local stepSpeed = 2			
			
			-- Not walking, we need to try to get to a suitable base position
			if leftStepping or rightStepping then
				for _, leg in pairs(mLegs) do
					if leg.StepCycle > 0 then
						leg.StepCycle = min(1, leg.StepCycle + dt*stepSpeed)
						local restingPos = (baseCF * leg.OffsetModifier).p
						local toVec = (leg.LastStepTo - restingPos)
						local targetPos;
						if toVec.magnitude > STRIDE_RESTING then
							targetPos = restingPos + (toVec.unit * STRIDE_RESTING)
						else
							targetPos = leg.LastStepTo
						end
						local norm;
						targetPos, norm = snapDown(targetPos)
						leg.AheadStep = targetPos
						leg.NormalHint = norm
						positionFootByCycle(leg, targetPos)
						if leg.StepCycle == 1 then
							leg.StepCycle = 0
						end
					else
						
					end
				end
			else
				fixFeetPositionsY()
			end
			
			-- Now, we stepped both legs. If both legs are resting now. See if 
			-- they are on roughly opposite offsets from where they should be.
			if mRightLeg.StepCycle == 0 and mLeftLeg.StepCycle == 0 then
				local rightResting = (baseCF * mRightLeg.OffsetModifier).p
				local leftResting = (baseCF * mLeftLeg.OffsetModifier).p
				local rightSep = mRightLeg.FootPosition - rightResting
				local leftSep = mLeftLeg.FootPosition - leftResting
				--
				local tooFar = abs(rightSep:Dot(baseAxis) - leftSep:Dot(baseAxis)) > 3
				local thetaBetweenFeet = acos(min(1, max(-1, rightSep.unit:Dot(leftSep.unit))))
				local distBetweenFeet = abs(rightSep.magnitude - leftSep.magnitude)
				--
				if rightSep:Dot(baseAxisPerp) > LEG_GAP/4 then
					mStableStanding = false
					mRightLeg.Takeoff = mRightLeg.FootPosition
					mRightLeg.StepCycle = dt
					--mRightLeg.LastStepTo = rightResting - baseAxisPerp*0.5
					local modLeftSep = leftSep.unit * 0.5
					if leftSep.magnitude == 0 then
						modLeftSep = -baseAxisPerp*0.5
					elseif leftSep:Dot(baseAxisPerp) > 0 then
						modLeftSep = (leftSep - 2*baseAxisPerp*leftSep:Dot(baseAxisPerp)).unit*0.5
					end
					mRightLeg.LastStepTo = rightResting + modLeftSep
					if (mRightLeg.LastStepTo - mRightLeg.Takeoff).magnitude < 0.5 then
						mRightLeg.StepCycle = 0
					end
					local fracThere = min(0.9, max(0, (mRightLeg.FootPosition - mRightLeg.LastStepTo).magnitude / getStrideFull()))
					mRightLeg.StepSpeedMod = 1 / (1 - fracThere)
				elseif leftSep:Dot(baseAxisPerp) < -LEG_GAP/4 then
					mStableStanding = false
					mLeftLeg.Takeoff = mLeftLeg.FootPosition
					mLeftLeg.StepCycle = dt
					--mLeftLeg.LastStepTo = leftResting + baseAxisPerp*0.5	
					local modRightSep = rightSep.unit * 0.5
					if rightSep.magnitude == 0 then
						modRightSep = baseAxisPerp*0.5
					elseif rightSep:Dot(baseAxisPerp) < 0 then
						modRightSep = (rightSep - 2*baseAxisPerp*rightSep:Dot(baseAxisPerp)).unit*0.5
					end
					mLeftLeg.LastStepTo = leftResting + modRightSep
					if (mRightLeg.LastStepTo - mRightLeg.Takeoff).magnitude < 0.5 then
						mRightLeg.StepCycle = 0
					end					
					local fracThere = min(0.9, max(0, (mLeftLeg.FootPosition - mLeftLeg.LastStepTo).magnitude / getStrideFull()))
					mLeftLeg.StepSpeedMod = 1 / (1 - fracThere)	
				elseif not mStableStanding and (thetaBetweenFeet < rad(150) or distBetweenFeet > 0.2 or tooFar) and mAirborneFraction < 0.5 then
					mStableStanding = true
					-- Step the foot further from the rest pos
					local furtherLeg, furtherResting, otherSep;
					if rightSep.magnitude > leftSep.magnitude then
						furtherLeg = mRightLeg
						furtherResting = rightResting
						otherSep = leftSep
					else
						furtherLeg = mLeftLeg
						furtherResting = leftResting
						otherSep = rightSep
					end
					--
					furtherLeg.StepCycle = dt
					furtherLeg.Takeoff = furtherLeg.FootPosition
					furtherLeg.StepSpeedMod = 1
					if tooFar then
						furtherLeg.LastStepTo = furtherResting - 0.5*otherSep
					else
						furtherLeg.LastStepTo = furtherResting - otherSep
					end
					if (furtherLeg.Takeoff - furtherLeg.LastStepTo).magnitude < 0.2 then
						furtherLeg.StepCycle = 0
					end
				end
			end
			fixFeetPositionsY()
		end
		
		local leftFootPosition,rightFootPosition = mLeftLeg.FootPosition,mRightLeg.FootPosition
		local footAngle = getBaseRotationY()
		local leftFootRotation = CFAngles(0,FOOT_ANGLE + footAngle,0)
		local rightFootRotation = CFAngles(0,-FOOT_ANGLE + footAngle,0)
		return CFnew(leftFootPosition) * leftFootRotation,CFnew(rightFootPosition) * rightFootRotation
	end
	
	function FootPlanterClass:OffsetFeet(Offset)
		overrideVelocityWithZero = true
		for _,leg in pairs(mLegs) do
			leg.FootPosition = leg.FootPosition + Offset
			leg.LastStepTo = leg.LastStepTo + Offset
			if leg.Takeoff then leg.Takeoff = leg.Takeoff + Offset end
			if leg.AheadStep then leg.AheadStep = leg.AheadStep + Offset end
		end
		overrideVelocityWithZero = true
	end
	
	return FootPlanterClass
end



return FootPlanter]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX96373DD2F94647D79E8130289C78FE86">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Head</string>
						<string name="ScriptGuid">{4043F878-44DD-42A3-B202-753EBED361DE}</string>
						<ProtectedString name="Source"><![CDATA[--Stores information about the head of a character.
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local Limb = require(script.Parent.Parent:WaitForChild("NexusAppendage"):WaitForChild("Limb"))
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()

local Head = {}
Head.__index = Head
setmetatable(Head, Limb)

export type Head = {
    Head: BasePart,
    LastNeckRotationGlobal: number?,
} & typeof(setmetatable({}, Head)) & Limb.Limb



--[[
Creates a head.
--]]
function Head.new(HeadPart: BasePart): Head
    local self = setmetatable(Limb.new() :: any, Head) :: Head
    self.Head = HeadPart
    return self
end

--[[
Returns the offset from the head to
the location of the eyes.
--]]
function Head.GetEyesOffset(self: Head): CFrame
    return (self:GetAttachmentCFrame(self.Head, "FaceFrontAttachment") :: CFrame) * CFrame.new(0, (self.Head :: BasePart).Size.Y / 4, 0)
end

--[[
Returns the head CFrame for the
given VR input in global world space.
--]]
function Head.GetHeadCFrame(self: Head, VRHeadCFrame: CFrame): CFrame
    return VRHeadCFrame * self:GetEyesOffset():Inverse()
end

--[[
Returns the neck CFrame for the
given VR input in global world space.
--]]
function Head.GetNeckCFrame(self: Head, VRHeadCFrame: CFrame, TargetAngle: number?): CFrame
    --Get the base neck CFrame and angles.
    local BaseNeckCFrame = (self:GetHeadCFrame(VRHeadCFrame) :: CFrame) * (self:GetAttachmentCFrame(self.Head, "NeckRigAttachment") :: CFrame)
    local BaseNeckLookVector = BaseNeckCFrame.LookVector
    local BaseNeckLook,BaseNeckTilt = math.atan2(BaseNeckLookVector.X, BaseNeckLookVector.Z) + math.pi, math.asin(BaseNeckLookVector.Y)

    --Clamp the new neck tilt.
    local NewNeckTilt = 0
    local MaxNeckTilt = Settings:GetSetting("Appearance.MaxNeckTilt") or math.rad(60)
    if BaseNeckTilt > MaxNeckTilt then
        NewNeckTilt = BaseNeckTilt - MaxNeckTilt
    elseif BaseNeckTilt < -MaxNeckTilt then
        NewNeckTilt = BaseNeckTilt + MaxNeckTilt
    end

    --Clamp the neck rotation if it is turning.
    if TargetAngle then
        --Determine the minimum angle difference.
        --Modulus is not used as it guarentees a positive answer, not the minimum answer, which can be negative.
        local RotationDifference = (BaseNeckLook - TargetAngle)
        while RotationDifference > math.pi do RotationDifference = RotationDifference - (2 * math.pi) end
        while RotationDifference < -math.pi do RotationDifference = RotationDifference + (2 * math.pi) end

        --Set the angle based on if it is over the limit or not.
        local MaxNeckSeatedRotation = Settings:GetSetting("Appearance.MaxNeckSeatedRotation") or math.rad(60)
        if RotationDifference > MaxNeckSeatedRotation then
            BaseNeckLook = RotationDifference - MaxNeckSeatedRotation
        elseif RotationDifference < -MaxNeckSeatedRotation then
            BaseNeckLook = RotationDifference + MaxNeckSeatedRotation
        else
            BaseNeckLook = 0
        end
    else
        local MaxNeckRotation = Settings:GetSetting("Appearance.MaxNeckRotation") or math.rad(35)
        local LastNeckRotationGlobal = self.LastNeckRotationGlobal
        if LastNeckRotationGlobal then
            --Determine the minimum angle difference.
            --Modulus is not used as it guarentees a positive answer, not the minimum answer, which can be negative.
            local RotationDifference = (BaseNeckLook - LastNeckRotationGlobal)
            while RotationDifference > math.pi do RotationDifference = RotationDifference - (2 * math.pi) end
            while RotationDifference < -math.pi do RotationDifference = RotationDifference + (2 * math.pi) end

            --Set the angle based on if it is over the limit or not.
            --Ignore if there is no previous stored rotation or if the rotation is "big" (like teleporting).
            if math.abs(RotationDifference) < 1.5 * MaxNeckRotation then
                if RotationDifference > MaxNeckRotation then
                    BaseNeckLook = BaseNeckLook - MaxNeckRotation
                elseif RotationDifference < -MaxNeckRotation then
                    BaseNeckLook = BaseNeckLook + MaxNeckRotation
                else
                    BaseNeckLook = LastNeckRotationGlobal
                end
            end
        end
    end
    self.LastNeckRotationGlobal = BaseNeckLook

    --Return the new neck CFrame.
    return CFrame.new(BaseNeckCFrame.Position) * CFrame.Angles(0, BaseNeckLook, 0) * CFrame.Angles(NewNeckTilt, 0, 0)
end



return Head]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX08F3B3F06FF246879C642FB7D4338273">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Torso</string>
						<string name="ScriptGuid">{0E82B555-39EB-4994-9DD5-3EED8B22D5EC}</string>
						<ProtectedString name="Source"><![CDATA[ --Stores information about the torso of a character.
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local Limb = require(script.Parent.Parent:WaitForChild("NexusAppendage"):WaitForChild("Limb"))
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()

local Torso = {}
Torso.__index = Torso
setmetatable(Torso, Limb)

export type Torso = {
    LowerTorso: BasePart,
    UpperTorso: BasePart,
} & typeof(setmetatable({}, Torso)) & Limb.Limb



--[[
Creates a torso.
--]]
function Torso.new(LowerTorso: BasePart, UpperTorso: BasePart): Torso
    local self = setmetatable(Limb.new() :: any, Torso) :: Torso
    self.LowerTorso = LowerTorso
    self.UpperTorso = UpperTorso
    return self
end

--[[
Returns the lower and upper torso CFrames
for the given neck CFrame in global world space.
--]]
function Torso.GetTorsoCFrames(self: Torso, NeckCFrame: CFrame): (CFrame, CFrame)
    --Determine the upper torso CFrame.
    local UpperTorsoCFrame = NeckCFrame * self:GetAttachmentCFrame(self.UpperTorso, "NeckRigAttachment"):Inverse()

    --Determine the center CFrame with bending.
    local MaxTorsoBend = Settings:GetSetting("Appearance.MaxTorsoBend") or math.rad(10)
    local NeckTilt = math.asin(NeckCFrame.LookVector.Y)
    local LowerTorsoAngle = math.sign(NeckTilt) * math.min(math.abs(NeckTilt), MaxTorsoBend)
    local TorsoCenterCFrame = UpperTorsoCFrame * self:GetAttachmentCFrame(self.UpperTorso, "WaistRigAttachment") * CFrame.Angles(-LowerTorsoAngle, 0, 0)

    --Return the lower and upper CFrames.
    return TorsoCenterCFrame * self:GetAttachmentCFrame(self.LowerTorso, "WaistRigAttachment"):Inverse(), UpperTorsoCFrame
end

--[[
Returns the CFrames of the joints for
the appendages.
--]]
function Torso.GetAppendageJointCFrames(self: Torso, LowerTorsoCFrame: CFrame, UpperTorsoCFrame: CFrame): {[string]: CFrame}
    return {
        RightShoulder = UpperTorsoCFrame * self:GetAttachmentCFrame(self.UpperTorso, "RightShoulderRigAttachment"),
        LeftShoulder = UpperTorsoCFrame * self:GetAttachmentCFrame(self.UpperTorso, "LeftShoulderRigAttachment"),
        LeftHip = LowerTorsoCFrame * self:GetAttachmentCFrame(self.LowerTorso, "LeftHipRigAttachment"),
        RightHip = LowerTorsoCFrame * self:GetAttachmentCFrame(self.LowerTorso, "RightHipRigAttachment"),
    }
end



return Torso]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Script" referent="RBXD809F2F17A6E475D8124129F1B05305A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NexusVRCharacterModelClientLoader</string>
					<token name="RunContext">2</token>
					<string name="ScriptGuid">{0A019ED7-66E7-4FAA-A420-5174905B81F2}</string>
					<ProtectedString name="Source"><![CDATA[--Loads Nexus VR Character Model on the client.
--!strict

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VRService = game:GetService("VRService")

local NexusVRCharacterModel = ReplicatedStorage:WaitForChild("NexusVRCharacterModel") :: ModuleScript
local PlayerBufferedRemoteEventReceiver = require(NexusVRCharacterModel:WaitForChild("NexusBufferedReplication"):WaitForChild("Receiver"):WaitForChild("PlayerBufferedRemoteEventReceiver")) :: any
local CameraService = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CameraService")) :: any).GetInstance()
local CharacterService = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CharacterService")) :: any).GetInstance()
local ControlService = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("ControlService")) :: any).GetInstance()
local DefaultCursorService = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("DefaultCursorService")) :: any).GetInstance()
local EnigmaService = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("EnigmaService")) :: any).GetInstance()
local Settings = (require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")) :: any).GetInstance()
local BufferProtocol = require(NexusVRCharacterModel:WaitForChild("Util"):WaitForChild("BufferProtocol")) :: any
local UpdateInputs = NexusVRCharacterModel:WaitForChild("UpdateInputs") :: UnreliableRemoteEvent
local ReplicationReady = NexusVRCharacterModel:WaitForChild("ReplicationReady") :: RemoteEvent



--Add the deprecation warning to the bundled Nexus VR Core.
local BaseScreenGui = require(ReplicatedStorage:WaitForChild("NexusVRCore"):WaitForChild("Container"):WaitForChild("BaseScreenGui")) :: any
local OriginalBaseScreenGuiConstructor = BaseScreenGui.__new
BaseScreenGui.__new = function(...)
    warn("Using the bundled (automically loaded) Nexus VR Core with Nexus VR Character Model is deprecated.\nIt is recommended to move to a fixed version, which can be downloaded from GitHub.")
    return OriginalBaseScreenGuiConstructor(...)
end

--Load the settings.
Settings:SetDefaults(HttpService:JSONDecode((NexusVRCharacterModel:WaitForChild("Configuration") :: StringValue).Value))

--Connect replication for other players.
local LastPlayerUpdates = {} :: {[Player]: number}
local UpdateInputsPlayerBufferedRemoteEventReceiver = PlayerBufferedRemoteEventReceiver.new(UpdateInputs, function(Buffer)
    return BufferProtocol.Deserialize(Buffer)
end)
UpdateInputsPlayerBufferedRemoteEventReceiver:OnDataReceived(function(Player: Player, Data)
    if Player == Players.LocalPlayer then return end

    --Return if the update is after the latest update.
    --Unreliable events do not guarentee order.
    local UpdateTime = Data.UpdateTime
    if UpdateTime then
        if LastPlayerUpdates[Player] and UpdateTime < LastPlayerUpdates[Player] then return end
        LastPlayerUpdates[Player] = UpdateTime
    end

    --Update the character.
    local Character = CharacterService:GetCharacter(Player)
    if Character then
        Character:UpdateFromInputs(Data.HeadCFrame, Data.LeftHandCFrame, Data.RightHandCFrame, Data.CurrentWalkspeed, {
            LeftFoot = Data.LeftFootCFrame,
            RightFoot = Data.RightFootCFrame,
        })
    end
end)
Players.PlayerRemoving:Connect(function(Player)
    LastPlayerUpdates[Player] = nil
end)
ReplicationReady:FireServer()

--Connect updating all the character Motor6Ds.
--Must be done after Stepped to override Animators.
RunService.Stepped:Connect(function()
    CharacterService:RefreshAllCharacters()
end)

--Allow checking if Nexus VR Character Model is loaded without being in VR.
local LoadedPrintStatementPrinted = false
UserInputService.InputBegan:Connect(function(Input)
    if not LoadedPrintStatementPrinted and Input.KeyCode == Enum.KeyCode.F9 and (UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.RightControl)) and Settings:GetSetting("Output.AllowClientToOutputLoadedMessage") ~= false then
        LoadedPrintStatementPrinted = true
        print(`Nexus VR Character Model version {Settings:GetSetting("Version.Tag")} ({Settings:GetSetting("Version.Commit")}) is loaded.`)
    end
end)

--Wait for VR to be enabled.
while not UserInputService.VREnabled do
    UserInputService:GetPropertyChangedSignal("VREnabled"):Wait()
    warn("VR was detected later than when Nexus VR Character Model loaded. This may be a Roblox bug.")
end

--Disable the native VR controller models.
--Done in a pcall in case the SetCore is not registered or is removed.
task.spawn(function()
    for i = 1, 600 do
        local Worked = pcall(function()
            StarterGui:SetCore("VREnableControllerModels", false)
            DefaultCursorService:SetCursorState("Detect")
        end)
        if Worked then break end
        task.wait(0.1)
    end
end)

--Display a message if R6 is used.
local Character = Players.LocalPlayer.Character
while not Character do
    Character = Players.LocalPlayer.CharacterAdded:Wait()
end
if Character:WaitForChild("Humanoid").RigType == Enum.HumanoidRigType.R6 then
    local R6Message = (require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("R6Message")) :: any).new()
    R6Message:Open()
    return
end

--Set the initial controller and camera.
--Must happen before loading the settings in the main menu.
ControlService:SetActiveController(Settings:GetSetting("Movement.DefaultMovementMethod"))
CameraService:SetActiveCamera(Settings:GetSetting("Camera.DefaultCameraOption"))

--Load the menu.
local MainMenu = (require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("MainMenu")) :: any).GetInstance()
MainMenu:SetUpOpening()

--Load the backpack.
if Settings:GetSetting("Extra.NexusVRBackpackEnabled") ~= false then
    task.defer(function()
        local NexusVRBackpack = require(ReplicatedStorage:WaitForChild("NexusVRBackpack")) :: {Load: (any) -> ()}
        NexusVRBackpack:Load()
    end)
end

--Load Enigma.
if Settings:GetSetting("Extra.EnigmaEnabled") ~= false then
    EnigmaService:Enable()
end

--Start updating the VR character.
RunService:BindToRenderStep("NexusVRCharacterModelUpdate", Enum.RenderPriority.Camera.Value - 1, function()
    ControlService:UpdateCharacter()
end)

--Disable FadeOutViewOnCollision.
if Settings:GetSetting("DisableFadeOutViewOnCollision") == true then
    VRService.FadeOutViewOnCollision = false
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX80A4B2C615F643C28B17A0E59BB20065">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">State</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX568D773C314446CDA37B28BAE0DE318E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CameraService</string>
						<string name="ScriptGuid">{42A0CC81-BB4F-45D3-B09F-977E1FD2CE11}</string>
						<ProtectedString name="Source"><![CDATA[--Manages the local camera.
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local CommonCamera = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Camera"):WaitForChild("CommonCamera"))
local DefaultCamera = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Camera"):WaitForChild("DefaultCamera"))
local ThirdPersonTrackCamera = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Camera"):WaitForChild("ThirdPersonTrackCamera"))

local CameraService = {}
CameraService.__index = CameraService
local StaticInstance = nil

export type CameraService = {
    ActiveCamera: string,
    CurrentCamera: CameraInterface?,
    RegisteredCameras: {[string]: CameraInterface},
} & typeof(setmetatable({}, CameraService))

export type CameraInterface = {
    Enable: (self: CameraInterface) -> (),
    Disable: (self: CameraInterface) -> (),
    UpdateCamera: (self: CameraInterface, HeadsetCFrameWorld: CFrame) -> (),
}



--[[
Creates a camera service.
--]]
function CameraService.new(): CameraService
    --Create the object.
    local self = setmetatable({
        RegisteredCameras = {},
    }, CameraService) :: CameraService

    --Register the default controllers.
    self:RegisterCamera("Default", DefaultCamera.new() :: any)
    self:RegisterCamera("ThirdPersonTrack", ThirdPersonTrackCamera.new() :: any)
    self:RegisterCamera("Disabled", CommonCamera.new() :: any)

    --Return the object.
    return self
end

--[[
Returns a singleton instance of the camera service.
--]]
function CameraService.GetInstance(): CameraService
    if not StaticInstance then
        StaticInstance = CameraService.new()
    end
    return StaticInstance
end

--[[
Registers a camera.
--]]
function CameraService.RegisterCamera(self: CameraService, Name: string, Camera: CameraInterface): ()
    self.RegisteredCameras[Name] = Camera
end

--[[
Sets the active camera.
--]]
function CameraService.SetActiveCamera(self: CameraService, Name: string): ()
    --Return if the camera didn't change.
    if self.ActiveCamera == Name then return end
    self.ActiveCamera = Name

    --Disable the current camera.
    if self.CurrentCamera then
        self.CurrentCamera:Disable()
    end

    --Enable the new camera.
    self.CurrentCamera = self.RegisteredCameras[Name]
    if self.CurrentCamera then
        self.CurrentCamera:Enable()
    elseif Name ~= nil then
        warn(`Nexus VR Character Model camera \"{Name}\" is not registered.`)
    end
end

--[[
Updates the local camera.
--]]
function CameraService.UpdateCamera(self: CameraService,HeadsetCFrameWorld: CFrame): ()
    if self.CurrentCamera then
        self.CurrentCamera:UpdateCamera(HeadsetCFrameWorld)
    end
end



return CameraService]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3C64E964093D464CBF5115D4F86BCC58">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CharacterService</string>
						<string name="ScriptGuid">{3D7E0373-CB9D-477E-83F1-8D5CEF5B9CCE}</string>
						<ProtectedString name="Source"><![CDATA[--Manages VR characters.
--!strict

local Players = game:GetService("Players")

local NexusVRCharacterModel = script.Parent.Parent
local Character = require(NexusVRCharacterModel:WaitForChild("Character"))

local CharacterService = {}
CharacterService.__index = CharacterService
local StaticInstance = nil

export type CharacterService = {
    Characters: {[Player]: {
        Character: Model,
        VRCharacter: Character.Character,
    }},
} & typeof(setmetatable({}, CharacterService))



--[[
Creates a character service.
--]]
function CharacterService.new(): CharacterService
    --Create the object.
    local self = setmetatable({
        Characters = {},
    }, CharacterService) :: CharacterService

    --Connect clearing players.
    Players.PlayerRemoving:Connect(function(Player)
        self.Characters[Player] = nil
    end)

    --Return the object.
    return self
end

--[[
Returns a singleton instance of the character service.
--]]
function CharacterService.GetInstance(): CharacterService
    if not StaticInstance then
        StaticInstance = CharacterService.new()
    end
    return StaticInstance
end

--[[
Returns the VR character for a player.
--]]
function CharacterService.GetCharacter(self: CharacterService, Player: Player): Character.Character?
    --Return if the character is nil.
    if not Player.Character or not Player.Character:FindFirstChild("Head") then
        return nil
    end

    --Create the VR character if it isn't valid.
    local PlayerCharacter = self.Characters[Player]
    if not PlayerCharacter or PlayerCharacter.Character ~= Player.Character then
        self.Characters[Player] = {
            Character = Player.Character,
            VRCharacter = Character.new(Player.Character :: Model),
        }
    end

    --Return the stored character.
    return self.Characters[Player].VRCharacter
end

--[[
Refreshes all the characters.
--]]
function CharacterService.RefreshAllCharacters(self: CharacterService): ()
    for _, Character in self.Characters do
        Character.VRCharacter:RefreshCharacter()
    end
end



return CharacterService]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXCAC157E70843458E941C1ACB1EAF031F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ControlService</string>
						<string name="ScriptGuid">{F101AE82-F739-4C35-B16B-2A9B48E77985}</string>
						<ProtectedString name="Source"><![CDATA[--Manages controlling the local characters.
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local BaseController = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Controller"):WaitForChild("BaseController"))
local TeleportController = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Controller"):WaitForChild("TeleportController"))
local SmoothLocomotionController = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Controller"):WaitForChild("SmoothLocomotionController"))

local ControlService = {}
ControlService.__index = ControlService
local StaticInstance = nil

export type ControlService = {
    RegisteredControllers: {[string]: ControllerInterface},
    ActiveController: string,
    CurrentController: ControllerInterface?,
} & typeof(setmetatable({}, ControlService))

export type ControllerInterface = {
    Disable: (self: ControllerInterface) -> (),
    Enable: (self: ControllerInterface) -> (),
    UpdateCharacter: (self: ControllerInterface) -> (),
}



--[[
Creates a control service.
--]]
function ControlService.new(): ControlService
    --Create the object.
    local self = setmetatable({
        RegisteredControllers = {},
    }, ControlService) :: ControlService

    --Register the default controllers.
    local EmptyController = BaseController.new()
    EmptyController.ActionsToLock = {Enum.KeyCode.Thumbstick1, Enum.KeyCode.Thumbstick2, Enum.KeyCode.ButtonR3, Enum.KeyCode.ButtonA}
    self:RegisterController("None", EmptyController :: any)
    self:RegisterController("Teleport", TeleportController.new() :: any)
    self:RegisterController("SmoothLocomotion", SmoothLocomotionController.new() :: any)

    --Return the object.
    return self 
end

--[[
Returns a singleton instance of the character service.
--]]
function ControlService.GetInstance(): ControlService
    if not StaticInstance then
        StaticInstance = ControlService.new()
    end
    return StaticInstance
end

--[[
Registers a controller.
--]]
function ControlService.RegisterController(self: ControlService, Name: string, Controller: ControllerInterface): ()
    self.RegisteredControllers[Name] = Controller
end

--[[
Sets the active controller.
--]]
function ControlService.SetActiveController(self: ControlService, Name: string): ()
    --Return if the controller didn't change.
    if self.ActiveController == Name then return end
    self.ActiveController = Name

    --Disable the current controller.
    if self.CurrentController then
        self.CurrentController:Disable()
    end

    --Enable the new controller.
    self.CurrentController = self.RegisteredControllers[Name]
    if self.CurrentController then
        self.CurrentController:Enable()
    elseif Name ~= nil then
        warn(`Nexus VR Character Model controller \"{Name}\" is not registered.`)
    end
end

--[[
Updates the local character.
--]]
function ControlService:UpdateCharacter()
    if self.CurrentController then
        self.CurrentController:UpdateCharacter()
    end
end



return ControlService]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFCF940B7F5C245448E503595E6A3402B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">DefaultCursorService</string>
						<string name="ScriptGuid">{0B52ED00-41C4-43FE-8B42-630543834B1C}</string>
						<ProtectedString name="Source"><![CDATA[--Manages toggling the default cursor.
--Workaround for: https://github.com/TheNexusAvenger/Nexus-VR-Character-Model/issues/10
--!strict

local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local RunService = game:GetService("RunService")

local DefaultCursorService = {}
DefaultCursorService.__index = DefaultCursorService
local StaticInstance = nil

export type DefaultCursorService = {
    CursorOptionsList: {string},
    CurrentCursorState: string,
    CursorOptions: {[string]: () -> ()},
    CursorDisabledOptions: {[string]: () -> ()},
} & typeof(setmetatable({}, DefaultCursorService))



--[[
Creates a default cursor service.
--]]
function DefaultCursorService.new(): DefaultCursorService
    return setmetatable({
        CursorOptionsList = {"Detect", "Enabled", "Disabled"},
        CursorOptions = {
            Detect = function()
                --Enable the pointer.
                StarterGui:SetCore("VRLaserPointerMode", "Pointer")
    
                --Wait until the next frame to register the BindToRenderStep. Otherwise, the order is
                RunService.Stepped:Wait()
    
                --Enable the workaround for moving the pointer when the cursor isn't active.
                --It must be Last + 1 because the Core Script uses Last.
                RunService:BindToRenderStep("NexusVRCharacterModel_MoveCursorWorkaround", Enum.RenderPriority.Last.Value + 1, function()
                    local Camera = Workspace.CurrentCamera
                    local VRCoreEffectParts = Camera:FindFirstChild("VRCoreEffectParts")
                    if VRCoreEffectParts then
                        local LaserPointerOrigin = VRCoreEffectParts:FindFirstChild("LaserPointerOrigin")
                        local Cursor = VRCoreEffectParts:FindFirstChild("Cursor")
                        if LaserPointerOrigin and Cursor then
                            local CursorSurfaceGui = Cursor:FindFirstChild("CursorSurfaceGui")
                            if CursorSurfaceGui and not CursorSurfaceGui.Enabled then
                                LaserPointerOrigin.CFrame = CFrame.new(0, math.huge, 0)
                            end
                        end
                    end
                end)
            end,
            Enabled = function()
                StarterGui:SetCore("VRLaserPointerMode", "Pointer")
            end,
            Disabled = function()
                StarterGui:SetCore("VRLaserPointerMode", "Disabled")
            end,
        },
        CursorDisabledOptions = {
            Detect = function()
                RunService:UnbindFromRenderStep("NexusVRCharacterModel_MoveCursorWorkaround")
            end,
        },
    }, DefaultCursorService) :: DefaultCursorService
end

--[[
Returns a singleton instance of the character service.
--]]
function DefaultCursorService.GetInstance(): DefaultCursorService
    if not StaticInstance then
        StaticInstance = DefaultCursorService.new()
    end
    return StaticInstance
end

--[[
Sets the cursor state.
--]]
function DefaultCursorService.SetCursorState(self: DefaultCursorService, OptionName: string): ()
    if self.CurrentCursorState == OptionName then return end
    if self.CurrentCursorState and self.CursorDisabledOptions[self.CurrentCursorState] then
        self.CursorDisabledOptions[self.CurrentCursorState]()
    end
    self.CurrentCursorState = OptionName
    task.spawn(self.CursorOptions[OptionName])
end



return DefaultCursorService]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2761D0C48010462DA788D5FEDE857910">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">EnigmaService</string>
						<string name="ScriptGuid">{5D58B757-B9C5-4018-9354-11A62A98CFA2}</string>
						<ProtectedString name="Source"><![CDATA[--Manages reeading UserCframes from Enigma.
--!strict

local THUMBSTICK_DEADZONE = 0.2

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VRService = game:GetService("VRService")

local NexusVRCharacterModel = script.Parent.Parent
local Enigma = require(NexusVRCharacterModel:WaitForChild("Enigma"))
local Head = require(NexusVRCharacterModel:WaitForChild("Character"):WaitForChild("Head"))

local EnigmaService = {}
EnigmaService.__index = EnigmaService
local StaticInstance = nil

export type EnigmaService = {
    Offsets: {
        LeftFoot: CFrame?,
        RightFoot: CFrame?,
    },
} & typeof(setmetatable({}, EnigmaService))
export type TrackerData = {
    LeftFoot: CFrame?,
    RightFoot: CFrame?,
}



--[[
Creates an Enigma service.
--]]
function EnigmaService.new(): EnigmaService
    return setmetatable({
        Offsets = {},
    }, EnigmaService) :: EnigmaService
end

--[[
Returns a singleton instance of the Enigma service.
--]]
function EnigmaService.GetInstance(): EnigmaService
    if not StaticInstance then
        StaticInstance = EnigmaService.new()
    end
    return StaticInstance
end

--[[
Returns the CFrames for the trackers.
--]]
function EnigmaService.GetCFrames(self: EnigmaService, Character: any): TrackerData
    if not Enigma.Enabled then return {} end
    local HeadsetWorldCFrame = Character.Parts.Head.CFrame * Character.Head:GetEyesOffset()
    local OriginWorldCFrame = HeadsetWorldCFrame * UserInputService:GetUserCFrame(Enum.UserCFrame.Head):Inverse()

    local LeftFootTrackerCFrame = Enigma:GetUserCFrame("LeftFoot")
    local RightFootTrackerCFrame = Enigma:GetUserCFrame("RightFoot")
    local Offsets = {}
    if LeftFootTrackerCFrame and self.Offsets.LeftFoot then
        Offsets.LeftFoot = OriginWorldCFrame * LeftFootTrackerCFrame * self.Offsets.LeftFoot
    end
    if RightFootTrackerCFrame and self.Offsets.RightFoot then
        Offsets.RightFoot = OriginWorldCFrame * RightFootTrackerCFrame * self.Offsets.RightFoot
    end
    return Offsets
end

--[[
Calibrates any inputs based on the current inputs.
--]]
function EnigmaService.Calibrate(self: EnigmaService, Character: any): ()
    if not Enigma.Enabled then return end
    local LeftFootTrackerCFrame = Enigma:GetUserCFrame("LeftFoot")
    local RightFootTrackerCFrame = Enigma:GetUserCFrame("RightFoot")
    if not LeftFootTrackerCFrame and not RightFootTrackerCFrame then return end
    local Attachments = Character.Attachments
    local HeadsetWorldCFrame = Workspace.CurrentCamera:GetRenderCFrame()
    local OriginWorldCFrame = HeadsetWorldCFrame * UserInputService:GetUserCFrame(Enum.UserCFrame.Head):Inverse()
    local FloorWorldCFrame = OriginWorldCFrame * UserInputService:GetUserCFrame(Enum.UserCFrame.Floor)
    
    local NewCharacterHead = Head.new(Character.Parts.Head)
    local HeadWorldCFrame = NewCharacterHead:GetHeadCFrame(HeadsetWorldCFrame)
    local NeckWorldCFrame = NewCharacterHead:GetNeckCFrame(HeadWorldCFrame)
    local LowerTorsoCFrame = NeckWorldCFrame * Attachments.UpperTorso.NeckRigAttachment.CFrame:Inverse() * Attachments.UpperTorso.WaistRigAttachment.CFrame * Attachments.LowerTorso.WaistRigAttachment.CFrame:Inverse()

    if LeftFootTrackerCFrame then
        local LeftFootTrackerWorldCFrame = OriginWorldCFrame * LeftFootTrackerCFrame
        local LeftUpperLegCFrame = LowerTorsoCFrame * Attachments.LowerTorso.LeftHipRigAttachment.CFrame * Attachments.LeftUpperLeg.LeftHipRigAttachment.CFrame:Inverse()
        local LeftLowerLegCFrame = LeftUpperLegCFrame * Attachments.LeftUpperLeg.LeftKneeRigAttachment.CFrame * Attachments.LeftLowerLeg.LeftKneeRigAttachment.CFrame:Inverse()
        local LeftFootCFrame = LeftLowerLegCFrame * Attachments.LeftLowerLeg.LeftAnkleRigAttachment.CFrame * Attachments.LeftFoot.LeftAnkleRigAttachment.CFrame:Inverse()
        local LeftFootBottomCFrame = LeftFootCFrame * Attachments.LeftFoot.LeftFootAttachment.CFrame
        LeftFootCFrame = CFrame.new(0, FloorWorldCFrame.Y - LeftFootBottomCFrame.Y, 0) * LeftFootCFrame
        self.Offsets.LeftFoot = LeftFootTrackerWorldCFrame:Inverse() * LeftFootCFrame
    end
    if RightFootTrackerCFrame then
        local RightFootTrackerWorldCFrame = OriginWorldCFrame * RightFootTrackerCFrame
        local RightUpperLegCFrame = LowerTorsoCFrame * Attachments.LowerTorso.RightHipRigAttachment.CFrame * Attachments.RightUpperLeg.RightHipRigAttachment.CFrame:Inverse()
        local RightLowerLegCFrame = RightUpperLegCFrame * Attachments.RightUpperLeg.RightKneeRigAttachment.CFrame * Attachments.RightLowerLeg.RightKneeRigAttachment.CFrame:Inverse()
        local RightFootCFrame = RightLowerLegCFrame * Attachments.RightLowerLeg.RightAnkleRigAttachment.CFrame * Attachments.RightFoot.RightAnkleRigAttachment.CFrame:Inverse()
        local RightFootBottomCFrame = RightFootCFrame * Attachments.RightFoot.RightFootAttachment.CFrame
        RightFootCFrame = CFrame.new(0, FloorWorldCFrame.Y - RightFootBottomCFrame.Y, 0) * RightFootCFrame
        self.Offsets.RightFoot = RightFootTrackerWorldCFrame:Inverse() * RightFootCFrame
    end
end

--[[
Enables Enigma.
--]]
function EnigmaService.Enable(self: EnigmaService): ()
    --Enable Enigma.
    Enigma:Enable()

    --Implement the inputs.
    --Pasting data interrupts the gamepad inputs.
    local LastLeftThumbstick = Vector3.zero
    local ButtonADown = false
    UserInputService.InputBegan:Connect(function(Input)
        if Input.KeyCode == Enum.KeyCode.ButtonA then
            ButtonADown = true
        end
    end)
    UserInputService.InputChanged:Connect(function(Input)
        if Input.KeyCode == Enum.KeyCode.Thumbstick1 then
            if Input.Position.Magnitude > THUMBSTICK_DEADZONE then
                LastLeftThumbstick = Input.Position
            else
                LastLeftThumbstick = Vector3.zero
            end
        end
    end)
    UserInputService.InputEnded:Connect(function(Input)
        if Input.KeyCode == Enum.KeyCode.Thumbstick1 then
            LastLeftThumbstick = Vector3.zero
        elseif Input.KeyCode == Enum.KeyCode.ButtonA then
            ButtonADown = false
        end
    end)

    RunService:BindToRenderStep("EnigmaCustomMovement", Enum.RenderPriority.Input.Value + 1, function()
        --Return if Enigma isn't active.
        if not Enigma:IsActive() then return end

        --Return if the character is invalid.
        local Character = Players.LocalPlayer.Character
        if not Character then return end
        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        if not Humanoid or Humanoid.Health <= 0 then return end

        --Move the character.
        local MovementReferenceWorldCFrame = Workspace.CurrentCamera:GetRenderCFrame()
        local MovementReferenceRotation = CFrame.new(-MovementReferenceWorldCFrame.Position) * MovementReferenceWorldCFrame
        local MoveDirection = (MovementReferenceRotation * CFrame.new(LastLeftThumbstick.X, 0, -LastLeftThumbstick.Y)).Position
        if MoveDirection.Magnitude > 0.01 or not VRService.AvatarGestures then --Move is not overriden with AvatarGestures since it does continous movements when not walking.
            Players.LocalPlayer:Move(MoveDirection, false)
        end
        if ButtonADown then
            Humanoid.Jump = true
        end
    end)
end



return EnigmaService]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3C0D09FF4CE54AF49F5C7B28BB5BBF93">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Settings</string>
						<string name="ScriptGuid">{9A5B83C7-52FD-466C-A4AD-F9E09AE39D64}</string>
						<ProtectedString name="Source"><![CDATA[--Stores settings.
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local TypedEvent = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("Event"):WaitForChild("TypedEvent"))

local Settings ={}
Settings.__index = Settings
local StaticInstance = nil

export type Settings ={
    Defaults: any,
    Overrides: any,
    SettingsChangeEvents: {[string]: TypedEvent.TypedEvent<>},
    SettingsCache: {[string]: any},
} & typeof(setmetatable({}, Settings))



--[[
Creates a settings object.
--]]
function Settings.new(): Settings
    return setmetatable({
        Defaults = {},
        Overrides = {},
        SettingsChangeEvents = {},
        SettingsCache = {},
    }, Settings) :: Settings
end

--[[
Returns a singleton instance of settings.
--]]
function Settings.GetInstance(): Settings
    if not StaticInstance then
        StaticInstance = Settings.new()
    end
    return StaticInstance
end

--[[
Returns the value of a setting.
--]]
function Settings.GetSetting(self: Settings, Setting: string): any
    --Return a cached entry if one exists.
    if self.SettingsCache[Setting] ~= nil then
        return self.SettingsCache[Setting]
    end

    --Get the table containing the setting.
    local Defaults, Overrides = self.Defaults, self.Overrides
    local SplitSettingNames = string.split(Setting, ".")
    for i = 1, #SplitSettingNames - 1 do
        Defaults = Defaults[SplitSettingNames[i]] or {}
        Overrides = Overrides[SplitSettingNames[i]] or {}
    end

    --Return the value.
    local Value = Overrides[SplitSettingNames[#SplitSettingNames]]
    if Value == nil then
        Value = Defaults[SplitSettingNames[#SplitSettingNames]]
    end
    self.SettingsCache[Setting] = Value
    return Value
end

--[[
Sets the value of a setting.
--]]
function Settings.SetSetting(self: Settings, Setting: string, Value: any): ()
    --Set the setting.
    local Overrides = self.Overrides
    local SplitSettingNames = string.split(Setting,".")
    for i = 1, #SplitSettingNames - 1 do
        if not Overrides[SplitSettingNames[i]] then
            Overrides[SplitSettingNames[i]] = {}
        end
        Overrides = Overrides[SplitSettingNames[i]]
    end
    Overrides[SplitSettingNames[#SplitSettingNames]] = Value
    self.SettingsCache[Setting] = Value

    --Fire the changed signal.
    local Event = self.SettingsChangeEvents[string.lower(Setting)]
    if Event then
        Event:Fire()
    end
end

--[[
Sets all the defaults.
--]]
function Settings.SetDefaults(self: Settings, Defaults: {[string]: any}): ()
    --Set the defaults.
    self.Defaults = Defaults
    self.SettingsCache = {}

    --Fire all the event changes.
    for _, Event in self.SettingsChangeEvents do
        (Event :: TypedEvent.TypedEvent<>):Fire()
    end
end

--[[
Sets all the overrides.
--]]
function Settings.SetOverrides(self: Settings, Overrides: {[string]: any}): ()
    --Set the overrides.
    self.Overrides = Overrides
    self.SettingsCache = {}

    --Fire all the event changes.
    for _, Event in self.SettingsChangeEvents do
        (Event :: TypedEvent.TypedEvent<>):Fire()
    end
end

--[[
Returns a changed signal for a setting.
--]]
function Settings.GetSettingsChangedSignal(self: Settings, Overrides: string): TypedEvent.TypedEvent<>
    Overrides = string.lower(Overrides)

    --Create the event if none exists.
    if not self.SettingsChangeEvents[Overrides] then
        self.SettingsChangeEvents[Overrides] = TypedEvent.new()
    end

    --Return the event.
    return self.SettingsChangeEvents[Overrides]
end

--[[
Destroys the settings.
--]]
function Settings.Destroy(self: Settings): ()
    --Disconnect the settings.
    for _,Event in self.SettingsChangeEvents do
        (Event :: TypedEvent.TypedEvent<>):Destroy()
    end
    self.SettingsChangeEvents = {}
end



return Settings]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4FB13BF53283492284F6535B1C3F5189">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">VRInputService</string>
						<string name="ScriptGuid">{FD4B9ED1-1982-4590-99FF-C5F6D269C5BC}</string>
						<ProtectedString name="Source"><![CDATA[--Manages VR inputs. This normalizes the inputs from
--the headsets as the Y position of the inputs is arbitrary,
--meaning it can be the floor, eye level, or random.
--!strict

local NexusVRCharacterModel = script.Parent.Parent
local TypedEvent = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("Event"):WaitForChild("TypedEvent"))

local VRInputService = {}
VRInputService.__index = VRInputService
local StaticInstance = nil

export type VRInputService = {
    RecenterOffset: CFrame,
    ManualNormalHeadLevel: number?,
    HighestHeadHeight: number?,
    ThumbstickValues: {[Enum.KeyCode]: Vector3},
    VRService: VRService,
    UserInputService: UserInputService,
    Recentered: TypedEvent.TypedEvent<>,
    EyeLevelSet: TypedEvent.TypedEvent<>,
} & typeof(setmetatable({}, VRInputService))



--[[
Creates a settings object.
--]]
function VRInputService.new(VRService: VRService?, UserInputService: UserInputService?): VRInputService
    --Create the object.
    local self = setmetatable({
        RecenterOffset = CFrame.identity,
        ThumbstickValues = {
            [Enum.KeyCode.Thumbstick1] = Vector3.zero,
            [Enum.KeyCode.Thumbstick2] = Vector3.zero,
        },
        VRService = VRService or game:GetService("VRService"),
        UserInputService = UserInputService or game:GetService("UserInputService"),
        Recentered = TypedEvent.new(),
        EyeLevelSet = TypedEvent.new(),
    }, VRInputService) :: VRInputService

    --Connect updating the thumbsticks.
    self.UserInputService.InputEnded:Connect(function(Input)
        if self.ThumbstickValues[Input.KeyCode] then
            self.ThumbstickValues[Input.KeyCode] = Vector3.zero
        end
    end)
    self.UserInputService.InputChanged:Connect(function(Input)
        if self.ThumbstickValues[Input.KeyCode] then
            self.ThumbstickValues[Input.KeyCode] = Input.Position
        end
    end)

    --Return the object.
    return self
end

--[[
Returns a singleton instance of the VR input service.
--]]
function VRInputService.GetInstance(): VRInputService
    if not StaticInstance then
        StaticInstance = VRInputService.new()
    end
    return StaticInstance
end

--[[
Returns the VR inputs to use. The inputs are normalized
so that 0 is the head height.
--]]
function VRInputService.GetVRInputs(self: VRInputService): {[Enum.UserCFrame]: CFrame}
    --Get the head input.
    local VRInputs = {
        [Enum.UserCFrame.Head] = self.VRService:GetUserCFrame(Enum.UserCFrame.Head),
    } :: {[Enum.UserCFrame]: CFrame}

    --Get the hand inputs.
    if self.VRService:GetUserCFrameEnabled(Enum.UserCFrame.LeftHand) then
        VRInputs[Enum.UserCFrame.LeftHand] = self.VRService:GetUserCFrame(Enum.UserCFrame.LeftHand)
    else
        VRInputs[Enum.UserCFrame.LeftHand] = VRInputs[Enum.UserCFrame.Head] * CFrame.new(-1, -2.5, 0.5)
    end
    if self.VRService:GetUserCFrameEnabled(Enum.UserCFrame.RightHand) then
        VRInputs[Enum.UserCFrame.RightHand] = self.VRService:GetUserCFrame(Enum.UserCFrame.RightHand)
    else
        VRInputs[Enum.UserCFrame.RightHand] = VRInputs[Enum.UserCFrame.Head] * CFrame.new(1, -2.5, 0.5)
    end

    --Determine the height offset.
    local HeightOffset = 0
    if self.ManualNormalHeadLevel then
        --Adjust to normalize the height around the set value.
        HeightOffset = -self.ManualNormalHeadLevel
    else
        --Adjust to normalize the height around the highest value.
        --The head CFrame is moved back 0.5 studs for when the headset suddenly goes up (like putting on and taking off).
        local CurrentVRHeadHeight = (VRInputs[Enum.UserCFrame.Head] * CFrame.new(0, 0, 0.5)).Y
        if not self.HighestHeadHeight or CurrentVRHeadHeight > self.HighestHeadHeight then
            self.HighestHeadHeight = CurrentVRHeadHeight
        end
        HeightOffset = -self.HighestHeadHeight :: number
    end

    --Normalize the CFrame heights.
    --A list of enums is used instead of VRInputs because modifying a table stops pairs().
    for _, InputEnum in {Enum.UserCFrame.Head, Enum.UserCFrame.LeftHand, Enum.UserCFrame.RightHand} do
        VRInputs[InputEnum] = CFrame.new(0, HeightOffset, 0) * self.RecenterOffset * VRInputs[InputEnum]
    end

    --Return the CFrames.
    return VRInputs
end

--[[
Recenters the service.
Does not alter the Y axis.
--]]
function VRInputService.Recenter(self: VRInputService): ()
    local HeadCFrame = self.VRService:GetUserCFrame(Enum.UserCFrame.Head)
    self.RecenterOffset = CFrame.Angles(0, -math.atan2(-HeadCFrame.LookVector.X, -HeadCFrame.LookVector.Z), 0) * CFrame.new(-HeadCFrame.X, 0, -HeadCFrame.Z)
    self.Recentered:Fire()
end

--[[
Sets the eye level.
--]]
function VRInputService.SetEyeLevel(self: VRInputService): ()
    self.ManualNormalHeadLevel = self.VRService:GetUserCFrame(Enum.UserCFrame.Head).Y
    self.EyeLevelSet:Fire()
end

--[[
Returns the current value for a thumbstick.
--]]
function VRInputService.GetThumbstickPosition(self: VRInputService, Thumbsick: Enum.KeyCode): Vector3
    return self.ThumbstickValues[Thumbsick] or Vector3.zero
end



return VRInputService]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX047ADF255FFC4746BB46E854EF925F9D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">UI</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXE01FAF3E307F4C36B123C2D2A754E260">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">MainMenu</string>
						<string name="ScriptGuid">{8AD15EBE-DA42-4D2C-8F26-25D31F6E169C}</string>
						<ProtectedString name="Source"><![CDATA[--Main menu for Nexus VR Character Model.
--!strict

local MENU_OPEN_TIME_REQUIREMENT = 1
local MENU_OPEN_TIME = 0.25



local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local NexusVRCharacterModel = script.Parent.Parent
local ScreenGui3D = require(NexusVRCharacterModel:WaitForChild("NexusVRCore"):WaitForChild("Container"):WaitForChild("ScreenGui3D"))
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()
local ApiBaseView = require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("View"):WaitForChild("ApiBaseView"))
local EnigmaView = require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("View"):WaitForChild("EnigmaView"))
local SettingsView = require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("View"):WaitForChild("SettingsView"))
local NexusButton = require(NexusVRCharacterModel:WaitForChild("NexusButton"))
local TextButtonFactory = require(NexusVRCharacterModel:WaitForChild("NexusButton"):WaitForChild("Factory"):WaitForChild("TextButtonFactory")).CreateDefault(Color3.fromRGB(0, 170, 255))
TextButtonFactory:SetDefault("Theme", "RoundedCorners")

local MainMenu = {}
MainMenu.__index = MainMenu
local StaticInstance = nil

export type MainMenu = {
    CurrentView: number,
    Views: {any},
    ScreenGui: ScreenGui3D.NexusInstanceScreenGui3D,
    ViewAdornFrame: Frame,
    LeftButton: NexusButton.NexusButton,
    RightButton: NexusButton.NexusButton,
    ViewTextLabel: TextLabel,
    LeftHandHintVisible: boolean,
    RightHandHintVisible: boolean,
} & typeof(setmetatable({}, MainMenu))



--[[
Creates the main menu.
--]]
function MainMenu.new(): any
    local self = setmetatable({}, MainMenu) :: MainMenu

    --Set up the ScreenGui.
    local MainMenuScreenGui = ScreenGui3D.new()
    MainMenuScreenGui.ResetOnSpawn = false
    MainMenuScreenGui.Enabled = false
    MainMenuScreenGui.CanvasSize = Vector2.new(500, 605)
    MainMenuScreenGui.FieldOfView = 0
    MainMenuScreenGui.Easing = 0.25
    self.ScreenGui = MainMenuScreenGui

    --Create the parent frame, display text, and toggle buttons.
    local ViewAdornFrame = Instance.new("Frame")
    ViewAdornFrame.BackgroundTransparency = 1
    ViewAdornFrame.Size = UDim2.new(0, 500, 0, 500)
    ViewAdornFrame.Parent = MainMenuScreenGui:GetContainer()
    self.ViewAdornFrame = ViewAdornFrame

    local ButtonAdornFrame = Instance.new("Frame")
    ButtonAdornFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    ButtonAdornFrame.BackgroundTransparency = 0.6 * GuiService.PreferredTransparency
    ButtonAdornFrame.Position = UDim2.new(0, 0, 0, 505)
    ButtonAdornFrame.Size = UDim2.new(1, 0, 0, 100)
    ButtonAdornFrame.Parent = ViewAdornFrame
    GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
        ButtonAdornFrame.BackgroundTransparency = 0.6 * GuiService.PreferredTransparency
    end)

    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(5 * 0.05, 0)
    UICorner.Parent = ButtonAdornFrame

    local LeftButton, LeftText = TextButtonFactory:Create()
    LeftButton.BorderSize = UDim.new(0.075, 0)
    LeftButton.Size = UDim2.new(0, 80, 0, 80)
    LeftButton.Position = UDim2.new(0, 10, 0, 10)
    LeftButton.Parent = ButtonAdornFrame
    LeftText.Text = "<"
    self.LeftButton = LeftButton

    local RightButton, RightText = TextButtonFactory:Create()
    RightButton.BorderSize = UDim.new(0.075, 0)
    RightButton.Size = UDim2.new(0, 80, 0, 80)
    RightButton.Position = UDim2.new(0, 410, 0, 10)
    RightButton.Parent = ButtonAdornFrame
    RightText.Text = ">"
    self.RightButton = RightButton

    local ViewTextLabel = Instance.new("TextLabel")
    ViewTextLabel.BackgroundTransparency = 1
    ViewTextLabel.Size = UDim2.new(0, 300, 0, 60)
    ViewTextLabel.Position = UDim2.new(0, 100, 0, 20)
    ViewTextLabel.Font = Enum.Font.SourceSansBold
    ViewTextLabel.TextScaled = true
    ViewTextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    ViewTextLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    ViewTextLabel.TextStrokeTransparency = 0
    ViewTextLabel.Parent = ButtonAdornFrame
    self.ViewTextLabel = ViewTextLabel

    --Set up the default views.
    self.CurrentView = 1
    self.Views = {}
    SettingsView.new(self:CreateView("Settings"));
    EnigmaView.new(self:CreateView("Enigma"), self);
    self:UpdateVisibleView()

    --Connect changing views.
    local DB = true
    LeftButton.MouseButton1Down:Connect(function()
        if not DB then return end
        DB = false

        --De-increment the current view.
        self.CurrentView = self.CurrentView - 1
        if self.CurrentView == 0 then
            self.CurrentView = #self.Views
        end

        --Update the views.
        self:UpdateVisibleView()
        task.wait()
        DB = true
    end)
    RightButton.MouseButton1Down:Connect(function()
        if not DB then return end
        DB = false

        --Increment the current view.
        self.CurrentView = self.CurrentView + 1
        if self.CurrentView > #self.Views then
            self.CurrentView = 1
        end

        --Update the views.
        self:UpdateVisibleView()
        task.wait()
        DB = true
    end)

    --Parent the menu.
    MainMenuScreenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    return self
end

--[[
Returns a singleton instance of the character service.
--]]
function MainMenu.GetInstance(): MainMenu
    if not StaticInstance then
        StaticInstance = MainMenu.new()
    end
    return StaticInstance
end

--[[
Sets up opening based on the controllers
being rotated upwards.
--]]
function MainMenu.SetUpOpening(self: MainMenu): ()
    --Create the animation parts.
    local InitialMenuToggleGestureActive = Settings:GetSetting("Menu.MenuToggleGestureActive")
    if InitialMenuToggleGestureActive == nil then
        InitialMenuToggleGestureActive = true
    end

    local LeftAdornPart = Instance.new("Part")
    LeftAdornPart.Transparency = 1
    LeftAdornPart.Size = Vector3.new()
    LeftAdornPart.Anchored = true
    LeftAdornPart.CanCollide = false
    LeftAdornPart.CanQuery = false
    LeftAdornPart.Parent = Workspace.CurrentCamera

    local LeftAdorn = Instance.new("BoxHandleAdornment")
    LeftAdorn.Color3 = Color3.fromRGB(0, 170, 255)
    LeftAdorn.AlwaysOnTop = true
    LeftAdorn.ZIndex = 0
    LeftAdorn.Adornee = LeftAdornPart
    LeftAdorn.Parent = LeftAdornPart

    local RightAdornPart = Instance.new("Part")
    RightAdornPart.Transparency = 1
    RightAdornPart.Size = Vector3.new()
    RightAdornPart.Anchored = true
    RightAdornPart.CanCollide = false
    RightAdornPart.CanQuery = false
    RightAdornPart.Parent = Workspace.CurrentCamera

    local RightAdorn = Instance.new("BoxHandleAdornment")
    RightAdorn.Color3 = Color3.fromRGB(0, 170 , 255)
    RightAdorn.AlwaysOnTop = true
    RightAdorn.ZIndex = 0
    RightAdorn.Adornee = RightAdornPart
    RightAdorn.Parent = RightAdornPart

    local LeftMenuToggleHintAdornPart = Instance.new("Part")
    LeftMenuToggleHintAdornPart.Transparency = 1
    LeftMenuToggleHintAdornPart.Size = Vector3.new(1,1,0)
    LeftMenuToggleHintAdornPart.Anchored = true
    LeftMenuToggleHintAdornPart.CanCollide = false
    LeftMenuToggleHintAdornPart.CanQuery = false
    LeftMenuToggleHintAdornPart.Parent = Workspace.CurrentCamera

    local RightMenuToggleHintAdornPart = Instance.new("Part")
    RightMenuToggleHintAdornPart.Transparency = 1
    RightMenuToggleHintAdornPart.Size = Vector3.new(1,1,0)
    RightMenuToggleHintAdornPart.Anchored = true
    RightMenuToggleHintAdornPart.CanCollide = false
    RightMenuToggleHintAdornPart.CanQuery = false
    RightMenuToggleHintAdornPart.Parent = Workspace.CurrentCamera

    local LeftMenuToggleHintGuiFront = Instance.new("SurfaceGui")
    LeftMenuToggleHintGuiFront.Active = false
    LeftMenuToggleHintGuiFront.Face = Enum.NormalId.Front
    LeftMenuToggleHintGuiFront.CanvasSize = Vector2.new(500,500)
    LeftMenuToggleHintGuiFront.LightInfluence = 0
    LeftMenuToggleHintGuiFront.Enabled = InitialMenuToggleGestureActive
    LeftMenuToggleHintGuiFront.AlwaysOnTop = true
    LeftMenuToggleHintGuiFront.Adornee = LeftMenuToggleHintAdornPart
    LeftMenuToggleHintGuiFront.Parent = LeftMenuToggleHintAdornPart

    local LeftMenuToggleHintFrontArrow = Instance.new("ImageLabel")
    LeftMenuToggleHintFrontArrow.ImageTransparency = 1
    LeftMenuToggleHintFrontArrow.BackgroundTransparency = 1
    LeftMenuToggleHintFrontArrow.Rotation = 180
    LeftMenuToggleHintFrontArrow.Size = UDim2.new(1,0,1,0)
    LeftMenuToggleHintFrontArrow.Image = "rbxassetid://6537091378"
    LeftMenuToggleHintFrontArrow.ImageRectSize = Vector2.new(512,512)
    LeftMenuToggleHintFrontArrow.ImageRectOffset = Vector2.new(0,0)
    LeftMenuToggleHintFrontArrow.Parent = LeftMenuToggleHintGuiFront

    local LeftMenuToggleHintFrontText = Instance.new("ImageLabel")
    LeftMenuToggleHintFrontText.ImageTransparency = 1
    LeftMenuToggleHintFrontText.BackgroundTransparency = 1
    LeftMenuToggleHintFrontText.Size = UDim2.new(1,0,1,0)
    LeftMenuToggleHintFrontText.ZIndex = 2
    LeftMenuToggleHintFrontText.Image = "rbxassetid://6537091378"
    LeftMenuToggleHintFrontText.ImageRectSize = Vector2.new(512,512)
    LeftMenuToggleHintFrontText.ImageRectOffset = Vector2.new(0,512)
    LeftMenuToggleHintFrontText.Parent = LeftMenuToggleHintGuiFront

    local LeftMenuToggleHintGuiBack = Instance.new("SurfaceGui")
    LeftMenuToggleHintGuiBack.Active = false
    LeftMenuToggleHintGuiBack.Face = Enum.NormalId.Back
    LeftMenuToggleHintGuiBack.CanvasSize = Vector2.new(500,500)
    LeftMenuToggleHintGuiBack.LightInfluence = 0
    LeftMenuToggleHintGuiBack.Enabled = InitialMenuToggleGestureActive
    LeftMenuToggleHintGuiBack.AlwaysOnTop = true
    LeftMenuToggleHintGuiBack.Adornee = LeftMenuToggleHintAdornPart
    LeftMenuToggleHintGuiBack.Parent = LeftMenuToggleHintAdornPart

    local LeftMenuToggleHintBackArrow = Instance.new("ImageLabel")
    LeftMenuToggleHintBackArrow.ImageTransparency = 1
    LeftMenuToggleHintBackArrow.BackgroundTransparency = 1
    LeftMenuToggleHintBackArrow.Size = UDim2.new(1,0,1,0)
    LeftMenuToggleHintBackArrow.Image = "rbxassetid://6537091378"
    LeftMenuToggleHintBackArrow.ImageRectSize = Vector2.new(512,512)
    LeftMenuToggleHintBackArrow.ImageRectOffset = Vector2.new(512,0)
    LeftMenuToggleHintBackArrow.Parent = LeftMenuToggleHintGuiBack

    local LeftMenuToggleHintBackText = Instance.new("ImageLabel")
    LeftMenuToggleHintBackText.ImageTransparency = 1
    LeftMenuToggleHintBackText.BackgroundTransparency = 1
    LeftMenuToggleHintBackText.Size = UDim2.new(1,0,1,0)
    LeftMenuToggleHintBackText.ZIndex = 2
    LeftMenuToggleHintBackText.Image = "rbxassetid://6537091378"
    LeftMenuToggleHintBackText.ImageRectSize = Vector2.new(512,512)
    LeftMenuToggleHintBackText.ImageRectOffset = Vector2.new(0,512)
    LeftMenuToggleHintBackText.Parent = LeftMenuToggleHintGuiBack

    local RightMenuToggleHintGuiFront = Instance.new("SurfaceGui")
    RightMenuToggleHintGuiFront.Active = false
    RightMenuToggleHintGuiFront.Face = Enum.NormalId.Front
    RightMenuToggleHintGuiFront.CanvasSize = Vector2.new(500,500)
    RightMenuToggleHintGuiFront.LightInfluence = 0
    RightMenuToggleHintGuiFront.Enabled = InitialMenuToggleGestureActive
    RightMenuToggleHintGuiFront.AlwaysOnTop = true
    RightMenuToggleHintGuiFront.Adornee = RightMenuToggleHintAdornPart
    RightMenuToggleHintGuiFront.Parent = RightMenuToggleHintAdornPart

    local RightMenuToggleHintFrontArrow = Instance.new("ImageLabel")
    RightMenuToggleHintFrontArrow.ImageTransparency = 1
    RightMenuToggleHintFrontArrow.BackgroundTransparency = 1
    RightMenuToggleHintFrontArrow.Size = UDim2.new(1,0,1,0)
    RightMenuToggleHintFrontArrow.Image = "rbxassetid://6537091378"
    RightMenuToggleHintFrontArrow.ImageRectSize = Vector2.new(512,512)
    RightMenuToggleHintFrontArrow.ImageRectOffset = Vector2.new(512,0)
    RightMenuToggleHintFrontArrow.Parent = RightMenuToggleHintGuiFront

    local RightMenuToggleHintFrontText = Instance.new("ImageLabel")
    RightMenuToggleHintFrontText.ImageTransparency = 1
    RightMenuToggleHintFrontText.BackgroundTransparency = 1
    RightMenuToggleHintFrontText.Size = UDim2.new(1,0,1,0)
    RightMenuToggleHintFrontText.ZIndex = 2
    RightMenuToggleHintFrontText.Image = "rbxassetid://6537091378"
    RightMenuToggleHintFrontText.ImageRectSize = Vector2.new(512,512)
    RightMenuToggleHintFrontText.ImageRectOffset = Vector2.new(0,512)
    RightMenuToggleHintFrontText.Parent = RightMenuToggleHintGuiFront

    local RightMenuToggleHintGuiBack = Instance.new("SurfaceGui")
    RightMenuToggleHintGuiBack.Active = false
    RightMenuToggleHintGuiBack.Face = Enum.NormalId.Back
    RightMenuToggleHintGuiBack.CanvasSize = Vector2.new(500,500)
    RightMenuToggleHintGuiBack.LightInfluence = 0
    RightMenuToggleHintGuiBack.Enabled = InitialMenuToggleGestureActive
    RightMenuToggleHintGuiBack.AlwaysOnTop = true
    RightMenuToggleHintGuiBack.Adornee = RightMenuToggleHintAdornPart
    RightMenuToggleHintGuiBack.Parent = RightMenuToggleHintAdornPart

    local RightMenuToggleHintBackArrow = Instance.new("ImageLabel")
    RightMenuToggleHintBackArrow.ImageTransparency = 1
    RightMenuToggleHintBackArrow.BackgroundTransparency = 1
    RightMenuToggleHintBackArrow.Size = UDim2.new(1,0,1,0)
    RightMenuToggleHintBackArrow.Image = "rbxassetid://6537091378"
    RightMenuToggleHintBackArrow.ImageRectSize = Vector2.new(512,512)
    RightMenuToggleHintBackArrow.ImageRectOffset = Vector2.new(0,0)
    RightMenuToggleHintBackArrow.Parent = RightMenuToggleHintGuiBack

    local RightMenuToggleHintBackText = Instance.new("ImageLabel")
    RightMenuToggleHintBackText.BackgroundTransparency = 1
    RightMenuToggleHintBackText.Rotation = 180
    RightMenuToggleHintBackText.ImageTransparency = 1
    RightMenuToggleHintBackText.Size = UDim2.new(1,0,1,0)
    RightMenuToggleHintBackText.ZIndex = 2
    RightMenuToggleHintBackText.Image = "rbxassetid://6537091378"
    RightMenuToggleHintBackText.ImageRectSize = Vector2.new(512,512)
    RightMenuToggleHintBackText.ImageRectOffset = Vector2.new(0,512)
    RightMenuToggleHintBackText.Parent = RightMenuToggleHintGuiBack

    --Connect hiding the hints when the setting changes.
    Settings:GetSettingsChangedSignal("Menu.MenuToggleGestureActive"):Connect(function()
        --Determine if the gesture is active.
        local MenuToggleGestureActive = Settings:GetSetting("Menu.MenuToggleGestureActive")
        if MenuToggleGestureActive == nil then
            MenuToggleGestureActive = true
        end

        --Update the visibility of the hints.
        LeftMenuToggleHintGuiFront.Enabled = MenuToggleGestureActive
        LeftMenuToggleHintGuiBack.Enabled = MenuToggleGestureActive
        RightMenuToggleHintGuiFront.Enabled = MenuToggleGestureActive
        RightMenuToggleHintGuiBack.Enabled = MenuToggleGestureActive
    end)


    --Start checking for the controllers to be upside down.
    --Done in a task since this function is non-yielding.
    local BothControllersUpStartTime
    local MenuToggleReached = false
    task.spawn(function()
        while true do
            --Determine if the gesture is active.
            local MenuToggleGestureActive = Settings:GetSetting("Menu.MenuToggleGestureActive")
            if MenuToggleGestureActive == nil then
                MenuToggleGestureActive = true
            end

            --Get the inputs and determine if the hands are both upside down and pointing forward.
            local VRInputs = VRInputService:GetVRInputs()
            local LeftHandCFrameRelative, RightHandCFrameRelative = VRInputs[Enum.UserCFrame.Head]:Inverse() * VRInputs[Enum.UserCFrame.LeftHand], VRInputs[Enum.UserCFrame.Head]:Inverse() * VRInputs[Enum.UserCFrame.RightHand]
            local LeftHandFacingUp, RightHandFacingUp = LeftHandCFrameRelative.UpVector.Y < 0, RightHandCFrameRelative.UpVector.Y < 0
            local LeftHandFacingForward, RightHandFacingForward = LeftHandCFrameRelative.LookVector.Z < 0, RightHandCFrameRelative.LookVector.Z < 0
            local LeftHandUp, RightHandUp = LeftHandFacingUp and LeftHandFacingForward, RightHandFacingUp and RightHandFacingForward
            local BothHandsUp = MenuToggleGestureActive and LeftHandUp and RightHandUp
            if BothHandsUp then
                BothControllersUpStartTime = BothControllersUpStartTime or tick()
            else
                BothControllersUpStartTime = nil :: any
                MenuToggleReached = false
            end

            --Update the adorn part CFrames.
            local CameraCenterCFrame = Workspace.CurrentCamera:GetRenderCFrame() * VRInputs[Enum.UserCFrame.Head]:Inverse()
            LeftAdornPart.CFrame = CameraCenterCFrame * VRInputs[Enum.UserCFrame.LeftHand] * CFrame.new(0, -0.25, 0.25)
            RightAdornPart.CFrame = CameraCenterCFrame * VRInputs[Enum.UserCFrame.RightHand] * CFrame.new(0, -0.25, 0.25)
            LeftMenuToggleHintAdornPart.CFrame = CameraCenterCFrame * VRInputs[Enum.UserCFrame.LeftHand]
            RightMenuToggleHintAdornPart.CFrame = CameraCenterCFrame * VRInputs[Enum.UserCFrame.RightHand]

            --Update the progress bars.
            if BothControllersUpStartTime and not MenuToggleReached then
                local DeltaTimePercent = (tick() - BothControllersUpStartTime) / MENU_OPEN_TIME_REQUIREMENT
                LeftAdorn.Size = Vector3.new(0.1, 0, 0.25 * DeltaTimePercent)
                RightAdorn.Size = Vector3.new(0.1, 0, 0.25 * DeltaTimePercent)
                LeftAdorn.Visible = true
                RightAdorn.Visible = true

                --Toggle the menu if the time threshold was reached.
                if DeltaTimePercent >= 1 then
                    MenuToggleReached = true
                    task.spawn(function()
                        self:Toggle()
                    end)
                end
            else
                LeftAdorn.Visible = false
                RightAdorn.Visible = false
            end

            --[[
            Updates the given hint parts.
            --]]
            local function UpdateHintParts(Visible,Part,FrontArrow,BackArrow,FrontText,BackText)
                local TweenData = TweenInfo.new(0.25)
                TweenService:Create(Part,TweenData,{
                    Size = Visible and Vector3.new(1, 1, 0) or Vector3.new(1.5, 1.5, 0)
                }):Play()
                TweenService:Create(FrontArrow,TweenData,{
                    ImageTransparency = Visible and 0 or 1
                }):Play()
                TweenService:Create(BackArrow,TweenData,{
                    ImageTransparency = Visible and 0 or 1
                }):Play()
                TweenService:Create(FrontText,TweenData,{
                    ImageTransparency = Visible and 0 or 1
                }):Play()
                TweenService:Create(BackText,TweenData,{
                    ImageTransparency = Visible and 0 or 1
                }):Play()
            end

            --Update the hints.
            local LeftHandHintVisible, RightHandHintVisible = self.ScreenGui.Enabled and not LeftHandUp, self.ScreenGui.Enabled and not RightHandUp
            if self.LeftHandHintVisible ~= LeftHandHintVisible then
                self.LeftHandHintVisible = LeftHandHintVisible
                UpdateHintParts(LeftHandHintVisible, LeftMenuToggleHintAdornPart, LeftMenuToggleHintFrontArrow, LeftMenuToggleHintBackArrow, LeftMenuToggleHintFrontText, LeftMenuToggleHintBackText)
            end
            if self.RightHandHintVisible ~= RightHandHintVisible then
                self.RightHandHintVisible = RightHandHintVisible
                UpdateHintParts(RightHandHintVisible, RightMenuToggleHintAdornPart, RightMenuToggleHintFrontArrow, RightMenuToggleHintBackArrow, RightMenuToggleHintFrontText, RightMenuToggleHintBackText)
            end
            local Rotation = (tick() * 10) % 360
            LeftMenuToggleHintFrontArrow.Rotation = Rotation
            LeftMenuToggleHintBackArrow.Rotation = -Rotation
            RightMenuToggleHintFrontArrow.Rotation = -Rotation
            RightMenuToggleHintBackArrow.Rotation = Rotation

            --Wait to poll again.
            RunService.RenderStepped:Wait()
        end
    end)
end

--[[
Toggles the menu being open.
--]]
function MainMenu.Toggle(self: MainMenu, Visible: boolean?): ()
    if self.ScreenGui.Enabled == Visible then return end

    --Determine the start and end values.
    local StartFieldOfView, EndFieldOfView = (self.ScreenGui.Enabled and math.rad(40) or 0), (self.ScreenGui.Enabled and 0 or math.rad(40))

    --Show the menu if it isn't visible.
    if not self.ScreenGui.Enabled then
        self.ScreenGui.Enabled = true
    end

    --Tween the field of view.
    local StartTime = tick()
    while tick() - StartTime < MENU_OPEN_TIME do
        local Delta = (tick() - StartTime) / MENU_OPEN_TIME
        Delta = (math.sin((Delta - 0.5) * math.pi) / 2) + 0.5
        self.ScreenGui.FieldOfView = StartFieldOfView + ((EndFieldOfView - StartFieldOfView) * Delta)
        RunService.RenderStepped:Wait()
    end

    --Hide thhe menu if it is closed.
    if EndFieldOfView == 0 then
        self.ScreenGui.Enabled = false
    end
end

--[[
Registers a view.
--]]
function MainMenu.RegisterView(self: MainMenu, ViewName: string, ViewInstance: any): ()
    warn("MainMenu::RegisterView is deprecated and may be removed in the future. Use MainMenu::CreateView instead.")

    --Set up the view instance.
    ViewInstance.Visible = false
    ViewInstance.Name = ViewName
    ViewInstance.Parent = self.ViewAdornFrame

    --Store the view.
    table.insert(self.Views, ViewInstance)
end

--[[
Creates a menu view.
--]]
function MainMenu.CreateView(self: MainMenu, InitialViewName: string): any
    --Create and store the view.
    local View = ApiBaseView.new(InitialViewName)
    View.Frame.Parent = (self :: any).ViewAdornFrame
    table.insert(self.Views, View)

    --Connect the events.
    View:GetPropertyChangedSignal("Name"):Connect(function()
        self:UpdateVisibleView()
    end)
    View.Destroyed:Connect(function()
        for i = 1, #self.Views do
            if self.Views[i] == View then
                table.remove(self.Views, i)
                if self.CurrentView > i then
                    self.CurrentView += -1
                end
                break
            end
        end
        self:UpdateVisibleView()
    end)
    return View
end

--[[
Updates the visible view.
--]]
function MainMenu.UpdateVisibleView(self: MainMenu, NewView: string?): ()
    --Update the button visibility.
    self.LeftButton.Visible = (#self.Views > 1)
    self.RightButton.Visible = (#self.Views > 1)

    --Update the display text.
    if NewView then
        for i, View in self.Views do
            if View.Name ~= NewView then continue end
            self.CurrentView = i
            break
        end
    end
    self.ViewTextLabel.Text = self.Views[self.CurrentView].Name

    --Update the view visibilites.
    for i, View in self.Views do
        View.Visible = (i == self.CurrentView)
    end
end



return MainMenu]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD7FF2DBE6D294BCEB5536D2DE5009CAA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">R6Message</string>
						<string name="ScriptGuid">{4135DD95-9CC8-4D33-95E2-E42C8018BA10}</string>
						<ProtectedString name="Source"><![CDATA[--Displays a message if R6 is used.
--!strict

local MESSAGE_OPEN_TIME = 0.25

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local NexusVRCharacterModel = script.Parent.Parent
local ScreenGui3D = require(NexusVRCharacterModel:WaitForChild("NexusVRCore"):WaitForChild("Container"):WaitForChild("ScreenGui3D"))
local TextButtonFactory = require(NexusVRCharacterModel:WaitForChild("NexusButton"):WaitForChild("Factory"):WaitForChild("TextButtonFactory")).CreateDefault(Color3.fromRGB(0, 170, 255))
TextButtonFactory:SetDefault("Theme", "RoundedCorners")

local R6Message = {}
R6Message.__index = R6Message

export type R6Message = {
    ScreenGui: any,
} & typeof(setmetatable({}, R6Message))



--[[
Creates the R6 message.
--]]
function R6Message.new(): R6Message
    --Set up the ScreenGui.
    local MessageScreenGui = ScreenGui3D.new()
    MessageScreenGui.ResetOnSpawn = false
    MessageScreenGui.Enabled = false
    MessageScreenGui.CanvasSize = Vector2.new(500, 500)
    MessageScreenGui.FieldOfView = 0
    MessageScreenGui.Easing = 0.25

    --Create the object.
    local self = setmetatable({
        ScreenGui = MessageScreenGui,
    }, R6Message) :: R6Message

    --Create the logo and message.
    local Logo = Instance.new("ImageLabel")
    Logo.BackgroundTransparency = 1
    Logo.Size = UDim2.new(0.4, 0, 0.4, 0)
    Logo.Position = UDim2.new(0.3, 0, -0.1, 0)
    Logo.Image = "http://www.roblox.com/asset/?id=1499731139"
    Logo.Parent = MessageScreenGui:GetContainer()

    local UpperText = Instance.new("TextLabel")
    UpperText.BackgroundTransparency = 1
    UpperText.Size = UDim2.new(0.8, 0, 0.1, 0)
    UpperText.Position = UDim2.new(0.1, 0, 0.25, 0)
    UpperText.Font = Enum.Font.SourceSansBold
    UpperText.Text = "R6 Not Supported"
    UpperText.TextScaled = true
    UpperText.TextColor3 = Color3.fromRGB(255, 255, 255)
    UpperText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    UpperText.TextStrokeTransparency = 0
    UpperText.Parent = MessageScreenGui:GetContainer()

    local LowerText = Instance.new("TextLabel")
    LowerText.BackgroundTransparency = 1
    LowerText.Size = UDim2.new(0.8, 0, 0.25, 0)
    LowerText.Position = UDim2.new(0.1, 0, 0.4, 0)
    LowerText.Font = Enum.Font.SourceSansBold
    LowerText.Text = "Nexus VR Character Model does not support using R6. Use R15 instead."
    LowerText.TextScaled = true
    LowerText.TextColor3 = Color3.fromRGB(255, 255, 255)
    LowerText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    LowerText.TextStrokeTransparency = 0
    LowerText.Parent = MessageScreenGui:GetContainer()

    --Create and connect the close button.
    local CloseButton, CloseText = TextButtonFactory:Create()
    CloseButton.Size = UDim2.new(0.3, 0, 0.1, 0)
    CloseButton.Position = UDim2.new(0.35, 0, 0.7, 0)
    CloseButton.Parent = MessageScreenGui:GetContainer()
    CloseText.Text = "Ok"

    CloseButton.MouseButton1Down:Connect(function()
        self:SetOpen(false)
        MessageScreenGui:Destroy()
    end)

    --Parent the message.
    MessageScreenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    return self
end

--[[
Sets the window open or closed.
--]]
function R6Message.SetOpen(self: R6Message, Open: boolean): ()
    --Determine the start and end values.
    local StartFieldOfView, EndFieldOfView = (Open and 0 or math.rad(40)), (Open and math.rad(40) or 0)

    --Show the message if it isn't visible.
    if Open then
        self.ScreenGui.Enabled = true
    end

    --Tween the field of view.
    local StartTime = tick()
    while tick() - StartTime < MESSAGE_OPEN_TIME do
        local Delta = (tick() - StartTime) / MESSAGE_OPEN_TIME
        Delta = (math.sin((Delta - 0.5) * math.pi) / 2) + 0.5
        self.ScreenGui.FieldOfView = StartFieldOfView + ((EndFieldOfView - StartFieldOfView) * Delta)
        RunService.RenderStepped:Wait()
    end

    --Hide thhe message if it is closed.
    if EndFieldOfView == 0 then
        self.ScreenGui.Enabled = false
    end
end

--[[
Opens the message.
--]]
function R6Message.Open(self: R6Message): ()
    self:SetOpen(true)
end



return R6Message]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX5DAFB6D541F044FFBB8E19EB17E81D8A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">View</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX24B60B58ED7E40A88BAF1E853A42D1DA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ApiBaseView</string>
							<string name="ScriptGuid">{81005ADE-AACD-4D32-B58A-EEEDCF03A36A}</string>
							<ProtectedString name="Source"><![CDATA[--Base view for the menu intended to be used with the API.
--!strict

local GuiService = game:GetService("GuiService")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local NexusInstance = require(NexusVRCharacterModel:WaitForChild("NexusInstance"))
local TypedEvent = require(NexusVRCharacterModel:WaitForChild("NexusInstance"):WaitForChild("Event"):WaitForChild("TypedEvent"))

local ApiBaseView = {}
ApiBaseView.__index = ApiBaseView

export type ApiBaseView = {
    Name: string,
    Visible: boolean,
    Destroyed: TypedEvent.TypedEvent<>,
    Frame: Frame,
} & typeof(setmetatable({}, ApiBaseView))
export type NexusInstanceApiBaseView = NexusInstance.NexusInstance<ApiBaseView>



--[[
Creates the view.
--]]
function ApiBaseView.__new(self: NexusInstanceApiBaseView, InitialName: string): ()
    self.Name = InitialName
    self.Destroyed = self:CreateEvent()

    self.Frame = Instance.new("Frame")
    self.Frame.Name = tostring(self.Name)
    self.Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    self.Frame.BackgroundTransparency = 1
    self.Frame.Size = UDim2.new(1, 0, 1, 0)
    self.Frame.Visible = false
    self.Frame.SizeConstraint = Enum.SizeConstraint.RelativeXX
    self:GetPropertyChangedSignal("Name"):Connect(function()
        self.Frame.Name = tostring(self.Name)
    end)
    self:GetPropertyChangedSignal("Visible"):Connect(function()
        self.Frame.Visible = self.Visible
    end)
end

--[[
Returns the containing frame.
--]]
function ApiBaseView.GetContainer(self: NexusInstanceApiBaseView): Frame
    return self.Frame
end

--[[
Adds the background of the frame.
--]]
function ApiBaseView.AddBackground(self: NexusInstanceApiBaseView): ()
    --Add the corner.
    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0.05, 0)
    UICorner.Parent = self.Frame

    --Enable the transparency.
    self.Frame.BackgroundTransparency = 0.6 * GuiService.PreferredTransparency
    GuiService:GetPropertyChangedSignal("PreferredTransparency"):Connect(function()
        self.Frame.BackgroundTransparency = 0.6 * GuiService.PreferredTransparency
    end)
end

--[[
Destroys the view.
--]]
function ApiBaseView.Destroy(self: NexusInstanceApiBaseView): ()
    self.Destroyed:Fire()
    self.Frame:Destroy()
end



return NexusInstance.ToInstance(ApiBaseView) :: NexusInstance.NexusInstanceClass<typeof(ApiBaseView), (InitialName: string) -> (NexusInstanceApiBaseView)>]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXE55396CCE7BC4147B8DC964F9734B512">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">EnigmaView</string>
							<string name="ScriptGuid">{50BA21FF-31A8-4492-8929-78E9513C3BEB}</string>
							<ProtectedString name="Source"><![CDATA[--View for the Enigma library.
--!strict

local SUPPORTED_PROTOCOL_VERSIONS = {
    ["1"] = true,
    ["2"] = true,
}

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VRService = game:GetService("VRService")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local Enigma = require(NexusVRCharacterModel:WaitForChild("Enigma"))
local NexusButton = require(NexusVRCharacterModel:WaitForChild("NexusButton"))
local EnigmaTrackerRoles = require(NexusVRCharacterModel:WaitForChild("Enigma"):WaitForChild("Data"):WaitForChild("TrackerRole"))
local CharacterService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CharacterService")).GetInstance()
local EnigmaService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("EnigmaService")).GetInstance()
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local BaseApiView = require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("View"):WaitForChild("ApiBaseView"))

local TextButtonFactory = require(NexusVRCharacterModel:WaitForChild("NexusButton"):WaitForChild("Factory"):WaitForChild("TextButtonFactory")).CreateDefault(Color3.fromRGB(0, 170, 255))
TextButtonFactory:SetDefault("Theme", "RoundedCorners")

local EnigmaView = {}
EnigmaView.__index = EnigmaView

export type EnigmaView = {
    EnigmaText: TextLabel,
    ShowTrackersButton: NexusButton.NexusInstanceNexusButton?,
    DebugTrackersVisible: boolean?,
    CalibrateButton: NexusButton.NexusInstanceNexusButton?,
} & typeof(setmetatable({}, EnigmaView))



--[[
Returns text with rich text color.
--]]
local function AddColor(Text: string, R: number, G: number, B: number): string
    return `<font color="rgb({R},{G},{B})">{Text}</font>`
end

--[[
Creates the Enigma view.
--]]
function EnigmaView.new(View: BaseApiView.NexusInstanceApiBaseView, Menu: any): EnigmaView
    View:AddBackground()

    --Create the view.
    local Container = View:GetContainer()
    local EnigmaText = Instance.new("TextLabel")
    EnigmaText.BackgroundTransparency = 1
    EnigmaText.Size = UDim2.new(0.9, 0, 0.6, 0)
    EnigmaText.Position = UDim2.new(0.05, 0, 0.075, 0)
    EnigmaText.Font = Enum.Font.SourceSansBold
    EnigmaText.Text = ""
    EnigmaText.RichText = true
    EnigmaText.TextWrapped = true
    EnigmaText.TextColor3 = Color3.fromRGB(255, 255, 255)
    EnigmaText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    EnigmaText.TextStrokeTransparency = 0
    EnigmaText.TextSize = 28
    EnigmaText.TextYAlignment = Enum.TextYAlignment.Top
    EnigmaText.Parent = Container

    --Create the object.
    local self = setmetatable({
        EnigmaText = EnigmaText,
    }, EnigmaView) :: EnigmaView

    --Return the object early if Enigma is not enabled.
    if Settings:GetSetting("Extra.EnigmaEnabled") == false then
        EnigmaText.Text = "This game has disabled Enigma."
        return self
    end

    local ShowTrackersButton, ShowTrackersText = TextButtonFactory:Create()
    ShowTrackersButton.Size = UDim2.new(0.5, 0, 0.075, 0)
    ShowTrackersButton.Position = UDim2.new(0.25, 0, 0.775, 0)
    ShowTrackersButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
    ShowTrackersButton.Parent = Container
    ShowTrackersText.Text = " Show Trackers "
    self.ShowTrackersButton = ShowTrackersButton

    self.DebugTrackersVisible = false
    local DB = true
    ShowTrackersButton.MouseButton1Down:Connect(function()
        if not DB then return end
        DB = false
        self.DebugTrackersVisible = not self.DebugTrackersVisible
        if self.DebugTrackersVisible then
            task.spawn(function()
                self:ShowDebugTrackers()
            end)
        end
        ShowTrackersText.Text = (self.DebugTrackersVisible and " Hide Trackers" or " Show Trackers ")
        task.wait()
        DB = true
    end)

    local CalibrateButton, CalibrateText = TextButtonFactory:Create()
    CalibrateButton.Size = UDim2.new(0.5, 0, 0.075, 0)
    CalibrateButton.Position = UDim2.new(0.25, 0, 0.875, 0)
    CalibrateButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
    CalibrateButton.Parent = Container
    CalibrateText.Text = " Calibrate Trackers "
    self.CalibrateButton = CalibrateButton

    CalibrateButton.MouseButton1Down:Connect(function()
        if not DB then return end
        DB = false
        local Character = CharacterService:GetCharacter(Players.LocalPlayer)
        if Character then
            EnigmaService:Calibrate(Character)
        end
        task.wait()
        DB = true
    end)

    --Update the text in the background.
    self:UpdateText()
    task.spawn(function()
        while true do
            self:UpdateText()
            task.wait(0.1)
        end
    end)

    --Present the view if an uncalibratedd input becomes visible.
    task.spawn(function()
        local UncalibratedInputsPrompted = {
            LeftFoot = false,
            RightFoot = false,
        }
        while true do
            --Determine if there are unprompted inputs.
            local AllInputsCalibrated = true
            local InputsToPrompt = {}
            for InputName, Prompted in UncalibratedInputsPrompted do
                if Prompted then continue end
                if not Prompted then
                    AllInputsCalibrated = false
                end
                if not Enigma.Enabled or not Enigma:GetUserCFrameEnabled(InputName :: any) then continue end
                if EnigmaService.Offsets[InputName] then continue end
                table.insert(InputsToPrompt, InputName)
            end
            for _, InputName in InputsToPrompt do
                UncalibratedInputsPrompted[InputName] = true
            end

            --Show the view.
            if #InputsToPrompt > 0 then
                Menu:UpdateVisibleView(View.Name)
                Menu:Toggle(true)
                self:UpdateText()
            end

            --Break the loop if all inputs are prompted.
            if AllInputsCalibrated then break end
            task.wait()
        end
    end)

    --Return the object.
    return self
end

--[[
Updates the Enigma text.
--]]
function EnigmaView.UpdateText(self: EnigmaView): ()
    --Add the tracker information.
    local Text = ""
    local HasLeftFoot, HasRightFoot = Enigma.Enabled and Enigma:GetUserCFrameEnabled("LeftFoot"), Enigma.Enabled and Enigma:GetUserCFrameEnabled("RightFoot")
    if HasLeftFoot then
        if EnigmaService.Offsets.LeftFoot then
            Text = `{Text}Left Foot Tracker: {AddColor("Active", 0, 200, 0)}`
        else
            Text = `{Text}Left Foot Tracker: {AddColor("Requires Calibration", 200, 150, 0)}`
        end
    else
        Text = `{Text}Left Foot Tracker: {AddColor("Inactive", 200, 0, 0)}`
    end
    if HasRightFoot then
        if EnigmaService.Offsets.RightFoot then
            Text = `{Text}\nRight Foot Tracker: {AddColor("Active", 0, 200, 0)}`
        else
            Text = `{Text}\nRight Foot Tracker: {AddColor("Requires Calibration", 200, 150, 0)}`
        end
    else
        Text = `{Text}\nRight Foot Tracker: {AddColor("Inactive", 200, 0, 0)}`
    end

    --Add the data transfer status.
    if Enigma:IsActive() then
        local FocusedTextBox = UserInputService:GetFocusedTextBox()
        if not FocusedTextBox or (FocusedTextBox.Parent and FocusedTextBox.Parent.Name == "EnigmaTextBoxInput") then
            Text = `{Text}\nData transfer: {AddColor("Active", 0, 200, 0)}`
            if Enigma.Input then
                local EnigmaVersion = string.split(Enigma.Input:GetCurrentText(), "|")[1]
                if SUPPORTED_PROTOCOL_VERSIONS[EnigmaVersion] then
                    Text = `{Text}\n\nProtocol version: {EnigmaVersion}`
                else
                    Text = `{Text}\n\nProtocol version: {AddColor(`{EnigmaVersion} (Unsupported)`, 200, 150, 0)}`
                end
            end
        else
            Text = `{Text}\nData transfer: {AddColor("Inactive", 200, 0, 0)}`
        end
        if not HasLeftFoot and not HasRightFoot and Enigma:GetUserCFrameEnabled("None") then
            Text = `{Text}\n\n Trackers are detected, but the role in SteamVR is "None". They need to have assigned roles through the SteamVR menu.`
        else
            Text = `{Text}\n\nTo calibrate, stand up straight with your head level and facing forward with your feet next to each other pointing forward.`
        end
        if self.ShowTrackersButton then
            self.ShowTrackersButton.Visible = true
        end
        if self.CalibrateButton then
            self.CalibrateButton.Visible = true
        end
    else
        Text = `{Text}\nData transfer: {AddColor("Inactive", 200, 150, 0)}`
        Text = `{Text}\n\n Enigma requires a desktop application. There may be experience-specific issues when Enigma is active.`
        if self.ShowTrackersButton then
            self.ShowTrackersButton.Visible = false
        end
        if self.CalibrateButton then
            self.CalibrateButton.Visible = false
        end
    end

    --Set the text.
    self.EnigmaText.Text = Text
end

--[[
Shows debug trackers.
--]]
function EnigmaView.ShowDebugTrackers(self: EnigmaView): ()
    if not Enigma.Enabled then return end
    local TrackerParts, TrackerLabels = {}, {}
    local TrackersPartsFolder = Instance.new("Folder")
    TrackersPartsFolder.Name = "NexusVRCharacterModelEnigmaDebugTrackers"
    TrackersPartsFolder.Parent = Workspace.CurrentCamera

    while self.DebugTrackersVisible do
        --Get the visible trackers.
        local ActiveInputs = {}
        local TotalInputs = 0
        local OriginWorldCFrame = Workspace.CurrentCamera:GetRenderCFrame() * VRService:GetUserCFrame(Enum.UserCFrame.Head):Inverse()
        for _, UserCFrameName: EnigmaTrackerRoles.TrackerRole in EnigmaTrackerRoles do
            local TrackerIndex = 1
            while Enigma:GetUserCFrameEnabled(UserCFrameName, TrackerIndex) do
                local DisplayUserCFrame = (TrackerIndex == 1 and UserCFrameName or `{UserCFrameName} ({TrackerIndex})`)
                ActiveInputs[DisplayUserCFrame] = OriginWorldCFrame * Enigma:GetUserCFrame(UserCFrameName, TrackerIndex)
                TotalInputs += 1
                TrackerIndex += 1
            end
        end

        --Update the debug trackers.
        local CurrentInput = 1
        for InputName, InputCFrame in ActiveInputs do
            if not TrackerParts[CurrentInput] then
                local TrackerPart = Instance.new("Part")
                TrackerPart.BrickColor = BrickColor.new("Institutional white")
                TrackerPart.Material = Enum.Material.Neon
                TrackerPart.Anchored = true
                TrackerPart.CanCollide = false
                TrackerPart.CanTouch = false
                TrackerPart.CanQuery = false
                TrackerPart.Shape = Enum.PartType.Ball
                TrackerPart.Size = Vector3.new(0.2, 0.2, 0.2)
                TrackerPart.Parent = TrackersPartsFolder
                TrackerParts[CurrentInput] = TrackerPart

                local SphereHandleAdornment = Instance.new("SphereHandleAdornment")
                SphereHandleAdornment.Transparency = 0.5
                SphereHandleAdornment.AlwaysOnTop = true
                SphereHandleAdornment.Color3 = Color3.fromRGB(255, 255, 255)
                SphereHandleAdornment.ZIndex = 1
                SphereHandleAdornment.Radius = 0.1
                SphereHandleAdornment.Adornee = TrackerPart
                SphereHandleAdornment.Parent = TrackerPart

                local BillboardGui = Instance.new("BillboardGui")
                BillboardGui.AlwaysOnTop = true
                BillboardGui.Adornee = TrackerPart
                BillboardGui.Size = UDim2.new(2, 0, 0.4, 0)
                BillboardGui.StudsOffset = Vector3.new(0, 0.3 ,0)
                BillboardGui.Parent = TrackerPart

                local TrackerRoleText = Instance.new("TextLabel")
                TrackerRoleText.BackgroundTransparency = 1
                TrackerRoleText.Size = UDim2.new(1, 0, 1, 0)
                TrackerRoleText.TextScaled = true
                TrackerRoleText.TextColor3 = Color3.fromRGB(255, 255, 255)
                TrackerRoleText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
                TrackerRoleText.TextStrokeTransparency = 0
                TrackerRoleText.Parent = BillboardGui
                TrackerLabels[CurrentInput] = TrackerRoleText
            end
            TrackerParts[CurrentInput].CFrame = InputCFrame
            TrackerLabels[CurrentInput].Text = InputName
            CurrentInput += 1
        end

        --Remove extra trackers.
        for i = #TrackerParts, TotalInputs + 1, -1 do
            TrackerParts[i]:Destroy()
            TrackerParts[i] = nil
            TrackerLabels[i]:Destroy()
            TrackerLabels[i] = nil
        end

        --Wait to refresh.
        RunService.RenderStepped:Wait()
    end

    --Clear the instances.
    TrackersPartsFolder:Destroy()
end



return EnigmaView]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX02BDC69EF3524C5A996145A2F19DC86D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">SettingsView</string>
							<string name="ScriptGuid">{D23C056D-EC45-418F-8EDF-2E4F6516503C}</string>
							<ProtectedString name="Source"><![CDATA[--View for the user settings.
--!strict

local UserInputService = game:GetService("UserInputService")
local VRService = game:GetService("VRService")

local NexusVRCharacterModel = script.Parent.Parent.Parent
local CameraService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("CameraService")).GetInstance()
local ControlService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("ControlService")).GetInstance()
local DefaultCursorService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("DefaultCursorService")).GetInstance()
local Settings = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("Settings")).GetInstance()
local VRInputService = require(NexusVRCharacterModel:WaitForChild("State"):WaitForChild("VRInputService")).GetInstance()
local BaseApiView = require(NexusVRCharacterModel:WaitForChild("UI"):WaitForChild("View"):WaitForChild("ApiBaseView"))

local TextButtonFactory = require(NexusVRCharacterModel:WaitForChild("NexusButton"):WaitForChild("Factory"):WaitForChild("TextButtonFactory")).CreateDefault(Color3.fromRGB(0, 170, 255))
TextButtonFactory:SetDefault("Theme", "RoundedCorners")

local SettingsView = {}
SettingsView.__index = SettingsView

export type SettingsView = {

} & typeof(setmetatable({}, SettingsView))



--[[
Creates the settings view.
--]]
function SettingsView.new(View: BaseApiView.NexusInstanceApiBaseView): ()
    View:AddBackground()

    --Create the object.
    local self = setmetatable({}, SettingsView) :: SettingsView

    --Create the header.
    local Container = View:GetContainer()
    local HeaderLogo = Instance.new("ImageLabel")
    HeaderLogo.BackgroundTransparency = 1
    HeaderLogo.Size = UDim2.new(0.4, 0, 0.4, 0)
    HeaderLogo.Position = UDim2.new(0.3, 0, -0.075, 0)
    HeaderLogo.Image = "http://www.roblox.com/asset/?id=1499731139"
    HeaderLogo.Parent = Container

    local NameText = Instance.new("TextLabel")
    NameText.BackgroundTransparency = 1
    NameText.Size = UDim2.new(0.8, 0, 0.1, 0)
    NameText.Position = UDim2.new(0.1, 0, 0.225, 0)
    NameText.Font = Enum.Font.SourceSansBold
    NameText.Text = "Nexus VR Character Model"
    NameText.TextScaled = true
    NameText.TextColor3 = Color3.fromRGB(255, 255, 255)
    NameText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    NameText.TextStrokeTransparency = 0
    NameText.Parent = Container

    --Create the settings.
    local CameraSettingFrame = Instance.new("Frame")
    CameraSettingFrame.BackgroundTransparency = 1
    CameraSettingFrame.Size = UDim2.new(0.8, 0,0.11, 0)
    CameraSettingFrame.Position = UDim2.new(0.1, 0, 0.325, 0)
    CameraSettingFrame.Parent = Container
    self:PopulateSettingsFrame(CameraSettingFrame, "View", function()
        if VRService.AvatarGestures then
            return {"Default"} --TODO: Third-person camera setting is not supported with AvatarGestures.
        end
        return Settings:GetSetting("Camera.EnabledCameraOptions") or {}
    end, function()
        return CameraService.ActiveCamera
    end, function(NewValue)
        CameraService:SetActiveCamera(NewValue)
    end)

    local MovementSettingFrame = Instance.new("Frame")
    MovementSettingFrame.BackgroundTransparency = 1
    MovementSettingFrame.Size = UDim2.new(0.8, 0, 0.11, 0)
    MovementSettingFrame.Position = UDim2.new(0.1, 0, 0.325 + (0.15 * 1), 0)
    MovementSettingFrame.Parent = Container
    self:PopulateSettingsFrame(MovementSettingFrame, "Control", "Movement.EnabledMovementMethods", function()
        return ControlService.ActiveController
    end, function(NewValue)
        ControlService:SetActiveController(NewValue)
    end)

    local CursorSettingFrame = Instance.new("Frame")
    CursorSettingFrame.BackgroundTransparency = 1
    CursorSettingFrame.Size = UDim2.new(0.8, 0, 0.11, 0)
    CursorSettingFrame.Position = UDim2.new(0.1, 0, 0.325 + (0.15 * 2), 0)
    CursorSettingFrame.Parent = Container
    self:PopulateSettingsFrame(CursorSettingFrame, "Roblox VR Cursor", function()
        return DefaultCursorService.CursorOptionsList
    end, function()
        return DefaultCursorService.CurrentCursorState
    end, function(NewValue)
        DefaultCursorService:SetCursorState(NewValue)
    end)

    --Create the callibration settings.
    local RecenterButton, RecenterText = TextButtonFactory:Create()
    RecenterButton.Size = UDim2.new(0.4, 0, 0.075, 0)
    RecenterButton.Position = UDim2.new((VRService.AvatarGestures and 0.3 or 0.075), 0, 0.85, 0)
    RecenterButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
    RecenterButton.Parent = Container
    RecenterText.Text = "Recenter"

    RecenterButton.MouseButton1Down:Connect(function()
        if not VRService.AvatarGestures then
            VRInputService:Recenter()
        else
            UserInputService:RecenterUserHeadCFrame()
        end
    end)

    if not VRService.AvatarGestures then
        local SetEyeLevelButton, SetEyeLevelText = TextButtonFactory:Create()
        SetEyeLevelButton.Size = UDim2.new(0.4, 0, 0.075, 0)
        SetEyeLevelButton.Position = UDim2.new(0.525, 0, 0.85, 0)
        SetEyeLevelButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
        SetEyeLevelButton.Parent = Container
        SetEyeLevelText.Text = " Set Eye Level "

        SetEyeLevelButton.MouseButton1Down:Connect(function()
            VRInputService:SetEyeLevel()
        end)
    end

    --Create the version information.
    local VersionText = Instance.new("TextLabel")
    VersionText.BackgroundTransparency = 1
    VersionText.AnchorPoint = Vector2.new(0.5, 1)
    VersionText.Size = UDim2.new(0.8, 0, 0.04, 0)
    VersionText.Position = UDim2.new(0.5, 0, 1, 0)
    VersionText.Font = Enum.Font.SourceSansBold
    VersionText.Text = `Version {Settings:GetSetting("Version.Tag")} ({Settings:GetSetting("Version.Commit")})`
    VersionText.TextScaled = true
    VersionText.TextColor3 = Color3.fromRGB(255, 255, 255)
    VersionText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    VersionText.TextStrokeTransparency = 0
    VersionText.Parent = Container

    --Return the object.
    return SettingsView
end

--[[
Popuulates a setting frame.
--]]
function SettingsView.PopulateSettingsFrame(self: SettingsView, ContainerFrame: Frame, HeaderName: string, GetOptionsSettings: string | () -> ({string}), GetValueFunction: () -> (string), SetValueFunction: (string) -> ()?): ()
    --Converrt the GetOptionsSettings callback if it is a string.
    local OptionsSetting = nil
    if typeof(GetOptionsSettings) == "string" then
        OptionsSetting = GetOptionsSettings
        GetOptionsSettings = function()
            return Settings:GetSetting(OptionsSetting) or {}
        end
    end

    --Create the frames.
    local LeftButton,LeftText = TextButtonFactory:Create()
    LeftButton.Size = UDim2.new(1, 0, 1, 0)
    LeftButton.Position = UDim2.new(0, 0, 0, 0)
    LeftButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
    LeftButton.Parent = ContainerFrame
    LeftText.Text = "<"

    local RightButton,RightText = TextButtonFactory:Create()
    RightButton.AnchorPoint = Vector2.new(1, 0)
    RightButton.Size = UDim2.new(1, 0, 1, 0)
    RightButton.Position = UDim2.new(1, 0, 0, 0)
    RightButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
    RightButton.Parent = ContainerFrame
    RightText.Text = ">"

    local OptionHeaderText = Instance.new("TextLabel")
    OptionHeaderText.BackgroundTransparency = 1
    OptionHeaderText.Size = UDim2.new(0.8, 0, 0.5, 0)
    OptionHeaderText.Position = UDim2.new(0.1, 0, -0.0125, 0)
    OptionHeaderText.Font = Enum.Font.SourceSansBold
    OptionHeaderText.Text = HeaderName
    OptionHeaderText.TextScaled = true
    OptionHeaderText.TextColor3 = Color3.fromRGB(255, 255, 255)
    OptionHeaderText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    OptionHeaderText.TextStrokeTransparency = 0
    OptionHeaderText.Parent = ContainerFrame

    local OptionText = Instance.new("TextLabel")
    OptionText.BackgroundTransparency = 1
    OptionText.Size = UDim2.new(0.6, 0, 0.7, 0)
    OptionText.Position = UDim2.new(0.2, 0, 0.3, 0)
    OptionText.Font = Enum.Font.SourceSansBold
    OptionText.TextScaled = true
    OptionText.TextColor3 = Color3.fromRGB(255, 255, 255)
    OptionText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    OptionText.TextStrokeTransparency = 0
    OptionText.Parent = ContainerFrame

    --[[
    Updates the settings.
    --]]
    local function UpdateSettings(Increment: number?): ()
        --Get the current value id.
        local InitialValueName = GetValueFunction()
        local CurrentValue = 1
        local Options = (GetOptionsSettings :: () -> ({string}))()
        for i,Option in Options do
            if Option == InitialValueName then
                CurrentValue = i
                break
            end
        end

        --Increment the value.
        if Increment and Increment ~= 0 then
            CurrentValue = CurrentValue + Increment
            if CurrentValue <= 0 then
                CurrentValue = #Options
            end
            if CurrentValue > #Options then
                CurrentValue = 1
            end
        end

        --Update the button visibility.
        LeftButton.Visible = (#Options > 1)
        RightButton.Visible = (#Options > 1)

        --Update the display text.
        OptionText.Text = Options[CurrentValue] or "(N/A)"

        --Set the new value.
        if Increment and Increment ~= 0 and Options[CurrentValue] then
            (SetValueFunction :: (string) -> ())(Options[CurrentValue])
        end
    end

    --Connect the events.
    local DB = true
    if OptionsSetting then
        Settings:GetSettingsChangedSignal(OptionsSetting):Connect(UpdateSettings)
    end
    LeftButton.MouseButton1Down:Connect(function()
        if not DB then return end
        DB = false
        UpdateSettings(-1)
        task.wait()
        DB = true
    end)
    RightButton.MouseButton1Down:Connect(function()
        if not DB then return end
        DB = false
        UpdateSettings(1)
        task.wait()
        DB = true
    end)

    --Update the initial settings.
    UpdateSettings()
end



return SettingsView]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX0A671F9C953846A8AB0456F3C4F52290">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Util</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXEA5841ECB6AA4AC682379D1FE6D51D19">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">BufferProtocol</string>
						<string name="ScriptGuid">{961A8B0A-ACEB-4C4C-8298-895069381983}</string>
						<ProtectedString name="Source"><![CDATA[--Serializes and deserializes buffers for Nexus Buffered Replication.
--!strict

local BUFFER_PROTOCOL_FIELDS = {
    --Normal.
    {
        Name = "UpdateTime",
        Type = "number",
    },
    {
        Name = "CurrentWalkspeed",
        Type = "number",
    },
    {
        Name = "HeadCFrame",
        Type = "CFrame",
    },
    {
        Name = "LeftHandCFrame",
        Type = "CFrame",
    },
    {
        Name = "RightHandCFrame",
        Type = "CFrame",
    },

    --Enigma.
    {
        Name = "LeftFootCFrame",
        Type = "CFrame",
    },
    {
        Name = "RightFootCFrame",
        Type = "CFrame",
    },
}
local FIELD_TYPE_TO_LENGTH = {
    ["number"] = 8,
    ["CFrame"] = 7 * 4,
}

local BufferProtocol = {}

export type BufferProtocolData = {
    --Normal.
    UpdateTime: number,
    CurrentWalkspeed: number?,
    HeadCFrame: CFrame,
    LeftHandCFrame: CFrame?,
    RightHandCFrame: CFrame?,
    
    --Enigma.
    LeftFootCFrame: CFrame?,
    RightFootCFrame: CFrame?,
}



--[[
Serializes a request to a buffer.
--]]
function BufferProtocol.Serialize(Data: BufferProtocolData): buffer
    --Determine the fields to write.
    local FieldsToSerialize = {}
    local SerializedLength = 1
    for i, FieldData in BUFFER_PROTOCOL_FIELDS do
        local FieldValue = Data[FieldData.Name]
        if not FieldValue or typeof(FieldValue) ~= FieldData.Type then continue end
        local FieldLength = FIELD_TYPE_TO_LENGTH[FieldData.Type]
        SerializedLength += 1 + FIELD_TYPE_TO_LENGTH[FieldData.Type]
        table.insert(FieldsToSerialize, {
            Index = i,
            Length = FieldLength,
            Data = FieldValue,
        })
    end

    --Write the fields.
    local Buffer = buffer.create(SerializedLength)
    local Offset = 1
    buffer.writei8(Buffer, 0, #FieldsToSerialize)
    for _, Field in FieldsToSerialize do
        --Write the field type.
        buffer.writei8(Buffer, Offset, Field.Index)
        Offset += 1

        --Write the field data.
        local FieldValue = Field.Data
        local FieldType = typeof(FieldValue)
        if FieldType == "number" then
            buffer.writef64(Buffer, Offset, FieldValue)
        elseif FieldType == "CFrame" then
            local Position = FieldValue.Position
            local AxisAngleVector3, AxisAngleRotation = FieldValue:ToAxisAngle()
            buffer.writef32(Buffer, Offset, Position.X)
            buffer.writef32(Buffer, Offset + 4, Position.Y)
            buffer.writef32(Buffer, Offset + 8, Position.Z)
            buffer.writef32(Buffer, Offset + 12, AxisAngleVector3.X)
            buffer.writef32(Buffer, Offset + 16, AxisAngleVector3.Y)
            buffer.writef32(Buffer, Offset + 20, AxisAngleVector3.Z)
            buffer.writef32(Buffer, Offset + 24, AxisAngleRotation)
        end
        Offset += Field.Length
    end
    return Buffer
end

--[[
Deserializes a section of a buffer.
--]]
function BufferProtocol.DeserializeSection(Buffer: buffer, StartOffset: number): (BufferProtocolData, number)
    local Data = {} :: BufferProtocolData
    local InitialOffset = StartOffset
    local TotalFields = buffer.readi8(Buffer, StartOffset)
    StartOffset += 1
    for i = 1, TotalFields do
        local FieldData = BUFFER_PROTOCOL_FIELDS[buffer.readi8(Buffer, StartOffset)]
        StartOffset += 1
        if FieldData.Type == "number" then
            Data[FieldData.Name] = buffer.readf64(Buffer, StartOffset)
            StartOffset += 8
        elseif FieldData.Type == "CFrame" then
            local Position = CFrame.new(buffer.readf32(Buffer, StartOffset), buffer.readf32(Buffer, StartOffset + 4), buffer.readf32(Buffer, StartOffset + 8))
            local AxisAngleVector3, AxisAngleRotation = Vector3.new(buffer.readf32(Buffer, StartOffset + 12), buffer.readf32(Buffer, StartOffset + 16), buffer.readf32(Buffer, StartOffset + 20)), buffer.readf32(Buffer, StartOffset + 24)
            Data[FieldData.Name] = Position * CFrame.fromAxisAngle(AxisAngleVector3, AxisAngleRotation)
            StartOffset += 7 * 4
        end
    end
    return Data, StartOffset - InitialOffset
end

--[[
Deserializess data for players.
--]]
function BufferProtocol.Deserialize(Buffer: buffer): {[number]: BufferProtocolData}
    local BufferLength = buffer.len(Buffer)
    local CurrentIndex = 0
    local Data = {}
    while CurrentIndex < BufferLength do
        local UserId = buffer.readf64(Buffer, CurrentIndex)
        CurrentIndex += 8
        local PlayerData, DataRead = BufferProtocol.DeserializeSection(Buffer, CurrentIndex)
        Data[UserId] = PlayerData
        CurrentIndex += DataRead
    end
    return Data
end



return BufferProtocol]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX190AF68EE87F469791FFFD6AA42E8BA5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">FindCollidablePartOnRay</string>
						<string name="ScriptGuid">{4242DC22-2BD8-443E-A696-2B258DA1C01F}</string>
						<ProtectedString name="Source"><![CDATA[--Helper function that ray casts to find a collidable part.
--!strict

local Workspace = game:GetService("Workspace")

return function(StartPosition: Vector3, Direction: Vector3, IgnoreList: Instance | {Instance}?, CollisionGroup: string?): (BasePart?, Vector3)
    --Convert the collision group.
    if typeof(CollisionGroup) == "Instance" and CollisionGroup:IsA("BasePart") then
        CollisionGroup = CollisionGroup.CollisionGroup
    end

    --Create the parameters.
    local RaycastParameters = RaycastParams.new()
    RaycastParameters.FilterType = Enum.RaycastFilterType.Exclude
    RaycastParameters.FilterDescendantsInstances = {Workspace.CurrentCamera}
    if IgnoreList then
        RaycastParameters:AddToFilter(IgnoreList)
    end
    RaycastParameters.IgnoreWater = true
    if CollisionGroup then
        RaycastParameters.CollisionGroup = CollisionGroup
    end

    while true do
        --Raycast and try again if the hit part isn't collidable.
        local RaycastResult = Workspace:Raycast(StartPosition, Direction, RaycastParameters)
        if not RaycastResult then
            return nil, StartPosition + Direction
        end
        local HitPart,EndPosition = RaycastResult.Instance, RaycastResult.Position
        if HitPart and not HitPart.CanCollide and (not HitPart:IsA("Seat") or not HitPart:IsA("VehicleSeat") or HitPart.Disabled) then
            RaycastParameters:AddToFilter(HitPart)
            continue
        end

        --Return the hit result.
        return HitPart, EndPosition
    end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXB7ABF9D9D2E74DDABDFC88BC6A589B44">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Warnings</string>
						<string name="ScriptGuid">{C7659871-76F3-4667-A467-462DFE1B7888}</string>
						<ProtectedString name="Source"><![CDATA[--Displays warnings when loading Nexus VR Character Model.
--!strict

local HttpService = game:GetService("HttpService")



return function(): ()
    --Load the configuration.
    local ConfigurationValue = script.Parent.Parent:WaitForChild("Configuration")
    local Configuration = HttpService:JSONDecode(ConfigurationValue.Value)

    --Determine the suppressed warnings.
    local SupressedWarnings = {}
    if Configuration.Output and Configuration.Output.SuppressWarnings then
        for _, WarningName in Configuration.Output.SuppressWarnings do
            SupressedWarnings[string.lower(WarningName)] = true
        end
    end
    if SupressedWarnings["all"] then return end

    --Build the warnings.
    local Warnings = {
        {
            Key = "MissingNexusVRBackpackEnabled",
            Message = "The configuration entry Extra.NexusVRBackpackEnabled is missing (defaults to true).",
            Condition = function()
               return Configuration.Extra == nil or Configuration.Extra.NexusVRBackpackEnabled == nil
            end,
        },
        {
            Key = "MissingAllowClientToOutputLoadedMessage",
            Message = "The configuration entry Extra.AllowClientToOutputLoadedMessage is missing (defaults to true).",
            Condition = function()
               return Configuration.Output == nil or Configuration.Output.AllowClientToOutputLoadedMessage == nil
            end,
        },
        {
            Key = "MissingDisableHeadLocked",
            Message = "The configuration entry Camera.DisableHeadLocked is missing (defaults to true).",
            Condition = function()
               return Configuration.Camera == nil or Configuration.Camera.DisableHeadLocked == nil
            end,
        },
    }

    --Output the warnings.
    for _, Warning in Warnings do
        if not SupressedWarnings[string.lower(Warning.Key)] and Warning.Condition() then
            warn(Warning.Message)
            warn(`\tThis warning can be disabled by adding \"{Warning.Key}\" or \"All\" to Output.SuppressWarnings in the configuration of Nexus VR Character Model.`)
        end
    end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXC359898D6496427280DF37EA55400301">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Enigma</string>
					<string name="ScriptGuid">{504C203B-2900-433F-B6B1-E54C03998B13}</string>
					<ProtectedString name="Source"><![CDATA[--Main module for managing UserCFrames from Enigma.
--!strict

local LAST_INPUT_TIMEOUT_SECONDS = 0.5

local UserInputService = game:GetService("UserInputService")
local VRService = game:GetService("VRService")

local TrackerRole = require(script:WaitForChild("Data"):WaitForChild("TrackerRole"))
local CombinedInput = require(script:WaitForChild("Input"):WaitForChild("CombinedInput"))
local CompanionPluginInput = require(script:WaitForChild("Input"):WaitForChild("CompanionPluginInput"))
local TextBoxInput = require(script:WaitForChild("Input"):WaitForChild("TextBoxInput"))
local DeserializeOpenVrInputs = require(script:WaitForChild("Serialization"):WaitForChild("DeserializeOpenVrInputs"))
local CalculateRolloff = require(script:WaitForChild("Util"):WaitForChild("CalculateRolloff"))

local Enigma = {
    Enabled = false,
    TrackerRoles = TrackerRole,
    Input = nil :: CombinedInput.CombinedInput?,
    LastInputData = "",
    LastInputTime = tick(),
    LastFloorCFrameToOrigin = CFrame.identity,
    LastInputs = {} :: {[TrackerRole]: {DeserializeOpenVrInputs.RawOpenVRInput}},
}

export type TrackerRole = TrackerRole.TrackerRole
export type Enigma = typeof(Enigma)



--[[
Returns if Enigma is considered active.
--]]
function Enigma.IsActive(self: Enigma): ()
    --Return if the Enigma text box is active.
    local FocusedTextBox = UserInputService:GetFocusedTextBox()
    if FocusedTextBox then
        if FocusedTextBox.Parent and FocusedTextBox.Name == "EnigmaTextBox" then
            return true
        end
    end

    --Return if the last update was within the timeout.
    return (tick() - self.LastInputTime) < LAST_INPUT_TIMEOUT_SECONDS
end

--[[
Updates the stored UserCFrames.
--]]
function Enigma.UpdateUserCFrames(self: Enigma): ()
    --Return if the input was not initialized.
    if not self.Input then
        warn("Enigma is not enabled. Call Enigma:Enable() before calling.")
        return
    end

    --Return if the data is unchanged.
    --Clear the inputs if it has been enough time since the last update.
    local NewInputData = self.Input:GetCurrentText()
    if NewInputData == self.LastInputData then
        if tick() - self.LastInputTime >= LAST_INPUT_TIMEOUT_SECONDS then
            self.LastInputs = {}
        end
        return
    end

    --Parse and store the inputs.
    --Done in a pcall in case the text can't be parsed.
    pcall(function()
        local NewInputs = {}
        for _, NewRawInput in DeserializeOpenVrInputs(NewInputData) do
            if not NewInputs[NewRawInput.TrackerRole] then NewInputs[NewRawInput.TrackerRole] = {} end
            table.insert(NewInputs[NewRawInput.TrackerRole], NewRawInput)
        end
        self.LastInputData = NewInputData
        self.LastInputTime = tick()
        self.LastFloorCFrameToOrigin = VRService:GetUserCFrame(Enum.UserCFrame.Floor)
        self.LastInputs = NewInputs
    end)
end

--[[
Returns if a UserCFrame is active.
An optional index can be passed in for when a user has multiple trackers for the same role.
--]]
function Enigma.GetUserCFrameEnabled(self: Enigma, UserCFrame: TrackerRole, Index: number?): boolean
    self:UpdateUserCFrames()
    local UserCFrameGroup = self.LastInputs[UserCFrame]
    return UserCFrameGroup ~= nil and UserCFrameGroup[Index or 1] ~= nil
end

--[[
Returns the CFrame for a UserCFrame.
The result will be nil if the user does not have a tracker for the UserCFrame.
An optional index can be passed in for when a user has multiple trackers for the same role.
--]]
function Enigma.GetUserCFrame(self: Enigma, UserCFrame: TrackerRole, Index: number?): CFrame?
    self:UpdateUserCFrames()
    local UserCFrameGroup = self.LastInputs[UserCFrame]
    if not UserCFrameGroup then return nil end
    local RawInputData = UserCFrameGroup[Index or 1]
    if not RawInputData then return nil end
    local TimeOffset = CalculateRolloff(0.03, 0.03 * 3, tick() - self.LastInputTime)
    return self.LastFloorCFrameToOrigin * (CFrame.new(RawInputData.FloorRelativeVelocity * TimeOffset) * RawInputData.FloorRelativeCFrame)
end

--[[
Enables inputs for Enigma.
--]]
function Enigma.Enable(self: Enigma): ()
    if self.Input then return end
    self.Input = CombinedInput.new({TextBoxInput.new(), CompanionPluginInput.new()} :: {any})
    self.Enabled = true
end



return Enigma]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX4FF26594C6BA4C7A96549D7DA810EE0C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Data</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXBDF431E33D6F4E2E8D9F386655A105C0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TrackerRole</string>
							<string name="ScriptGuid">{2F639D8A-7303-4692-87A3-7953FDFD70A9}</string>
							<ProtectedString name="Source"><![CDATA[--Enum for a tracker.
--!strict

export type TrackerRole = "None" | "Handed" | "LeftFoot" | "RightFoot" | "LeftShoulder" |
    "RightShoulder" | "LeftElbow" | "RightElbow" | "LeftKnee" | "RightKnee" |
    "Waist" | "Chest" | "Camera" | "Keyboard" | "Unsupported"

return {
    "None",
    "Handed",
    "LeftFoot",
    "RightFoot",
    "LeftShoulder",
    "RightShoulder",
    "LeftElbow",
    "RightElbow",
    "LeftKnee",
    "RightKnee",
    "Waist",
    "Chest",
    "Camera",
    "Keyboard",
    "Unsupported",
} :: {TrackerRole}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX393AB03E5923458CBDAB5CF31084D5E0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Input</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXD5913856B6384C668AE70FD8EB34128B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CombinedInput</string>
							<string name="ScriptGuid">{5EBEE9AA-65D4-4DD8-8D0F-E2AD41521790}</string>
							<ProtectedString name="Source"><![CDATA[--Combines multiple inputs together and returns the latest one that changes.
--When multiple inputs change, the first changed one is prioritized.
--!strict

local CombinedInput = {}
CombinedInput.__index = CombinedInput

export type GenericInput = {
    GetCurrentText: (self: GenericInput) -> (string),
} & any
export type CombinedInput = {
    Inputs: {GenericInput},
    LastText: string,
    LastTextValues: {[GenericInput]: string},
} & typeof(setmetatable({}, CombinedInput))


--[[
Creates a new CombinedInput.
--]]
function CombinedInput.new(Inputs: {GenericInput}): CombinedInput
    --Get the initial text values.
    local LastTextValues = {}
    for _, Input in Inputs do
        LastTextValues[Input] = Input:GetCurrentText()
    end

    --Create and return the value.
    return setmetatable({
        Inputs = Inputs,
        LastText = LastTextValues[Inputs[1]],
        LastTextValues = LastTextValues,
    }, CombinedInput) :: CombinedInput
end

--[[
Returns the current data in the TextBox.
Any data may be stored, including an empty string.
--]]
function CombinedInput.GetCurrentText(self: CombinedInput): string
    --Get the new values.
    local NewTextValues = {}
    for _, Input in self.Inputs do
        NewTextValues[Input] = Input:GetCurrentText()
    end

    --Update the last text if an input changed, starting at the first input.
    for _, Input in self.Inputs do
        if NewTextValues[Input] == self.LastTextValues[Input] then continue end
        self.LastText = NewTextValues[Input]
        break
    end

    --Return the new text.
    return self.LastText
end



return CombinedInput]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX802A94F59D9E44A0AF6FF58CD5CDD80D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CompanionPluginInput</string>
							<string name="ScriptGuid">{BBDBD4D3-572D-452E-A13F-6E7AE98DA249}</string>
							<ProtectedString name="Source"><![CDATA[--Reads data from the StringValue created by the Enigma companion plugin.
--!strict

local DATA_VALUE_NAME = "__EnigmaPluginData"

local ReplicatedStorage = game:GetService("ReplicatedStorage")

local CompanionPluginInput = {}
CompanionPluginInput.__index = CompanionPluginInput

export type CompanionPluginInput = typeof(setmetatable({}, CompanionPluginInput))



--[[
Creates a new CompanionPluginInput.
--]]
function CompanionPluginInput.new(): CompanionPluginInput
    return setmetatable({}, CompanionPluginInput) :: CompanionPluginInput
end

--[[
Returns the current data in the TextBox.
Any data may be stored, including an empty string.
--]]
function CompanionPluginInput.GetCurrentText(self: CompanionPluginInput): string
    local DataValue = ReplicatedStorage:FindFirstChild(DATA_VALUE_NAME) :: StringValue
    if not DataValue then return "" end
    return DataValue.Value
end



return CompanionPluginInput]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC5A205CB3B724990988CD716279B886A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TextBoxInput</string>
							<string name="ScriptGuid">{414538B7-64F3-4BC2-97D3-048E14609BBF}</string>
							<ProtectedString name="Source"><![CDATA[--Creates a TextBox that is locked to being focused to receive data.
--!strict

local HEARTBEAT_TIMEOUT_SECONDS = 0.5

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local TextBoxInput = {}
TextBoxInput.__index = TextBoxInput

export type TextBoxInput = {
    WindowFocused: boolean,
    LastHeartbeatTime: number,
    Events: {RBXScriptConnection},
    TextBoxEvents: {RBXScriptConnection},
    ScreenGui: ScreenGui?,
    TextBox: TextBox?,
} & typeof(setmetatable({}, TextBoxInput))



--[[
Creates a new TextBoxInput.
--]]
function TextBoxInput.new(Parent: Instance?): TextBoxInput
    --Create the object.
    local self = setmetatable({
        WindowFocused = true,
        LastHeartbeatTime = 0,
        Events = {},
        TextBoxEvents = {},
    }, TextBoxInput) :: TextBoxInput
    self:CreateTextBox(Parent or Players.LocalPlayer:WaitForChild("PlayerGui"))
    
    --Force the focusing of the TextBox.
    table.insert(self.Events, UserInputService.InputBegan:Connect(function(Input)
        if Input.KeyCode ~= Enum.KeyCode.F13 then return end
        self.LastHeartbeatTime = tick()
        self:TryCaptureFocus()
    end))
    table.insert(self.Events, UserInputService.WindowFocused:Connect(function()
        self.WindowFocused = true
        self:TryCaptureFocus()
    end))
    table.insert(self.Events, UserInputService.WindowFocusReleased:Connect(function()
        self.WindowFocused = false
        self:TryReleaseFocus()
    end))
    table.insert(self.Events, RunService.Stepped:Connect(function()
        self:TryCaptureFocus()
    end))

    --Return the object.
    return self
end

--[[
Creates the ScreenGui and TextBox.
This may be called multiple times it is destroyed.
--]]
function TextBoxInput.CreateTextBox(self: TextBoxInput, Parent: Instance): ()
    --Clear the previous elements.
    for _, Event in self.TextBoxEvents do
        Event:Disconnect()
    end
    self.TextBoxEvents = {}
    if self.ScreenGui then
        self.ScreenGui:Destroy()
    end
    if self.TextBox then
        self.TextBox:Destroy()
    end

    --Create the ScreenGui and TextBox.
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "EnigmaTextBoxInput"
    ScreenGui.ResetOnSpawn = false
    ScreenGui.Parent = Parent
    self.ScreenGui = ScreenGui

    local TextBox = Instance.new("TextBox")
    TextBox.Name = "EnigmaTextBox"
    TextBox.BackgroundTransparency = 0.99
    TextBox.BorderSizePixel = 0
    TextBox.Size = UDim2.new(0, 1, 0, 1)
    TextBox.Selectable = false
    TextBox.ClipsDescendants = true
    TextBox.ClearTextOnFocus = true
    TextBox.TextTransparency = 0.99
    TextBox.Parent = ScreenGui
    self.TextBox = TextBox

    --Connect the TextBox becoming inaccessible.
    table.insert(self.TextBoxEvents, TextBox.AncestryChanged:Connect(function()
        self:CreateTextBox(Parent)
    end))
    for _, Property in {"Enabled"} do
        local OriginalValue = (ScreenGui :: any)[Property]
        table.insert(self.TextBoxEvents, ScreenGui:GetPropertyChangedSignal(Property):Connect(function()
            (ScreenGui :: any)[Property] = OriginalValue
        end))
    end
    for _, Property in {"BackgroundTransparency", "Size", "ClipsDescendants", "Visible", "TextTransparency"} do
        local OriginalValue = (TextBox :: any)[Property]
        table.insert(self.TextBoxEvents, TextBox:GetPropertyChangedSignal(Property):Connect(function()
            (TextBox :: any)[Property] = OriginalValue
        end))
    end
end

--[[
Returns the current data in the TextBox.
Any data may be stored, including an empty string.
--]]
function TextBoxInput.GetCurrentText(self: TextBoxInput): string
    if not self.TextBox then return "" end
    return self.TextBox.Text
end

--[[
Tries to capture the focus of the TextBox.
--]]
function TextBoxInput.TryCaptureFocus(self: TextBoxInput): ()
    --Return if the TextBox should not be focused.
    if not self.WindowFocused or (tick() - self.LastHeartbeatTime) > HEARTBEAT_TIMEOUT_SECONDS then
        self:TryReleaseFocus()
        return
    end
    if not self.TextBox then return end
    if UserInputService:GetFocusedTextBox() == self.TextBox then return end

    --Capture the focus of the TextBox.
    self.TextBox:CaptureFocus()
end

--[[
Tries to release the focus of the TextBox.
--]]
function TextBoxInput.TryReleaseFocus(self: TextBoxInput): ()
    if not self.TextBox then return end
    if UserInputService:GetFocusedTextBox() ~= self.TextBox then return end
    self.TextBox:ReleaseFocus()
end

--[[
Destroys the TextBoxInput.
--]]
function TextBoxInput.Destroy(self: TextBoxInput): ()
    --Clear the events.
    for _, Event in self.Events do
        Event:Disconnect()
    end
    self.Events = {}
    for _, Event in self.TextBoxEvents do
        Event:Disconnect()
    end
    self.TextBoxEvents = {}

    --Clear the objects.
    if self.ScreenGui then
        self.ScreenGui:Destroy()
    end
    self.ScreenGui = nil
    if self.TextBox then
        self.TextBox:Destroy()
    end
    self.TextBox = nil
end



return TextBoxInput]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXB85C5F26639D41D099132A2A43067348">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Serialization</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXD45A39CC7E4C4A0A9D026D72E86BF75A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">DeserializeOpenVrInputs</string>
							<string name="ScriptGuid">{560DAEED-E005-45F8-A275-1FA56F0E535E}</string>
							<ProtectedString name="Source"><![CDATA[--Deserializes OpenVR input data from Enigma.
--!strict

local BASE_QUATERNION = {X = 0, Y = 0, Z = 0, W = 1}

local TrackerRole = require(script.Parent.Parent:WaitForChild("Data"):WaitForChild("TrackerRole"))
local StringDeserializer = require(script.Parent:WaitForChild("StringDeserializer"))

local WarnedMessages = {}

export type RawOpenVRInput = {
    TrackerRole: TrackerRole.TrackerRole,
    FloorRelativeCFrame: CFrame,
    FloorRelativeVelocity: Vector3,
}



--[[
Displays a warning message once.
--]]
local function WarnOnce(Message: string): ()
    if WarnedMessages[Message] then return end
    WarnedMessages[Message] = true
    warn(Message)
end



return function(Data: string): {RawOpenVRInput}
    --Prepare the deserialziation and check the protocol version.
    local Deserializer = StringDeserializer.new(Data)
    local ProcotolVersion = Deserializer:ReadNumber()
    local TotalTrackers = Deserializer:ReadNumber()
    if ProcotolVersion ~= 1 and ProcotolVersion ~= 2 then
        WarnOnce(`Enigma protocol version {ProcotolVersion} is unsupported and might not work as expected. Supported versions: 1, 2`)
    end

    --Read the inputs.
    local RawInputs = {}
    if ProcotolVersion == 1 then
        --Protocol version 1 was deprecated due to having no way to be forwards-compatible with new versions.
        for _ = 1, TotalTrackers do
            local Role = TrackerRole[Deserializer:ReadNumber() + 1] or "Unsupported" --Protocol starts counting at 0, but Lua starts at 1.
            local Position = Deserializer:ReadVector3()
            local Rotation = Deserializer:ReadQuaternion()
            local Velocity = Deserializer:ReadVector3()
            table.insert(RawInputs, {
                TrackerRole = Role :: TrackerRole.TrackerRole,
                FloorRelativeCFrame = CFrame.new(Position.X, Position.Y, Position.Z, Rotation.X, Rotation.Y, Rotation.Z, Rotation.W),
                FloorRelativeVelocity = Velocity,
            })
        end
    else
        --Protocol version 2 and higher *in theory* should be compatible with future versions.
        for _ = 1, TotalTrackers do
            local Role = "Unsupported"
            local Position = Vector3.zero
            local Rotation = BASE_QUATERNION
            local Velocity = Vector3.zero

            --Read the properties.
            local TotalProperties = Deserializer:ReadNumber()
            for _ = 1, TotalProperties do
                local PropertyId = Deserializer:ReadNumber()
                local TotalValues = Deserializer:ReadNumber()
                if PropertyId == 0 then --Tracker role
                    Role = TrackerRole[Deserializer:ReadNumber() + 1] or "Unsupported" --Protocol starts counting at 0, but Lua starts at 1.
                elseif PropertyId == 1 then --Position
                    Position = Deserializer:ReadVector3()
                elseif PropertyId == 2 then --Rotation
                    Rotation = Deserializer:ReadQuaternion()
                elseif PropertyId == 3 then --Velocity
                    Velocity = Deserializer:ReadVector3()
                else
                    local UnknownValues = {}
                    for _ = 1, TotalValues do
                        table.insert(UnknownValues, Deserializer:ReadString())
                    end
                    WarnOnce(`Unsupported property id {PropertyId} sent with {TotalValues} values: {table.concat(UnknownValues, "|")}`)
                end
            end

            --Add the input.
            table.insert(RawInputs, {
                TrackerRole = Role :: TrackerRole.TrackerRole,
                FloorRelativeCFrame = CFrame.new(Position.X, Position.Y, Position.Z, Rotation.X, Rotation.Y, Rotation.Z, Rotation.W),
                FloorRelativeVelocity = Velocity,
            })
        end

    end
    return RawInputs
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF6B75E23F226452F846EADA44E875800">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">StringDeserializer</string>
							<string name="ScriptGuid">{0C97C56D-CB20-47B2-A7AF-83489D1765C9}</string>
							<ProtectedString name="Source"><![CDATA[--Deserializes strings from Enigma's StringSerializer format.
--Due to pasting sometimes appending instead of replacing, this method is preferred over JSON.
--!strict

local StringDeserializer = {}
StringDeserializer.__index = StringDeserializer

export type Quaternion = {
    X: number,
    Y: number,
    Z: number,
    W: number,
}
export type StringDeserializer = {
    Index: number,
    Data: {string},
} & typeof(setmetatable({}, StringDeserializer))



--[[
Creates a new StringDeserializer for a message.
--]]
function StringDeserializer.new(Data: string): StringDeserializer
    return setmetatable({
        Index = 1,
        Data = string.split(Data, "|")
    }, StringDeserializer) :: StringDeserializer
end

--[[
Returns the next string.
--]]
function StringDeserializer.ReadString(self: StringDeserializer): string
    local Index = self.Index
    if not self.Data[Index] then error("Reached end of serialized string.") end
    self.Index += 1
    return self.Data[Index]
end

--[[
Returns the next number.
--]]
function StringDeserializer.ReadNumber(self: StringDeserializer): number
    return tonumber(self:ReadString()) :: number
end

--[[
Returns the next Vector3.
--]]
function StringDeserializer.ReadVector3(self: StringDeserializer): Vector3
    return Vector3.new(self:ReadNumber(), self:ReadNumber(), self:ReadNumber())
end

--[[
Returns the next Quaternion in the format of X, Y, Z, W.
--]]
function StringDeserializer.ReadQuaternion(self: StringDeserializer): Quaternion
    return {
        X = self:ReadNumber(),
        Y = self:ReadNumber(),
        Z = self:ReadNumber(),
        W = self:ReadNumber(),
    }
end



return StringDeserializer]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX2DD7D6BC726E4FB4BBBCEE33B27A1B21">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Util</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXD297E52646164C85B6F59E22CCF50821">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CalculateRolloff</string>
							<string name="ScriptGuid">{2BC79BD7-2C37-4B69-BB25-A07C20F7803E}</string>
							<ProtectedString name="Source"><![CDATA[--Calculates the multiplier to use with a rolloff to prevent excessive extrapolation.
--!strict

return function(NoRolloff: number, Rolloff: number, Multiplier: number): number
    if Multiplier <= NoRolloff then
        return Multiplier
    end
    return NoRolloff + (math.min((Multiplier - NoRolloff), Rolloff) / 2)
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX5FB4035901D24B84A30F6E25E2059C91">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">NexusAppendage</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX050243CB6E8A47EC92BB19F7CDD5805C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Appendage</string>
						<string name="ScriptGuid">{8CA5701F-70A8-4DD0-9D08-834D8903FDA3}</string>
						<ProtectedString name="Source"><![CDATA[--Manages an appendage for a character, such as an arm or a leg.
--!strict

local Limb = require(script.Parent:WaitForChild("Limb"))
local JointOffset = require(script.Parent:WaitForChild("JointOffset"))

local Appendage = {}
Appendage.Presets = {
    LeftArm = {
        "UpperTorso",
        "LeftUpperArm",
        "LeftLowerArm",
        "LeftHand",
        "LeftShoulder",
        "LeftShoulderRigAttachment",
        "LeftElbowRigAttachment",
        "LeftWristRigAttachment",
        "LeftGripAttachment",
    },
    RightArm = {
        "UpperTorso",
        "RightUpperArm",
        "RightLowerArm",
        "RightHand",
        "RightShoulder",
        "RightShoulderRigAttachment",
        "RightElbowRigAttachment",
        "RightWristRigAttachment",
        "RightGripAttachment",
    },
    LeftLeg = {
        "LowerTorso",
        "LeftUpperLeg",
        "LeftLowerLeg",
        "LeftFoot",
        "LeftHip",
        "LeftHipRigAttachment",
        "LeftKneeRigAttachment",
        "LeftAnkleRigAttachment",
        "LeftFootAttachment",
    },
    RightLeg = {
        "LowerTorso",
        "RightUpperLeg",
        "RightLowerLeg",
        "RightFoot",
        "RightHip",
        "RightHipRigAttachment",
        "RightKneeRigAttachment",
        "RightAnkleRigAttachment",
        "RightFootAttachment",
    },
}
Appendage.ConstraintPresets = {
    LeftArm = {
        {
            Type = "BallSocketConstraint",
            Attachment0 = {
                Part = "UpperTorso",
                Attachment = "LeftShoulderRigAttachment",
                Offset = CFrame.Angles(0, math.pi, 0),
            },
            Attachment1 = {
                Part = "LeftUpperArm",
                Attachment = "LeftShoulderRigAttachment",
                Offset = CFrame.Angles(0, math.pi, -math.pi / 2),
            },
            Properties = {
                Name = "LeftShoulderBallSocket",
                LimitsEnabled = true,
                UpperAngle = 110,
                TwistLimitsEnabled = true,
                TwistLowerAngle = -85,
                TwistUpperAngle = 85,
            },
        },
        {
            Type = "BallSocketConstraint",
            Attachment0 = {
                Part = "LeftUpperArm",
                Attachment = "LeftElbowRigAttachment",
                Offset = CFrame.identity,
            },
            Attachment1 = {
                Part = "LeftLowerArm",
                Attachment = "LeftElbowRigAttachment",
                Offset = CFrame.identity,
            },
            Properties = {
                Name = "LeftElbowBallSocket",
                LimitsEnabled = true,
                UpperAngle = 20,
                TwistLimitsEnabled = true,
                TwistLowerAngle = 5,
                TwistUpperAngle = 120,
            },
        },
    },
    RightArm = {
        {
            Type = "BallSocketConstraint",
            Attachment0 = {
                Part = "UpperTorso",
                Attachment = "RightShoulderRigAttachment",
                Offset = CFrame.identity,
            },
            Attachment1 = {
                Part = "RightUpperArm",
                Attachment = "RightShoulderRigAttachment",
                Offset = CFrame.Angles(0, 0, -math.pi / 2),
            },
            Properties = {
                Name = "RightShoulderBallSocket",
                LimitsEnabled = true,
                UpperAngle = 110,
                TwistLimitsEnabled = true,
                TwistLowerAngle = -85,
                TwistUpperAngle = 85,
            },
        },
        {
            Type = "BallSocketConstraint",
            Attachment0 = {
                Part = "RightUpperArm",
                Attachment = "RightElbowRigAttachment",
                Offset = CFrame.identity,
            },
            Attachment1 = {
                Part = "RightLowerArm",
                Attachment = "RightElbowRigAttachment",
                Offset = CFrame.identity,
            },
            Properties = {
                Name = "RightElbowBallSocket",
                LimitsEnabled = true,
                UpperAngle = 20,
                TwistLimitsEnabled = true,
                TwistLowerAngle = 5,
                TwistUpperAngle = 120,
            },
        },
    },
    LeftLeg = {
        {
            Type = "BallSocketConstraint",
            Attachment0 = {
                Part = "LowerTorso",
                Attachment = "LeftHipRigAttachment",
                Offset = CFrame.identity,
            },
            Attachment1 = {
                Part = "LeftUpperLeg",
                Attachment = "LeftHipRigAttachment",
                Offset = CFrame.identity,
            },
            Properties = {
                Name = "LeftHipBallSocket",
                LimitsEnabled = true,
                UpperAngle = 40,
                TwistLimitsEnabled = true,
                TwistLowerAngle = -5,
                TwistUpperAngle = 80,
            },
        },
        {
            Type = "BallSocketConstraint",
            Attachment0 = {
                Part = "LeftUpperLeg",
                Attachment = "LeftKneeRigAttachment",
                Offset = CFrame.identity,
            },
            Attachment1 = {
                Part = "LeftLowerLeg",
                Attachment = "LeftKneeRigAttachment",
                Offset = CFrame.identity,
            },
            Properties = {
                Name = "LeftKneeBallSocket",
                LimitsEnabled = true,
                UpperAngle = 5,
                TwistLimitsEnabled = true,
                TwistLowerAngle = -120,
                TwistUpperAngle = 5,
            },
        },
    },
    RightLeg = {
        {
            Type = "BallSocketConstraint",
            Attachment0 = {
                Part = "LowerTorso",
                Attachment = "RightHipRigAttachment",
                Offset = CFrame.identity,
            },
            Attachment1 = {
                Part = "RightUpperLeg",
                Attachment = "RightHipRigAttachment",
                Offset = CFrame.identity,
            },
            Properties = {
                Name = "RightHipBallSocket",
                LimitsEnabled = true,
                UpperAngle = 40,
                TwistLimitsEnabled = true,
                TwistLowerAngle = -5,
                TwistUpperAngle = 80,
            },
        },
        {
            Type = "BallSocketConstraint",
            Attachment0 = {
                Part = "RightUpperLeg",
                Attachment = "RightKneeRigAttachment",
                Offset = CFrame.identity,
            },
            Attachment1 = {
                Part = "RightLowerLeg",
                Attachment = "RightKneeRigAttachment",
                Offset = CFrame.identity,
            },
            Properties = {
                Name = "RightKneeBallSocket",
                LimitsEnabled = true,
                UpperAngle = 5,
                TwistLimitsEnabled = true,
                TwistLowerAngle = -120,
                TwistUpperAngle = 5,
            },
        },
    },
}
Appendage.__index = Appendage
setmetatable(Appendage, Limb)

export type Appendage = {
    RootPart: BasePart,
    UpperLimb: BasePart,
    LowerLimb: BasePart,
    LimbEnd: BasePart,
    StartJointOffset: JointOffset.JointOffset,
    StartAttachment: string,
    LimbJointAttachment: string,
    LimbEndAttachment: string,
    LimbHoldAttachment: string,
    AllowDisconnection: boolean,
    IKControlAttachment: Attachment,
    IKControl: IKControl,
    Constraints: {Instance},
} & typeof(setmetatable({},Appendage )) &  Limb.Limb



--[[
Creates an appendage.
--]]
function Appendage.new(Humanoid: Humanoid, RootPart: BasePart, UpperLimb: BasePart, LowerLimb: BasePart, LimbEnd: BasePart, StartMotor: string, StartAttachment: string, LimbJointAttachment: string, LimbEndAttachment: string, LimbHoldAttachment: string, AllowDisconnection: boolean?, SmoothTime: number?): Appendage
    --Store the parts.
    local self = setmetatable(Limb.new() :: any, Appendage) :: Appendage
    self.RootPart = RootPart
    self.UpperLimb = UpperLimb
    self.LowerLimb = LowerLimb
    self.LimbEnd = LimbEnd
    self.StartJointOffset = JointOffset.new(UpperLimb:WaitForChild(StartMotor) :: Motor6D, RootPart, StartAttachment)
    self.StartAttachment = StartAttachment
    self.LimbJointAttachment = LimbJointAttachment
    self.LimbEndAttachment = LimbEndAttachment
    self.LimbHoldAttachment = LimbHoldAttachment
    self.AllowDisconnection = AllowDisconnection or false
    self.Constraints = {}

    --Create arbitrary end attachments.
    if (LimbHoldAttachment == "LeftFootAttachment" or LimbHoldAttachment == "RightFootAttachment") and not LimbEnd:FindFirstChild(LimbHoldAttachment) then
        local EndAttachment = Instance.new("Attachment")
        EndAttachment.Name = LimbHoldAttachment
        EndAttachment.CFrame = CFrame.new(0, -LimbEnd.Size.Y / 2, 0)
        EndAttachment.Parent = LimbEnd

        local OriginalPositionValue = Instance.new("Vector3Value")
        OriginalPositionValue.Name = "OriginalPosition"
        OriginalPositionValue.Value = EndAttachment.Position
        OriginalPositionValue.Parent = EndAttachment
    end

    --Prepare the IKControl.
    if not Humanoid:FindFirstChildOfClass("Animator") then
        Instance.new("Animator").Parent = Humanoid
    end

    local IKControlAttachment = Instance.new("Attachment")
    IKControlAttachment.Name = `{UpperLimb.Name}_{LowerLimb.Name}_Attachment`
    IKControlAttachment.Parent = RootPart
    self.IKControlAttachment = IKControlAttachment

    local IKControl = Instance.new("IKControl")
    IKControl.Name = `{UpperLimb.Name}_{LowerLimb.Name}_IKControl`
    IKControl.ChainRoot = UpperLimb
    IKControl.EndEffector = LimbEnd
    IKControl.Offset = self:GetAttachmentCFrame(LimbEnd, LimbHoldAttachment):Inverse()
    IKControl.SmoothTime = SmoothTime or 0
    IKControl.Target = IKControlAttachment
    IKControl.Parent = Humanoid
    self.IKControl = IKControl
    self:MoveTo(self:GetAttachmentCFrame(UpperLimb, StartAttachment):Inverse() * self:GetAttachmentCFrame(UpperLimb, LimbJointAttachment) * self:GetAttachmentCFrame(LowerLimb, LimbJointAttachment):Inverse() * self:GetAttachmentCFrame(LowerLimb, LimbEndAttachment) * self:GetAttachmentCFrame(LimbEnd, LimbEndAttachment):Inverse() * self:GetAttachmentCFrame(LimbEnd, LimbHoldAttachment))

    --Return the object.
    return self
end

--[[
Creates an appendage using a CFrame.
--]]
function Appendage.FromPreset(PresetName: string, Character: Model, AllowDisconnection: boolean?, SmoothTime: number?): Appendage
    local Preset = Appendage.Presets[PresetName]
    local AppendageInstance = Appendage.new(Character:WaitForChild("Humanoid") :: Humanoid, Character:WaitForChild(Preset[1]) :: BasePart, Character:WaitForChild(Preset[2]) :: BasePart, Character:WaitForChild(Preset[3]) :: BasePart, Character:WaitForChild(Preset[4]) :: BasePart, Preset[5], Preset[6], Preset[7], Preset[8], Preset[9], AllowDisconnection, SmoothTime)
    AppendageInstance:AddConstraints(PresetName, Character)
    return AppendageInstance
end

--[[
Adds constraints for an appendage.
--]]
function Appendage.AddConstraints(self: Appendage, PresetName: string, Character: Model): ()
    for _, ConstraintPreset in Appendage.ConstraintPresets[PresetName] do
        local Attachment0Part = Character:WaitForChild(ConstraintPreset.Attachment0.Part) :: BasePart
        local Attachment1Part = Character:WaitForChild(ConstraintPreset.Attachment1.Part) :: BasePart

        --Ignore the constraint if the joint is already constrained.
        if Attachment1Part:FindFirstChildOfClass(ConstraintPreset.Type) then continue end

        --Get the attachments.
        local Attachment0 = Attachment0Part:WaitForChild(ConstraintPreset.Attachment0.Attachment) :: Attachment
        if ConstraintPreset.Attachment0.Offset ~= CFrame.identity then
            local NewAttachment0 = Attachment0:Clone()
            NewAttachment0.Name = "NexusAppendageConstraintOffset"
            NewAttachment0.CFrame = ConstraintPreset.Attachment0.Offset
            NewAttachment0.Parent = Attachment0
            table.insert(self.Constraints, NewAttachment0)
            Attachment0 = NewAttachment0
        end
        local Attachment1 = Attachment1Part:WaitForChild(ConstraintPreset.Attachment1.Attachment) :: Attachment
        if ConstraintPreset.Attachment1.Offset ~= CFrame.identity then
            local NewAttachment1 = Attachment1:Clone()
            NewAttachment1.Name = "NexusAppendageConstraintOffset"
            NewAttachment1.CFrame = ConstraintPreset.Attachment1.Offset
            NewAttachment1.Parent = Attachment1
            table.insert(self.Constraints, NewAttachment1)
            Attachment1 = NewAttachment1
        end

        --Create the constraint.
        local Constraint = Instance.new(ConstraintPreset.Type) :: any
        for Name, Value in ConstraintPreset.Properties do
            Constraint[Name] = Value
        end
        Constraint.Attachment0 = Attachment0
        Constraint.Attachment1 = Attachment1
        Constraint.Parent = Attachment1Part
        table.insert(self.Constraints, Constraint)
    end
end

--[[
Enables the appendage.
--]]
function Appendage.Enable(self: Appendage): ()
    self.IKControl.Weight = 1
end

--[[
Disables the appendage.
--]]
function Appendage.Disable(self: Appendage): ()
    self.IKControl.Weight = 0
end

--[[
Sets the target attachment for the IKControl.
MoveTo and MoveToWorld will not work when a target attachment is set.
--]]
function Appendage.SetTargetAttachment(self: Appendage, Target: Attachment?): ()
    self.IKControl.Target = Target or self.IKControlAttachment
end

--[[
Sets the smoothing time.
--]]
function Appendage.SetSmoothTime(self: Appendage, SmoothTime: number): ()
    self.IKControl.SmoothTime = SmoothTime
end

--[[
Moves the appendage target to the given CFrame relative to the
attachment the upper limb rotates at.
--]]
function Appendage.MoveTo(self: Appendage, Target: CFrame, TweenInfoObject: TweenInfo?): ()
    --Move the target CFrame.
    local StartAttachmentCFrame = self.StartJointOffset.AttachmentCFrame
    self.StartJointOffset:SetProperty(self.IKControlAttachment, "CFrame", StartAttachmentCFrame * Target, TweenInfoObject)

    --Move the Motor6D if disconnection is allowed.
    if not self.AllowDisconnection then return end
    local TargetEndJointCFrame = Target * self:GetAttachmentCFrame(self.LimbEnd, self.LimbHoldAttachment):Inverse() * self:GetAttachmentCFrame(self.LimbEnd, self.LimbEndAttachment)
    local AppendageLength = (self:GetAttachmentCFrame(self.UpperLimb, self.StartAttachment):Inverse() * self:GetAttachmentCFrame(self.UpperLimb, self.LimbJointAttachment) * self:GetAttachmentCFrame(self.LowerLimb, self.LimbJointAttachment):Inverse() * self:GetAttachmentCFrame(self.LowerLimb, self.LimbEndAttachment)).Position.Magnitude
    local TargetLength = TargetEndJointCFrame.Position.Magnitude
    if TargetLength > AppendageLength then
        self.StartJointOffset:SetOffset(CFrame.new(CFrame.new(Vector3.zero, TargetEndJointCFrame.Position).LookVector * (TargetLength - AppendageLength)), TweenInfoObject)
    else
        self.StartJointOffset:SetOffset(CFrame.identity, TweenInfoObject)
    end
end

--[[
Moves the appendage target to the given CFrame in world space.
--]]
function Appendage.MoveToWorld(self: Appendage, Target: CFrame, TweenInfoObject: TweenInfo?): ()
    local StartCFrame = self.RootPart.CFrame * self.StartJointOffset.AttachmentCFrame
    self:MoveTo(StartCFrame:Inverse() * Target)
end

--[[
Destroys the appendage.
--]]
function Appendage.Destroy(self: Appendage): ()
    --Clear the offset.
    self.StartJointOffset:Destroy()

    --Clear the IKControl.
    self.IKControlAttachment:Destroy()
    self.IKControl:Destroy()
    for _, Constraint in self.Constraints do
        Constraint:Destroy()
    end
end



return Appendage]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXA02E9266CE8345FF878F15DF97B43C3F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">JointOffset</string>
						<string name="ScriptGuid">{36C298BE-8C46-4BF2-BCB1-5AB94E740F3C}</string>
						<ProtectedString name="Source"><![CDATA[--Controls the offset of a joint.
--!strict

local TweenService = game:GetService("TweenService")

local JointOffset = {}
JointOffset.__index = JointOffset

export type JointType = "Motor6D" | "AnimationConstraint"
export type JointOffset = {
    JointType: JointType,
    Destroyed: boolean,
    Motor: Motor6D | AnimationConstraint,
    Part0: BasePart,
    StartAttachment: Attachment?,
    AttachmentCFrame: CFrame,
    ActiveTweens: {[Instance]: {[string]: Tween}},
    EventConnections: {RBXScriptConnection},
} & typeof(setmetatable({}, JointOffset))



--[[
Creates a JointOffset.
--]]
function JointOffset.new(Motor: Motor6D | AnimationConstraint, Part0: BasePart, AttachmentName: string): JointOffset
    --Create the initial object.
    local self = setmetatable({
        JointType = Motor.ClassName :: JointType,
        Destroyed = false,
        Motor = Motor,
        Part0 = Part0,
        AttachmentCFrame = CFrame.identity,
        ActiveTweens = {},
        EventConnections = {},
    }, JointOffset) :: JointOffset

    --Connect the attachment.
    table.insert(self.EventConnections, Part0.ChildAdded:Connect(function(Attachment)
        if Attachment.Name ~= AttachmentName or not Attachment:IsA("Attachment") then return end
        self:ConnectAttachment(Attachment)
    end))
    self:ConnectAttachment(Part0:FindFirstChild(AttachmentName) :: Attachment)

    --Return the object.
    return self
end

--[[
Connects an attachment.
--]]
function JointOffset.ConnectAttachment(self: JointOffset, Attachment: Attachment?): ()
    if not Attachment then return end

    --Store the new initial CFrame.
    self.AttachmentCFrame = Attachment.CFrame
    self.StartAttachment = Attachment

    --Try to connect external changes to the event.
    --There is no good way to support external Attachment.CFrame changes with this setup.
    --Checking for the part size changes is "good enough".
    table.insert(self.EventConnections, self.Part0:GetPropertyChangedSignal("Size"):Connect(function()
        if self.StartAttachment ~= Attachment then return end
        self.AttachmentCFrame = Attachment.CFrame
    end))
end

--[[
Sets a property with an optional TweenInfo.
--]]
function JointOffset.SetProperty(self: JointOffset, Ins: any, PropertyName: string, PropertyValue: any, TweenInfoObject: TweenInfo?): ()
    if self.Destroyed then return end
    if TweenInfoObject then
        if not self.ActiveTweens[Ins] then self.ActiveTweens[Ins] = {} end
        local Tween = TweenService:Create(Ins, TweenInfoObject, {
            [PropertyName] = PropertyValue,
        })
        Tween:Play()
        self.ActiveTweens[Ins][PropertyName] = Tween
    else
        Ins[PropertyName] = PropertyValue
    end
end

--[[
Sets the offset of the joint.
--]]
function JointOffset.SetOffset(self: JointOffset, Offset: CFrame, TweenInfoObject: TweenInfo?): ()
    if self.JointType == "Motor6D" then
        self:SetProperty(self.Motor, "C0", self.AttachmentCFrame * Offset, TweenInfoObject)
    elseif self.JointType == "AnimationConstraint" and self.StartAttachment then
        self:SetProperty(self.StartAttachment, "CFrame", self.AttachmentCFrame * Offset, TweenInfoObject)
    end
end

--[[
Destorys the joint offset.
--]]
function JointOffset.Destroy(self: JointOffset): ()
    self.Destroyed = true

    --Clear the event connections.
    for _, EventConnection in self.EventConnections do
        EventConnection:Disconnect()
    end

    --Cancel the tweens.
    for _, Tweens in self.ActiveTweens do
        for _, Tween in Tweens do
            Tween:Cancel()
        end
    end
    self.ActiveTweens = {}

    --Reset the offiset.
    if self.Motor:IsA("Motor6D") then
        self.Motor.C0 = self.AttachmentCFrame
    elseif self.Motor:IsA("AnimationConstraint") and self.StartAttachment then
        self.StartAttachment.CFrame = self.AttachmentCFrame
    end
end



return JointOffset]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4A54CE0E11734F06B712D994CAFB9353">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Limb</string>
						<string name="ScriptGuid">{E95BEF1E-A996-4833-A745-6FFBE72C0F02}</string>
						<ProtectedString name="Source"><![CDATA[--Base class for a limb.
--!strict

local Limb = {}
Limb.__index = Limb

export type Limb = typeof(setmetatable({}, Limb))



--[[
Creates a limb object.
--]]
function Limb.new(): Limb
    return setmetatable({}, Limb) :: Limb
end

--[[
Returns the CFrame of an attachment.
Returns an empty CFrame if the attachment
does not exist.
--]]
function Limb.GetAttachmentCFrame(self: Limb, Part: BasePart, AttachmentName: string): CFrame
    local Attachment = Part:FindFirstChild(AttachmentName) :: Attachment
    return Attachment and Attachment.CFrame or CFrame.identity
end



return Limb]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX381EE4B6250148A68D5604B13E86C4A8">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">NexusBufferedReplication</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX267BB84484994B8D8119F1834E527101">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Receiver</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA5118C548914467D872E860E0CC6C51C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BufferedRemoteEventReceiver</string>
							<string name="ScriptGuid">{C1A0B9E0-9B2D-4219-B262-7CCC0964EEFB}</string>
							<ProtectedString name="Source"><![CDATA[--Reads buffered requests from the server.
--!strict

local BufferedRemoteEventReceiver = {}
BufferedRemoteEventReceiver.__index = BufferedRemoteEventReceiver

export type BufferedRemoteEventReceiver<TKey, TData> = {
    RemoteEvent: UnreliableRemoteEvent | RemoteEvent,
    DeserializeMessages: (buffer) -> ({[TKey]: TData}),
    OnDataReceivedCallbacks: {(Key: TKey, Data: TData) -> ()},
    EventConnections: {RBXScriptConnection},
} & typeof(setmetatable({}, BufferedRemoteEventReceiver))



--[[
Creates a buffered RemoteEvent receiver.
--]]
function BufferedRemoteEventReceiver.new<TKey, TData>(RemoteEvent: UnreliableRemoteEvent | RemoteEvent, DeserializeMessages: (buffer) -> ({[TKey]: TData})): BufferedRemoteEventReceiver<TKey, TData>
    return setmetatable({
        RemoteEvent = RemoteEvent,
        DeserializeMessages = DeserializeMessages,
        OnDataReceivedCallbacks = {},
        EventConnections = {},
    }, BufferedRemoteEventReceiver) :: BufferedRemoteEventReceiver<TKey, TData>
end

--[[
Connects data being sent from the server.
--]]
function BufferedRemoteEventReceiver.OnDataReceived<TKey, TData>(self: BufferedRemoteEventReceiver<TKey, TData>, Callback: (Key: TKey, Data: TData) -> ()): ()
    --Add the callback.
    table.insert(self.OnDataReceivedCallbacks, Callback)

    --Connect events from the server if it hasn't been connected yet.
    if #self.OnDataReceivedCallbacks > 1 then return end
    table.insert(self.EventConnections, (self.RemoteEvent :: UnreliableRemoteEvent).OnClientEvent:Connect(function(Buffer: buffer)
        for Key, Data in self.DeserializeMessages(Buffer) do
            for _, OnDataReceivedCallback in self.OnDataReceivedCallbacks do
                task.spawn(OnDataReceivedCallback, Key, Data)
            end
        end
    end))
end

--[[
Destroys the buffered RemoteEvent receiver.
--]]
function BufferedRemoteEventReceiver.Destroy<TKey, TData>(self: BufferedRemoteEventReceiver<TKey, TData>): ()
    for _, EventConnection in self.EventConnections do
        EventConnection:Disconnect()
    end
    self.EventConnections = {}
    self.OnDataReceivedCallbacks = {}
end



return BufferedRemoteEventReceiver]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX9A179AFC5B6340E6AD513583BEAAFA8D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PlayerBufferedRemoteEventReceiver</string>
							<string name="ScriptGuid">{9123CE0A-7CB0-492B-8448-01297CAB6E9B}</string>
							<ProtectedString name="Source"><![CDATA[--Wraps BufferedRemoteEventReceiver for players.
--!strict

local BufferedRemoteEventReceiver = require(script.Parent:WaitForChild("BufferedRemoteEventReceiver"))

local PlayerBufferedRemoteEventReceiver = {}
PlayerBufferedRemoteEventReceiver.Players = game:GetService("Players")
PlayerBufferedRemoteEventReceiver.__index = PlayerBufferedRemoteEventReceiver

export type PlayerBufferedRemoteEventReceiver<TData> = {
    PlayerUserIdLookup: {[number]: Player},
    BufferedRemoteEventReceiver: BufferedRemoteEventReceiver.BufferedRemoteEventReceiver<number, TData>,
} & typeof(setmetatable({}, PlayerBufferedRemoteEventReceiver))



--[[
Creates a player buffered RemoteEvent receiver.
--]]
function PlayerBufferedRemoteEventReceiver.new<TData>(RemoteEvent: UnreliableRemoteEvent | RemoteEvent, DeserializeMessages: (buffer) -> ({[number]: TData})): PlayerBufferedRemoteEventReceiver<TData>
    --Create the object.
    local PlayerUserIdLookup = {}
    local self = setmetatable({
        PlayerUserIdLookup = PlayerUserIdLookup,
        BufferedRemoteEventReceiver = BufferedRemoteEventReceiver.new(RemoteEvent, DeserializeMessages),
    }, PlayerBufferedRemoteEventReceiver) :: PlayerBufferedRemoteEventReceiver<TData>
    
    --Create the player user id lookup.
    for _, Player in PlayerBufferedRemoteEventReceiver.Players:GetPlayers() do
        PlayerUserIdLookup[Player.UserId] = Player
    end
    table.insert(self.BufferedRemoteEventReceiver.EventConnections, PlayerBufferedRemoteEventReceiver.Players.PlayerAdded:Connect(function(Player)
        PlayerUserIdLookup[Player.UserId] = Player
    end))
    table.insert(self.BufferedRemoteEventReceiver.EventConnections, PlayerBufferedRemoteEventReceiver.Players.PlayerRemoving:Connect(function(Player)
        PlayerUserIdLookup[Player.UserId] = nil
    end))
    
    --Return the object.
    return self
end

--[[
Connects data being sent from the server.
--]]
function PlayerBufferedRemoteEventReceiver.OnDataReceived<TData>(self: PlayerBufferedRemoteEventReceiver<TData>, Callback: (Player: Player, Data: TData) -> ()): ()
    self.BufferedRemoteEventReceiver:OnDataReceived(function(UserId: number, Data: TData)
        local Player = self.PlayerUserIdLookup[UserId]
        if not Player then return end
        Callback(Player, Data)
    end)
end

--[[
Destroys the player buffered RemoteEvent receiver.
--]]
function PlayerBufferedRemoteEventReceiver.Destroy<TData>(self: PlayerBufferedRemoteEventReceiver<TData>): ()
    self.BufferedRemoteEventReceiver:Destroy()
end



return PlayerBufferedRemoteEventReceiver]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX9B53512161E042438C5876635EA63585">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Sender</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX55701706F6EE4BE4BCD982304F704BB0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BufferedRemoteEventSender</string>
							<string name="ScriptGuid">{02EC8D90-268F-4934-A883-D729ACFE1ABF}</string>
							<ProtectedString name="Source"><![CDATA[--Buffers requests to be sent to the client.
--!strict

local DEFAULT_MAX_REQUEST_SIZE = 900

local BufferedRemoteEventSender = {}
BufferedRemoteEventSender.__index = BufferedRemoteEventSender

export type BufferedRemoteEvent = {
    FireAllClients: (self: BufferedRemoteEvent, ...any) -> (),
    [any]: any,
} | UnreliableRemoteEvent | RemoteEvent
export type BufferedRemoteEventSender<TKey, TData> = {
    MaxRequestSize: number,
    QueuedData: {[TKey]: TData},
    RemoteEvent: BufferedRemoteEvent,
    SerializeMessage: (Key: TKey, Data: TData) -> (buffer),
    SendingActive: boolean,
} & typeof(setmetatable({}, BufferedRemoteEventSender))



--[[
Creates a buffered RemoteEvent sender.
--]]
function BufferedRemoteEventSender.new<TKey, TData>(RemoteEvent: BufferedRemoteEvent, SerializeMessage: (Key: TKey, Data: TData) -> (buffer)): BufferedRemoteEventSender<TKey, TData>
    return setmetatable({
        MaxRequestSize = DEFAULT_MAX_REQUEST_SIZE,
        QueuedData = {},
        RemoteEvent = RemoteEvent,
        SerializeMessage = SerializeMessage,
        SendingActive = true,
    }, BufferedRemoteEventSender) :: BufferedRemoteEventSender<TKey, TData>
end

--[[
Creates a buffered RemoteEvent sender with player keys.
--]]
function BufferedRemoteEventSender.WithPlayerKeys<TData>(RemoteEvent: BufferedRemoteEvent, SerializeMessage: (Data: TData) -> (buffer)): BufferedRemoteEventSender<Player, TData>
    return BufferedRemoteEventSender.new(RemoteEvent, function(Player: Player, Data: TData)
        local Buffer = SerializeMessage(Data)
        local NewBuffer = buffer.create(8 + buffer.len(Buffer))
        buffer.writef64(NewBuffer, 0, Player.UserId)
        buffer.copy(NewBuffer, 8, Buffer)
        return NewBuffer
    end)
end

--[[
Queues data to send to clients.
If there was previous data that was queued but not sent for the key, the previous request will be dropped.
--]]
function BufferedRemoteEventSender.QueueData<TKey, TData>(self: BufferedRemoteEventSender<TKey, TData>, Key: TKey, Data: TData): ()
    self.QueuedData[Key] = Data
end

--[[
Sends the queued data to the clients.
--]]
function BufferedRemoteEventSender.SendQueuedData<TKey, TData>(self: BufferedRemoteEventSender<TKey, TData>): ()
    --Get the data to send and clear it for new data to be queued.
    local QueuedData = self.QueuedData
    self.QueuedData = {}

    --Convert the queued data into individual buffers.
    --Drop buffers that are too long.
    local QueuedDataBufferGroups = {
        {
            Buffers = {},
            CurrentLength = 0,
        },
    }
    local MaxRequestSize = self.MaxRequestSize
    for Key, Data in QueuedData do
        --Serialize the data and warn if the data is too long.
        local BufferedData = self.SerializeMessage(Key, Data)
        local BufferLength = buffer.len(BufferedData)
        if BufferLength > self.MaxRequestSize then
            warn(`Data was serialzied for key {Key} and was too long ({BufferLength} > {MaxRequestSize}). The data will be dropped.`)
            continue
        end

        --Add the buffer.
        local LastGroup = QueuedDataBufferGroups[#QueuedDataBufferGroups]
        local LastGroupNewLength = LastGroup.CurrentLength + BufferLength
        if LastGroupNewLength > MaxRequestSize then
            table.insert(QueuedDataBufferGroups, {
                Buffers = {BufferedData},
                CurrentLength = BufferLength,
            })
        else
            table.insert(LastGroup.Buffers, BufferedData)
            LastGroup.CurrentLength = LastGroupNewLength
        end
    end

    --Combine the buffers and send them.
    for _, BufferGroup in QueuedDataBufferGroups do
        if BufferGroup.CurrentLength == 0 then return end
        local BufferToSend = buffer.create(BufferGroup.CurrentLength)
        local CurrentOffset = 0
        for _, Buffer in BufferGroup.Buffers do
            buffer.copy(BufferToSend, CurrentOffset, Buffer)
            CurrentOffset += buffer.len(Buffer)
        end
        (self.RemoteEvent :: UnreliableRemoteEvent):FireAllClients(BufferToSend)
    end
end

--[[
Starts sending data in the background with a delay function.
--]]
function BufferedRemoteEventSender.StartDataSending<TKey, TData>(self: BufferedRemoteEventSender<TKey, TData>, DelayFunction: () -> ()): ()
    task.spawn(function()
        while self.SendingActive do
            self:SendQueuedData()
            DelayFunction()
        end
    end)
end

--[[
Starts sending data in the background with a wait delay.
--]]
function BufferedRemoteEventSender.StartDataSendingWithDelay<TKey, TData>(self: BufferedRemoteEventSender<TKey, TData>, Delay: number): ()
    self:StartDataSending(function()
        task.wait(Delay)
    end)
end

--[[
Starts sending data in the background with an event delay.
--]]
function BufferedRemoteEventSender.StartDataSendingWithEvent<TKey, TData>(self: BufferedRemoteEventSender<TKey, TData>, Event: RBXScriptSignal): ()
    self:StartDataSending(function()
        Event:Wait()
    end)
end

--[[
Destroys the buffered RemoteEvent sender.
--]]
function BufferedRemoteEventSender.Destroy<TKey, TData>(self: BufferedRemoteEventSender<TKey, TData>): ()
    self.SendingActive = false
end



return BufferedRemoteEventSender]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC18D73ECDC7F47EEAEB85227A978D360">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">EnrollableRemoteEvent</string>
							<string name="ScriptGuid">{8D431BA8-53C5-4CD4-BCA8-CF21A49FFC93}</string>
							<ProtectedString name="Source"><![CDATA[--Sends RemoteEvent events to players "enrolled" in the event.
--This is intended to prevent sending requests to players that haven't loaded yet, such as modules loaded in using require-by-id.

local EnrollableRemoteEvent = {}
EnrollableRemoteEvent.Players = game:GetService("Players")
EnrollableRemoteEvent.__index = EnrollableRemoteEvent

export type EnrollableRemoteEvent = {
    RemoteEvent: UnreliableRemoteEvent | RemoteEvent,
    TotalPlayers: number,
    EnrolledPlayers: {Player},
    EventConnections: {RBXScriptConnection},
} & typeof(setmetatable({}, EnrollableRemoteEvent))



--[[
Creates an enrollable RemoteEvent.
--]]
function EnrollableRemoteEvent.new(RemoteEvent: UnreliableRemoteEvent | RemoteEvent): EnrollableRemoteEvent
    --Create the object.
    local self = setmetatable({
        RemoteEvent = RemoteEvent,
        TotalPlayers = #EnrollableRemoteEvent.Players:GetPlayers(),
        EnrolledPlayers = {},
        EventConnections = {},
    }, EnrollableRemoteEvent) :: EnrollableRemoteEvent

    --Update player counts.
    table.insert(self.EventConnections, EnrollableRemoteEvent.Players.PlayerAdded:Connect(function()
        self.TotalPlayers = #EnrollableRemoteEvent.Players:GetPlayers()
    end))
    table.insert(self.EventConnections, EnrollableRemoteEvent.Players.PlayerRemoving:Connect(function(Player)
        self.TotalPlayers = #EnrollableRemoteEvent.Players:GetPlayers()
        self:UnenrollPlayer(Player)
    end))

    --Return the object.
    return self
end

--[[
Enrolls a player in receiving data.
--]]
function EnrollableRemoteEvent.EnrollPlayer(self: EnrollableRemoteEvent, Player: Player): ()
    if table.find(self.EnrolledPlayers, Player) then return end
    table.insert(self.EnrolledPlayers, Player)
end

--[[
Unenrolls a player from receiving data.
--]]
function EnrollableRemoteEvent.UnenrollPlayer(self: EnrollableRemoteEvent, Player: Player): ()
    local Index = table.find(self.EnrolledPlayers, Player)
    if not Index then return end
    table.remove(self.EnrolledPlayers, Index)
end

--[[
Sends data to all the enrolled players.
--]]
function EnrollableRemoteEvent.FireAllClients(self: EnrollableRemoteEvent, ...: any): ()
    --Return if there is no enrolled players.
    local TotalEnrolledPlayers = #self.EnrolledPlayers
    if #self.EnrolledPlayers == 0 then return end

    --Send the data.
    local RemoteEvent = (self.RemoteEvent :: UnreliableRemoteEvent)
    if TotalEnrolledPlayers == self.TotalPlayers then
        --Send the data to all players.
        RemoteEvent:FireAllClients(...)
    else
        --Send the data to only the enrolled players.
        for _, Player in self.EnrolledPlayers do
            RemoteEvent:FireClient(Player, ...)
        end
    end
end

--[[
Destroys the enrollable RemoteEvent.
--]]
function EnrollableRemoteEvent.Destroy(self: EnrollableRemoteEvent): ()
    for _, EventConnection in self.EventConnections do
        EventConnection:Disconnect()
    end
    self.EventConnections = {}
end



return EnrollableRemoteEvent]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX47238CE09B0945FCBAF332C91EDA71C4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NexusButton</string>
					<string name="ScriptGuid">{0237F96D-8475-4903-9C0B-E9204FC0AF82}</string>
					<ProtectedString name="Source"><![CDATA[--Main module representing the button class. This button is meant to provide
--an easy way to make "good looking", cross platform buttons.
--!strict

local HOVER_COLOR_MULTIPLIER = 0.7
local PRESS_COLOR_MULTIPLIER = 1 / 0.7
local CONTROLLER_SECTION_THEME_MINIMUM_ASPECT_RATIO = 1.2
local CONTROLLER_SECTION_COLOR = Color3.fromRGB(50, 50, 50)

local GuiService = game:GetService("GuiService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local NexusInstance = require(script:WaitForChild("NexusInstance"))
local ControllerIcon = require(script:WaitForChild("ControllerIcon"))
local SimpleWrappedInstance = require(script:WaitForChild("SimpleWrappedInstance"))
local ThemedFrame = require(script:WaitForChild("ThemedFrame"))

local NexusButton = {}
NexusButton.Themes = ThemedFrame.Themes
NexusButton.__index = NexusButton
setmetatable(NexusButton, SimpleWrappedInstance)

export type NexusButton = {
    Theme: string,
    BorderSize: UDim,
    BorderSizeScale: number,
    TweenDuration: number,
    BorderTransparency: number,
    ContentsAdorn: Frame,
    MouseButton1Down: NexusInstance.TypedEvent<number, number>,
    MouseButton1Up: NexusInstance.TypedEvent<number, number>,
    MouseButton1Click: NexusInstance.TypedEvent<>,
    MouseButton2Down: NexusInstance.TypedEvent<number, number>,
    MouseButton2Up: NexusInstance.TypedEvent<number, number>,
    MouseButton2Click: NexusInstance.TypedEvent<>,

    BackgroundFrame: ThemedFrame.NexusInstanceThemedFrame,
    BorderFrame: ThemedFrame.NexusInstanceThemedFrame,
    GamepadIcon: ControllerIcon.NexusInstanceControllerIcon,
    Hovering: boolean,
    Pressed: boolean,
    MappedInputs: {[Enum.KeyCode]: Enum.UserInputType},
    EventConnections: {RBXScriptConnection},
} & typeof(setmetatable({}, NexusButton)) & SimpleWrappedInstance.SimpleWrappedInstance<TextButton>
export type NexusInstanceNexusButton = NexusInstance.NexusInstance<NexusButton>



--[[
Multiplies a Color3.
--]]
local function MultiplyColor3(Color: Color3, Multiplier: number): Color3
    return Color3.new(math.clamp(Color.R * Multiplier, 0, 1), math.clamp(Color.G * Multiplier, 0, 1), math.clamp(Color.B * Multiplier, 0, 1))
end

--[[
Creates a Nexus Button object.
--]]
function NexusButton.__new(self: NexusInstanceNexusButton): ()
    SimpleWrappedInstance.__new(self, Instance.new("TextButton"))

    --Create the frames.
    local BaseButton = self:GetWrappedInstance()
    BaseButton.BackgroundTransparency = 1
    BaseButton.Text = ""

    local BorderFrame = ThemedFrame.new()
    BorderFrame.Parent = BaseButton
    self:DisableChangeReplication("BorderFrame")
    self.BorderFrame = BorderFrame

    local BackgroundFrame = ThemedFrame.new()
    BackgroundFrame.Size = UDim2.new(1, 0, 1, 0)
    BackgroundFrame.ZIndex = 2
    BackgroundFrame.Parent = BaseButton
    self:DisableChangeReplication("BackgroundFrame")
    self.BackgroundFrame = BackgroundFrame

    BackgroundFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
        self:UpdateBorder(false)
    end)

    local ContentsAdorn = Instance.new("Frame")
    ContentsAdorn.BackgroundTransparency = 1
    ContentsAdorn.Size = UDim2.new(1, 0, 1, 0)
    ContentsAdorn.ZIndex = 3
    ContentsAdorn.Parent = BaseButton
    self:DisableChangeReplication("ContentsAdorn")
    self.ContentsAdorn = ContentsAdorn

    local GamepadIcon = ControllerIcon.new()
    GamepadIcon.BackgroundColor3 = CONTROLLER_SECTION_COLOR
    GamepadIcon.Size = UDim2.new(1, 0, 1, 0)
    GamepadIcon.Position = UDim2.new(1, 0, 0, 0)
    GamepadIcon.SizeConstraint = Enum.SizeConstraint.RelativeYY
    GamepadIcon.AnchorPoint = Vector2.new(1, 0)
    GamepadIcon.ZIndex = 4
    GamepadIcon.Parent = BaseButton
    self:DisableChangeReplication("GamepadIcon")
    self.GamepadIcon = GamepadIcon

    --Prepare the wrapped events.
    self:DisableChangeReplication("MouseButton1Down")
    self.MouseButton1Down = self:CreateEvent() :: any
    self:GetWrappedInstance().MouseButton1Down:Connect(function(...)
        self.MouseButton1Down:Fire(...)
    end)
    self:DisableChangeReplication("MouseButton1Up")
    self.MouseButton1Up = self:CreateEvent()  :: any
    self:GetWrappedInstance().MouseButton1Up:Connect(function(...)
        self.MouseButton1Up:Fire(...)
    end)
    self:DisableChangeReplication("MouseButton1Click")
    self.MouseButton1Click = self:CreateEvent()  :: any
    self:GetWrappedInstance().MouseButton1Click:Connect(function()
        self.MouseButton1Click:Fire()
    end)
    self:DisableChangeReplication("MouseButton2Down")
    self.MouseButton2Down = self:CreateEvent()  :: any
    self:GetWrappedInstance().MouseButton2Down:Connect(function(...)
        self.MouseButton2Down:Fire(...)
    end)
    self:DisableChangeReplication("MouseButton2Up")
    self.MouseButton2Up = self:CreateEvent()  :: any
    self:GetWrappedInstance().MouseButton2Up:Connect(function(...)
        self.MouseButton2Up:Fire(...)
    end)
    self:DisableChangeReplication("MouseButton2Click")
    self.MouseButton2Click = self:CreateEvent() :: any
    self:GetWrappedInstance().MouseButton2Click:Connect(function()
        self.MouseButton2Click:Fire()
    end)

    --Set the replication overrides.
    self:DisableChangeReplication("TweenDuration")
    self:DisableChangeReplication("BackgroundColor3")
    self:OnPropertyChanged("BackgroundColor3", function()
        self:UpdateBorder(false)
    end)
    self:DisableChangeReplication("BackgroundTransparency")
    self:OnPropertyChanged("BackgroundTransparency", function(NewBackgroundTransparency: number)
        BackgroundFrame.BackgroundTransparency = NewBackgroundTransparency
    end)
    self:DisableChangeReplication("BorderSize")
    self:OnPropertyChanged("BorderSize", function()
        self:UpdateBorder(false)
    end)
    self:DisableChangeReplication("BorderSizePixel")
    self:OnPropertyChanged("BorderSizePixel", function(NewBorderSizePixel: number)
        self.BorderSize = UDim.new(0, NewBorderSizePixel)
    end)
    self:DisableChangeReplication("BorderSizeScale")
    self:OnPropertyChanged("BorderSizeScale", function(NewBorderSizeScale: number)
        self.BorderSize = UDim.new(NewBorderSizeScale, 0)
    end)
    self:DisableChangeReplication("BorderColor3")
    self:OnPropertyChanged("BorderColor3", function()
        self:UpdateBorder(false)
    end)
    self:DisableChangeReplication("BorderColor3")
    self:OnPropertyChanged("AutoButtonColor", function()
        self:UpdateBorder(false)
    end)
    self:DisableChangeReplication("BorderTransparency")
    self:OnPropertyChanged("BorderTransparency", function(NewBorderTransparency: number)
        BorderFrame.BackgroundTransparency = NewBorderTransparency
    end)
    self:DisableChangeReplication("Hovering")
    self:OnPropertyChanged("Hovering", function()
        self:UpdateBorder(true)
    end)
    self:DisableChangeReplication("Pressed")
    self:OnPropertyChanged("Pressed", function()
        self:UpdateBorder(true)
    end)
    self:DisableChangeReplication("Theme")
    self:OnPropertyChanged("Theme", function(NewTheme: string)
        BackgroundFrame.Theme = self.Theme
        BorderFrame.Theme = self.Theme
        GamepadIcon.Theme = self.Theme
    end)

    --Connect the events.
    self:DisableChangeReplication("MappedInputs")
    self.MappedInputs = {}
    self:DisableChangeReplication("EventConnections")
    self.EventConnections = {}
    self.MouseEnter:Connect(function()
        self.Hovering = true
    end)
    self.MouseLeave:Connect(function()
        self.Hovering = false
    end)
    self.MouseButton1Down:Connect(function()
        self.Pressed = true
    end)
    self.MouseButton1Up:Connect(function()
        self.Pressed = false
    end)
    table.insert(self.EventConnections, GuiService:GetPropertyChangedSignal("SelectedObject"):Connect(function()
        self:UpdateBorder(true)
    end))
    table.insert(self.EventConnections, UserInputService.InputBegan:Connect(function(Input, Processed)
        if Processed and (GuiService.SelectedObject ~= self:GetWrappedInstance() or Input.KeyCode == Enum.KeyCode.ButtonA) then return end
        if self.Pressed then return end
        if not self.MappedInputs[Input.KeyCode] then return end

        local MouseInput = self.MappedInputs[Input.KeyCode]
        local CenterPosition = self.AbsolutePosition + (self.AbsoluteSize / 2)
        if MouseInput == Enum.UserInputType.MouseButton1 then
            self.MouseButton1Down:Fire(CenterPosition.X, CenterPosition.Y)
        elseif MouseInput == Enum.UserInputType.MouseButton2 then
            self.MouseButton2Down:Fire(CenterPosition.X, CenterPosition.Y)
        end
    end))
    table.insert(self.EventConnections, UserInputService.InputEnded:Connect(function(Input)
        if not self.Pressed then return end
        if not self.MappedInputs[Input.KeyCode] then return end

        local MouseInput = self.MappedInputs[Input.KeyCode]
        local CenterPosition = self.AbsolutePosition + (self.AbsoluteSize / 2)
        if MouseInput == Enum.UserInputType.MouseButton1 then
            self.MouseButton1Up:Fire(CenterPosition.X, CenterPosition.Y)
            self.MouseButton1Click:Fire()
        elseif MouseInput == Enum.UserInputType.MouseButton2 then
            self.MouseButton2Up:Fire(CenterPosition.X, CenterPosition.Y)
            self.MouseButton2Click:Fire()
        end
    end))
    table.insert(self.EventConnections, UserInputService.InputEnded:Connect(function(Input)
        if not self.Pressed then return end
        if Input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
        self.Pressed = false
    end))

    --Set the defaults.
    self.Size = UDim2.new(0, 200, 0, 50)
    self.BackgroundColor3 = Color3.fromRGB(204, 204, 204)
    self.BackgroundTransparency = 0
    self.BorderSize = UDim.new(0.15, 0)
    self.BorderColor3 = Color3.fromRGB(0, 0, 0)
    self.BorderTransparency = 0
    self.AutoButtonColor = true
    self.Hovering = false
    self.Pressed = false
    self.TweenDuration = 0.1
    self.Theme = "CutCorners"
end

--[[
Updates the background and border properties.
--]]
function NexusButton.UpdateBorder(self: NexusInstanceNexusButton, Tween: boolean?): ()
    --Get the border size.
    if not self.BorderSize then return end
    if not self.Theme then return end
    local ButtonSize = self.BackgroundFrame.AbsoluteSize
    local ButtonSizeY = ButtonSize.Y
    local BorderSize = (ButtonSizeY * self.BorderSize.Scale) + self.BorderSize.Offset
    local BackgroundColor3 = self.BackgroundColor3
    local BorderColor3 = self.BorderColor3

    --Modify the properties.
    if self.AutoButtonColor ~= false then
        if self.Pressed then
            BackgroundColor3 = MultiplyColor3(BackgroundColor3, PRESS_COLOR_MULTIPLIER)
            BorderColor3 = MultiplyColor3(BorderColor3, PRESS_COLOR_MULTIPLIER)
            BorderSize = BorderSize * 0.25
        elseif self.Hovering or GuiService.SelectedObject == self:GetWrappedInstance() then
            BackgroundColor3 = MultiplyColor3(BackgroundColor3, HOVER_COLOR_MULTIPLIER)
            BorderColor3 = MultiplyColor3(BorderColor3, HOVER_COLOR_MULTIPLIER)
            BorderSize = BorderSize * 0.75
        end
    end

    --Apply the properties.
    if Tween and self.TweenDuration and self.TweenDuration > 0 then
        TweenService:Create(self.BackgroundFrame:GetWrappedInstance(), TweenInfo.new(self.TweenDuration), {
            ImageColor3 = BackgroundColor3,
        }):Play()
        TweenService:Create(self.BorderFrame:GetWrappedInstance(), TweenInfo.new(self.TweenDuration), {
            ImageColor3 = BorderColor3,
            Size = UDim2.new(1, 0, 1, BorderSize),
        }):Play()
    else
        self.BackgroundFrame.ImageColor3 = BackgroundColor3
        self.BorderFrame.ImageColor3 = BorderColor3
        self.BorderFrame.Size = UDim2.new(1, 0, 1, BorderSize)
    end
    self.GamepadIcon.SubTheme = (((ButtonSize.X / ButtonSize.Y) < CONTROLLER_SECTION_THEME_MINIMUM_ASPECT_RATIO) and "MainButton" or "GamepadIconBackground") :: ThemedFrame.SubTheme
end

--[[
Returns the adorn frame to parent frames to the button.
--]]
function NexusButton.GetAdornFrame(self: NexusInstanceNexusButton): Frame
    return self.ContentsAdorn
end

--[[
Sets the controller icon for the button.
--]]
function NexusButton.SetControllerIcon(self: NexusInstanceNexusButton, KeyCode: Enum.KeyCode | string): ()
    self.GamepadIcon:SetIcon(KeyCode)
end

--[[
Maps a key input to a mouse input for clicking.
--]]
function NexusButton.MapKey(self: NexusInstanceNexusButton, KeyCode: Enum.KeyCode | string, MouseInput: Enum.UserInputType | string): ()
    --Correct the inputs.
    if typeof(KeyCode) == "string" then
        KeyCode = (Enum.KeyCode :: any)[KeyCode]
    end
    if typeof(MouseInput) == "string" then
        MouseInput = (Enum.UserInputType :: any)[MouseInput]
    end

    --Throw an error if the mouse input is invalid.
    if MouseInput ~= Enum.UserInputType.MouseButton1 and MouseInput ~= Enum.UserInputType.MouseButton2 then
        error("Mouse input must be either MouseButton1 or MouseButton2.")
    end

    --Store the mapped input.
    self.MappedInputs[KeyCode :: Enum.KeyCode] = MouseInput :: Enum.UserInputType
end

--[[
Unmaps a key input to a mouse input for clicking.
--]]
function NexusButton.UnmapKey(self: NexusInstanceNexusButton, KeyCode: Enum.KeyCode | string): ()
    --Correct the input.
    if typeof(KeyCode) == "string" then
        KeyCode = (Enum.KeyCode :: any)[KeyCode]
    end

    --Remove the mapped input.
    self.MappedInputs[KeyCode :: Enum.KeyCode] = nil
end

--[[
Destroys the button and disconnects the events.
--]]
function NexusButton.Destroy(self: NexusInstanceNexusButton): ()
    SimpleWrappedInstance.Destroy(self)
    self.GamepadIcon:Destroy()

    --Disconnect the events.
    for _, EventConnection in self.EventConnections do
        EventConnection:Disconnect()
    end
    self.EventConnections = {}
end



return NexusInstance.ToInstance(NexusButton) :: NexusInstance.NexusInstanceClass<typeof(NexusButton), () -> (NexusInstanceNexusButton)>]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX50000DFC3EB44EBA908819E0DDDC5850">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ControllerIcon</string>
						<string name="ScriptGuid">{76943562-8CEC-48BE-ADD1-DBF808D43EEB}</string>
						<ProtectedString name="Source"><![CDATA[--Class representing a controller icon.
--!strict

local BASE_ICON_SIZE_RELATIVE = 0.9
local XBOX_SPRITESHEET = "rbxassetid://408444495"
local PLAYSTATION_SPRITESHEET = "rbxassetid://15530886548"

export type IconProperties = {
	Image: string,
	Size: Vector2,
	Offset: Vector2,
	Color: Color3?,
}

local GAMEPAD_ICONS = {
    Xbox = {
        ButtonA = {
            Image = XBOX_SPRITESHEET,
            Size = Vector2.new(95, 95),
            Offset = Vector2.new(318, 416),
        },
        ButtonB = {
            Image = XBOX_SPRITESHEET,
            Size = Vector2.new(95, 95),
            Offset = Vector2.new(520, 522),
        },
        ButtonX = {
            Image = XBOX_SPRITESHEET,
            Size = Vector2.new(95, 95),
            Offset = Vector2.new(510, 416),
        },
        ButtonY = {
            Image = XBOX_SPRITESHEET,
            Size = Vector2.new(95, 95),
            Offset = Vector2.new(616, 318),
        },
        DPadUp = {
            Image = XBOX_SPRITESHEET,
            Size =  Vector2.new(105, 105),
            Offset = Vector2.new(616, 530),
        },
        DPadDown = {
            Image = XBOX_SPRITESHEET,
            Size = Vector2.new(105, 105),
            Offset = Vector2.new(212, 522),
        },
        DPadLeft = {
            Image = XBOX_SPRITESHEET,
            Size =  Vector2.new(105, 105),
            Offset = Vector2.new(318, 522),
        },
        DPadRight = {
            Image = XBOX_SPRITESHEET,
            Size =  Vector2.new(105, 105),
            Offset = Vector2.new(212, 416),
        },
        ButtonSelect = {
            Image = XBOX_SPRITESHEET,
            Size = Vector2.new(95, 95),
            Offset = Vector2.new(424, 522),
        },
        ButtonLB = {
            Image = XBOX_SPRITESHEET,
            Size = Vector2.new(115, 64),
            Offset = Vector2.new(116, 628),
        },
        ButtonRB = {
            Image = XBOX_SPRITESHEET,
            Size = Vector2.new(115, 64),
            Offset = Vector2.new(0, 628),
        },
        ButtonLT = {
            Image = XBOX_SPRITESHEET,
            Size = Vector2.new(105, 115),
            Offset = Vector2.new(616, 0),
        },
        ButtonRT = {
            Image = XBOX_SPRITESHEET,
            Size = Vector2.new(105, 115),
            Offset = Vector2.new(616, 414),
        },
        ButtonLS = {
            Image = XBOX_SPRITESHEET,
            Size = Vector2.new(105, 105),
            Offset = Vector2.new(0, 522),
        },
        ButtonRS = {
            Image = XBOX_SPRITESHEET,
            Size = Vector2.new(105, 105),
            Offset = Vector2.new(0, 416),
        },
        Thumbstick1 = {
            Image = XBOX_SPRITESHEET,
            Size = Vector2.new(105, 105),
            Offset = Vector2.new(616, 116),
        },
        Thumbstick2 = {
            Image = XBOX_SPRITESHEET,
            Size = Vector2.new(105, 105),
            Offset = Vector2.new(106, 522),
        },
    },
    PlayStation = {
        ButtonCross = {
            Image = PLAYSTATION_SPRITESHEET,
            Size = Vector2.new(58, 58),
            Offset = Vector2.new(0, 0),
        },
        ButtonCircle = {
            Image = PLAYSTATION_SPRITESHEET,
            Size = Vector2.new(58, 58),
            Offset = Vector2.new(58, 0),
        },
        ButtonSquare = {
            Image = PLAYSTATION_SPRITESHEET,
            Size = Vector2.new(58, 58),
            Offset = Vector2.new(116, 0),
        },
        ButtonTriangle = {
            Image = PLAYSTATION_SPRITESHEET,
            Size = Vector2.new(58, 58),
            Offset = Vector2.new(0, 58),
        },
        ButtonL1 = {
            Image = PLAYSTATION_SPRITESHEET,
            Size = Vector2.new(58, 58),
            Offset = Vector2.new(58, 58),
        },
        ButtonR1 = {
            Image = PLAYSTATION_SPRITESHEET,
            Size = Vector2.new(58, 58),
            Offset = Vector2.new(116, 58),
        },
        ButtonL2 = {
            Image = PLAYSTATION_SPRITESHEET,
            Size = Vector2.new(58, 58),
            Offset = Vector2.new(0, 116),
        },
        ButtonR2 = {
            Image = PLAYSTATION_SPRITESHEET,
            Size = Vector2.new(58, 58),
            Offset = Vector2.new(58, 116),
        },
        ButtonTouchpad = {
            Image = PLAYSTATION_SPRITESHEET,
            Size = Vector2.new(58, 58),
            Offset = Vector2.new(116, 116),
        },
    },
} :: {[string]: {[string]: IconProperties}}
GAMEPAD_ICONS.Default = GAMEPAD_ICONS.Xbox
GAMEPAD_ICONS.Default.ButtonL1 = GAMEPAD_ICONS.Xbox.ButtonLB
GAMEPAD_ICONS.Default.ButtonR1 = GAMEPAD_ICONS.Xbox.ButtonRB
GAMEPAD_ICONS.Default.ButtonL2 = GAMEPAD_ICONS.Xbox.ButtonLT
GAMEPAD_ICONS.Default.ButtonR2 = GAMEPAD_ICONS.Xbox.ButtonRT
GAMEPAD_ICONS.Default.ButtonL3 = GAMEPAD_ICONS.Xbox.ButtonLS
GAMEPAD_ICONS.Default.ButtonR3 = GAMEPAD_ICONS.Xbox.ButtonRS



local UserInputService = game:GetService("UserInputService")

local NexusInstance = require(script.Parent:WaitForChild("NexusInstance"))
local ThemedFrame = require(script.Parent:WaitForChild("ThemedFrame"))
local SimpleWrappedInstance = require(script.Parent:WaitForChild("SimpleWrappedInstance"))

local ControllerIcon = {}
ControllerIcon.__index = ControllerIcon
setmetatable(ControllerIcon, ThemedFrame)

local WarnedPlatformNames = {}

export type ControllerIcon = {
    IconScale: number,
    Icon: ImageLabel?,
    IconUIScale: UIScale?,
    IconVisible: boolean,
    KeyCode: Enum.KeyCode?,
    EventConnections: {RBXScriptConnection},
} & typeof(setmetatable({}, ControllerIcon)) & ThemedFrame.ThemedFrame
export type NexusInstanceControllerIcon = NexusInstance.NexusInstance<ControllerIcon>



--[[
Resolves the gamepad image properties for a KeyCode.
--]]
function ControllerIcon.ResolveImage(KeyCode: Enum.KeyCode): IconProperties
	--Get the name and fallback image.
	local PlatformKeyCodeName = UserInputService:GetStringForKeyCode(KeyCode)
	local FallbackImage = UserInputService:GetImageForKeyCode(KeyCode)

	--Return if a group matches.
	for GroupName, Images in GAMEPAD_ICONS do
		if not string.find(string.lower(FallbackImage), string.lower(GroupName)) then continue end
		if not Images[PlatformKeyCodeName] then continue end
		return Images[PlatformKeyCodeName]
	end

	--Return if the default exists.
	if GAMEPAD_ICONS.Default[PlatformKeyCodeName] then
		return GAMEPAD_ICONS.Default[PlatformKeyCodeName]
	end

	--Return the fallback case.
	if not WarnedPlatformNames[PlatformKeyCodeName] then
		warn(`No override exists for {PlatformKeyCodeName} (from {KeyCode.Name}) with {FallbackImage}. Returning default image.`)
		WarnedPlatformNames[PlatformKeyCodeName] = true
	end
	return {
		Image = FallbackImage,
		Size = Vector2.zero,
		Offset = Vector2.zero,
		Color = Color3.fromRGB(60, 60, 60),
	}
end

--[[
Constructor of the Controller Icon class.
--]]
function ControllerIcon.__new(self: NexusInstanceControllerIcon)
    ThemedFrame.__new(self)

    --Prepare the properties.
    self.SubTheme = "GamepadIconBackground"
    self:DisableChangeReplication("IconScale")
    self.IconScale = BASE_ICON_SIZE_RELATIVE
    self:DisableChangeReplication("Icon")
    self:DisableChangeReplication("IconUIScale")
    self:DisableChangeReplication("KeyCode")

    --Connect the events.
    self:DisableChangeReplication("EventConnections")
    self.EventConnections = {}
    table.insert(self.EventConnections, UserInputService.GamepadConnected:Connect(function()
        self:UpdateVisibility()
    end))
    table.insert(self.EventConnections, UserInputService.GamepadDisconnected:Connect(function()
        self:UpdateVisibility()
    end))

    --Update the visibility.
    self:DisableChangeReplication("IconVisible")
    self.IconVisible = false
    self:UpdateVisibility()
end

--[[
Updates the visibility of the icon.
--]]
function ControllerIcon.UpdateVisibility(self: NexusInstanceControllerIcon): ()
    --Set the visibility to false if there is no icon.
    if not self.Icon then
        self.Visible = false
        self.IconVisible = false
        return
    end

    --Determine if a controller is connected.
    local ControllerConnected = (#UserInputService:GetConnectedGamepads() ~= 0)

    --Set the visibility.
    self.Visible = ControllerConnected
    self.IconVisible = ControllerConnected
end

--[[
Sets the icon.
--]]
function ControllerIcon.SetIcon(self: NexusInstanceControllerIcon, KeyCode: Enum.KeyCode | string?): ()
    --Return if the KeyCode is nil.
    if KeyCode == nil then
        self.KeyCode = nil
        if self.Icon then
            self.Icon:Destroy()
            self.Icon = nil
        end
        self:UpdateVisibility()
        return
    end

    --Covert the KeyCode from a string.
    if type(KeyCode) == "string" then
        KeyCode = (Enum.KeyCode :: any)[KeyCode]
    end

    --Destroy the existing icon.
    if self.Icon then
        self.Icon:Destroy()
    end

    --Create the new icon.
    local IconData = self.ResolveImage(KeyCode :: Enum.KeyCode)
    local Icon = Instance.new("ImageLabel")
    Icon.BackgroundTransparency = 1
    Icon.AnchorPoint = Vector2.new(0.5, 0.5)
    Icon.Position = UDim2.new(0.5, 0, 0.5, 0)
    if IconData.Size.X > IconData.Size.Y then
        Icon.Size = UDim2.new(1, 0, IconData.Size.Y / IconData.Size.X, 0)
    elseif IconData.Size.X < IconData.Size.Y then
        Icon.Size = UDim2.new(IconData.Size.X / IconData.Size.Y, 0, 1, 0)
    else
        Icon.Size = UDim2.new(1, 0, 1, 0)
    end
    Icon.ZIndex = self.ZIndex
    Icon.Image = IconData.Image
    Icon.ImageRectSize = IconData.Size
    Icon.ImageRectOffset = IconData.Offset
    Icon.ImageColor3 = IconData.Color or Color3.fromRGB(255, 255, 255)
    Icon.Parent = self:GetWrappedInstance()

    local IconUIScale = Instance.new("UIScale")
    IconUIScale.Scale = self.IconScale or 1
    IconUIScale.Parent = Icon
    self.IconUIScale = IconUIScale

    self.Icon = Icon
    self.KeyCode = KeyCode :: Enum.KeyCode
    self:UpdateVisibility()
end

--[[
Sets the scale of the icon.
--]]
function ControllerIcon.SetScale(self: NexusInstanceControllerIcon, NewScale: number): ()
    self.IconScale = NewScale
    if self.IconUIScale then
        self.IconUIScale.Scale = NewScale
    end
end

--[[
Destroys the frame.
--]]
function ControllerIcon.Destroy(self: NexusInstanceControllerIcon): ()
    SimpleWrappedInstance.Destroy(self)

    --Disconnect the events.
    for _, EventConnection in self.EventConnections do
        EventConnection:Disconnect()
    end
    self.EventConnections = {}
end



return NexusInstance.ToInstance(ControllerIcon) :: NexusInstance.NexusInstanceClass<typeof(ControllerIcon), () -> (NexusInstanceControllerIcon)>]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX3122AF22120A476CB2145E47E5512E9B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Factory</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX2F18A7C99ADE4C9BBE3231EE24478F9D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ButtonFactory</string>
							<string name="ScriptGuid">{811478A8-B8AD-499F-9FAA-771F9134923D}</string>
							<ProtectedString name="Source"><![CDATA[--"Factory" for creating buttons. Used to be able to set defaults once.
--!strict

local BORDER_COLOR_OFFSET = Color3.fromRGB(-30, -30, -30)

local NexusButton = require(script.Parent.Parent)

local ButtonFactory = {}
ButtonFactory.__index = ButtonFactory

export type ButtonFactory = {
    Defaults: {[string]: any}
} & typeof(setmetatable({}, ButtonFactory))



--[[
Adds two Color3s.
--]]
function ButtonFactory.AddColor3(Color1: Color3, Color2: Color3): Color3
    return Color3.new(math.clamp(Color1.R + Color2.R, 0, 1), math.clamp(Color1.G + Color2.G, 0, 1), math.clamp(Color1.B + Color2.B, 0, 1))
end

--[[
Creates a button factory with the default style.
This is used by Nexus Development projects.
--]]
function ButtonFactory.CreateDefault(Color: Color3): ButtonFactory
    --Create the factory.
    local Factory = ButtonFactory.new()

    --Set the defaults.
    Factory:SetDefault("BackgroundColor3", Color)
    Factory:SetDefault("BorderColor3", ButtonFactory.AddColor3(Color, BORDER_COLOR_OFFSET))
    Factory:SetDefault("BorderTransparency", 0.25)

    --Return the factory.
    return Factory
end

--[[
Creates a button factory.
--]]
function ButtonFactory.new(): ButtonFactory
    return setmetatable({
        Defaults = {}
    }, ButtonFactory) :: ButtonFactory
end

--[[
Creates a button instance.
--]]
function ButtonFactory.Create(self: ButtonFactory): NexusButton.NexusInstanceNexusButton
    --Create the button.
    local Button = NexusButton.new()

    --Set the defaults.
    for PropertyName,PropertyValue in self.Defaults do
        (Button :: any)[PropertyName] = PropertyValue
    end

    --Return the button.
    return Button
end

--[[
Sets a default property.
--]]
function ButtonFactory.SetDefault(self: ButtonFactory, PropertyName: string, Property: any): ()
    self.Defaults[PropertyName] = Property
end

--[[
Unsets a default property.
--]]
function ButtonFactory.UnsetDefault(self: ButtonFactory, PropertyName: string): ()
    self.Defaults[PropertyName] = nil
end



return ButtonFactory]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX89134036890C4A109DB4ABF383615A9E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TextButtonFactory</string>
							<string name="ScriptGuid">{35ADD344-47F3-42D7-AE28-75B77B91CE04}</string>
							<ProtectedString name="Source"><![CDATA[--"Factory" for creating text buttons. Used to be able to set defaults once.
--!strict

local BORDER_COLOR_OFFSET = Color3.fromRGB(-30, -30, -30)

local NexusButton = require(script.Parent.Parent)
local ButtonFactory = require(script.Parent:WaitForChild("ButtonFactory"))

local TextButtonFactory = {}
TextButtonFactory.__index = TextButtonFactory
setmetatable(TextButtonFactory, ButtonFactory)

export type TextButtonFactory = {
    TextDefaults: {[string]: any},
} & typeof(setmetatable({}, TextButtonFactory)) & ButtonFactory.ButtonFactory



--[[
Creates a text button factory with the default
style. This is used by Nexus Development projects.
--]]
function TextButtonFactory.CreateDefault(Color: Color3): TextButtonFactory
    --Create the factory.
    local Factory = TextButtonFactory.new()

    --Set the defaults.
    Factory:SetDefault("BackgroundColor3", Color)
    Factory:SetDefault("BorderColor3", ButtonFactory.AddColor3(Color, BORDER_COLOR_OFFSET))
    Factory:SetDefault("BorderTransparency", 0.25)
    Factory:SetTextDefault("Font", Enum.Font.SourceSans)
    Factory:SetTextDefault("TextColor3", Color3.fromRGB(255, 255, 255))
    Factory:SetTextDefault("TextStrokeColor3", Color3.fromRGB(0, 0, 0))
    Factory:SetTextDefault("TextStrokeTransparency", 0)
    Factory:SetTextDefault("TextScaled", true)

    --Return the factory.
    return Factory
end

--[[
Creates a text button factory.
--]]
function TextButtonFactory.new(): TextButtonFactory
    local self = setmetatable(ButtonFactory.new(), TextButtonFactory) :: TextButtonFactory
    self.TextDefaults = {}
    return self
end

--[[
Creates a text button instance.
--]]
function TextButtonFactory.Create(self: TextButtonFactory): (NexusButton.NexusButton, TextLabel)
    --Create the button.
    local Button = ButtonFactory.Create(self)

    --Add a text label.
    local TextLabel = Instance.new("TextLabel")
    TextLabel.Size = UDim2.new(1, 0, 1, 0)
    TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    TextLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
    TextLabel.BackgroundTransparency = 1
    TextLabel.ZIndex = 5
    TextLabel.Parent = Button:GetAdornFrame()

    --Set the text defaults.
    for PropertyName,PropertyValue in self.TextDefaults do
        (TextLabel :: any)[PropertyName] = PropertyValue
    end

    --Return the button and textlabel.
    return Button, TextLabel
end

--[[
Sets a default text property.
--]]
function TextButtonFactory.SetTextDefault(self: TextButtonFactory, PropertyName: string, Property: any): ()
    self.TextDefaults[PropertyName] = Property
end

--[[
Unsets a default text property.
--]]
function TextButtonFactory.UnsetTextDefault(self: TextButtonFactory, PropertyName: string): ()
    self.TextDefaults[PropertyName] = nil
end



return TextButtonFactory]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXFFC9F3A224CD431D8B25D0768DFC2FBE">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SimpleWrappedInstance</string>
						<string name="ScriptGuid">{0279D472-873C-4817-A4C9-DE3F09E4BF13}</string>
						<ProtectedString name="Source"><![CDATA[--Simple instance wrapper for getting and setting instance values.
--!strict

local NexusInstance = require(script.Parent:WaitForChild("NexusInstance"))

local SimpleWrappedInstance = {}
SimpleWrappedInstance.__index = SimpleWrappedInstance

export type SimpleWrappedInstance<T> = {
    WrappedInstance: T,
    DisabledReplicationProperties: {[string]: boolean},
} & typeof(setmetatable({}, SimpleWrappedInstance)) & T
export type NexusInstanceSimpleWrappedInstance<T> = NexusInstance.NexusInstance<SimpleWrappedInstance<T>>



--[[
Creates a simple wrapped instance.
--]]
function SimpleWrappedInstance.__new<T>(self: NexusInstanceSimpleWrappedInstance<T>, WrappedInstance: T): ()
    --Store the wrapped instance.
    local DisabledReplicationProperties = {}
    self.WrappedInstance = WrappedInstance
    self.DisabledReplicationProperties = DisabledReplicationProperties

    --Modify __index.
    local Metatable = getmetatable(self) :: any
    local OriginalIndex = Metatable.__index
    Metatable.__index = function(self, Index: any): any
        --Return the object's value.
        local ObjectValue = OriginalIndex(self, Index)
        if ObjectValue ~= nil then
            return ObjectValue
        end

        --Return the instance's value.
        if DisabledReplicationProperties[Index] then return nil end
        local InstanceValue = (WrappedInstance :: any)[Index]
        if typeof(InstanceValue) == "function" then
            return function(_, ...)
                return InstanceValue(WrappedInstance, ...)
            end
        end
        return InstanceValue
    end

    --Replicate changes.
    self:OnAnyPropertyChanged(function(PropertyName, Value)
        if DisabledReplicationProperties[PropertyName] then return end
        (WrappedInstance :: any)[PropertyName] = Value
    end)
    if typeof(WrappedInstance) == "Instance" then
        WrappedInstance.Changed:Connect(function(PropertyName)
            if DisabledReplicationProperties[PropertyName] then return end

            --Replicate the change back if the object has a set value.
            local ObjectValue = OriginalIndex(self, PropertyName)
            if ObjectValue ~= nil then
                (self :: any)[PropertyName] = (WrappedInstance :: any)[PropertyName]
                return
            end

            --Fire the changed events.
            self.Changed:Fire(PropertyName)
            local PropertyChangedEvent = self.PropertyChangedEvents[PropertyName]
            if PropertyChangedEvent then
                PropertyChangedEvent:Fire()
            end
        end)
    end
end

--[[
Disables changes being replicated to the wrapped
instance for a specific property.
--]]
function SimpleWrappedInstance.DisableChangeReplication<T>(self: NexusInstanceSimpleWrappedInstance<T>, PropertyName: string): ()
    self.DisabledReplicationProperties[PropertyName] = true
end

--[[
Returns the wrapped instance.
--]]
function SimpleWrappedInstance.GetWrappedInstance<T>(self: NexusInstanceSimpleWrappedInstance<T>): T
    return self.WrappedInstance
end

--[[
Destroys the wrapped instance.
--]]
function SimpleWrappedInstance.Destroy<T>(self: NexusInstanceSimpleWrappedInstance<T>): ()
    if typeof(self.WrappedInstance) ~= "Instance" then return end
    self.WrappedInstance:Destroy()
end



return NexusInstance.ToInstance(SimpleWrappedInstance) :: NexusInstance.NexusInstanceClass<typeof(SimpleWrappedInstance), <T>(WrappedInstance: T) -> (NexusInstanceSimpleWrappedInstance<T>)>]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX72B43B2C7463441EB1E00C3FDBE736F6">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ThemedFrame</string>
						<string name="ScriptGuid">{69D24DCA-94E4-4390-93DB-4E822695873B}</string>
						<ProtectedString name="Source"><![CDATA[--Frame that has the same theming for the buttons.
--!strict

local DEFAULT_THEMES = {
    CutCorners = {
        MainButton = {
            Image = "rbxassetid://76476290918578",
            SliceCenter = Rect.new(32, 32, 34, 34),
            SliceScaleMultiplier = 0.2 / 32,
        },
        GamepadIconBackground = {
            Image = "rbxassetid://135976734207422",
            SliceCenter = Rect.new(32, 32, 34, 34),
            SliceScaleMultiplier = 0.2 / 32,
        },
    },
    CutTopLeftCorner = {
        MainButton = {
            Image = "rbxassetid://127204475432575",
            SliceCenter = Rect.new(32, 32, 34, 34),
            SliceScaleMultiplier = 0.2 / 32,
        },
        GamepadIconBackground = {
            Image = "rbxassetid://95201075795195",
            SliceCenter = Rect.new(32, 32, 34, 34),
            SliceScaleMultiplier = 0.2 / 32,
        },
    },
    CutBottomRightCorner = {
        MainButton = {
            Image = "rbxassetid://135976734207422",
            SliceCenter = Rect.new(32, 32, 34, 34),
            SliceScaleMultiplier = 0.2 / 32,
        },
        GamepadIconBackground = {
            Image = "rbxassetid://135976734207422",
            SliceCenter = Rect.new(32, 32, 34, 34),
            SliceScaleMultiplier = 0.2 / 32,
        },
    },
    RoundedCorners = {
        MainButton = {
            Image = "rbxassetid://136205699446611",
            SliceCenter = Rect.new(32, 32, 34, 34),
            SliceScaleMultiplier = 0.2 / 32,
        },
        GamepadIconBackground = {
            Image = "rbxassetid://98913835358317",
            SliceCenter = Rect.new(32, 32, 34, 34),
            SliceScaleMultiplier = 0.2 / 32,
        },
    },
} :: {[string]: NexusButtonTheme}

local NexusInstance = require(script.Parent:WaitForChild("NexusInstance"))
local SimpleWrappedInstance = require(script.Parent:WaitForChild("SimpleWrappedInstance"))

local ThemedFrame = {}
ThemedFrame.Themes = DEFAULT_THEMES
ThemedFrame.__index = ThemedFrame
setmetatable(ThemedFrame, SimpleWrappedInstance)

export type SubTheme = "MainButton" | "GamepadIconBackground"
export type NexusButtonThemeEntry = {
    Image: string,
    SliceCenter: Rect,
    SliceScaleMultiplier: number,
}
export type NexusButtonTheme = {
    MainButton: NexusButtonThemeEntry,
    GamepadIconBackground: NexusButtonThemeEntry,
}
export type ThemedFrame = {
    Theme: string,
    SubTheme: SubTheme,
    SliceScaleMultiplier: number,
} & typeof(setmetatable({}, ThemedFrame)) & SimpleWrappedInstance.SimpleWrappedInstance<ImageLabel>
export type NexusInstanceThemedFrame = NexusInstance.NexusInstance<ThemedFrame>



--[[
Creates the themed frame.
--]]
function ThemedFrame.__new(self: NexusInstanceThemedFrame)
    SimpleWrappedInstance.__new(self, Instance.new("ImageLabel"))
    self:GetWrappedInstance().BackgroundTransparency = 1

    --Set the initial them.
    self:DisableChangeReplication("Theme")
    self.Theme = "CutCorners"
    self:DisableChangeReplication("SubTheme")
    self.SubTheme = "MainButton"

    --Connect property changes.
    self:DisableChangeReplication("BackgroundColor3")
    self:OnPropertyChanged("BackgroundColor3", function(NewBackgroundColor3: Color3)
        self.ImageColor3 = NewBackgroundColor3
    end)
    self:DisableChangeReplication("BackgroundTransparency")
    self:OnPropertyChanged("BackgroundTransparency", function(NewBackgroundTransparency: number)
        self.ImageTransparency = NewBackgroundTransparency
    end)
    self:DisableChangeReplication("SliceScaleMultiplier")
    self:OnPropertyChanged("SliceScaleMultiplier", function()
        self:UpdateSliceScale()
    end)
    self:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
        self:UpdateSliceScale()
    end)

    --Connect changing the theme.
    self:OnPropertyChanged("Theme", function()
        self:UpdateTheme()
    end)
    self:OnPropertyChanged("SubTheme", function()
        self:UpdateTheme()
    end)

    --Set the defaults.
    self.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.BackgroundTransparency = 0
    self.ScaleType = Enum.ScaleType.Slice
    self.SliceScaleMultiplier = 1
    self.Size = UDim2.new(0, 100, 0, 100)
    self:UpdateTheme()
end

--[[
Updates the slice scale of the frame.
--]]
function ThemedFrame.UpdateSliceScale(self: NexusInstanceThemedFrame): ()
    local ThemeEntry = ThemedFrame.Themes[self.Theme][self.SubTheme]
    self.SliceScale = math.min(self.AbsoluteSize.X, self.AbsoluteSize.Y) * ThemeEntry.SliceScaleMultiplier * (self.SliceScaleMultiplier or 1)
end

--[[
Updates the theme of the frame.
--]]
function ThemedFrame.UpdateTheme(self: NexusInstanceThemedFrame): ()
    --Get the theme.
    local Theme = ThemedFrame.Themes[self.Theme]
    if not Theme then
        error(`Unknown theme: {self.Theme}`)
    end
    local ThemeEntry = Theme[self.SubTheme]
    if not ThemeEntry then
        error(`Unknown subtheme: {self.SubTheme}`)
    end

    --Update the theme.
    self.Image = ThemeEntry.Image
    self.SliceCenter = ThemeEntry.SliceCenter
    self:UpdateSliceScale()
end



return NexusInstance.ToInstance(ThemedFrame) :: NexusInstance.NexusInstanceClass<typeof(ThemedFrame), () -> (NexusInstanceThemedFrame)>]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX0AFA8411DFF148E0BBCB5FF0FFA8A31C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NexusInstance</string>
						<string name="ScriptGuid">{B7CC470F-BDCC-4391-A5C4-C0DB7221EA49}</string>
						<ProtectedString name="Source"><![CDATA[--Main module for Nexus Instance.
--!strict

local METATABLE_METHODS = {
    "__call",
    "__concat",
    "__unm",
    "__add",
    "__sub",
    "__mul",
    "__div",
    "__idiv",
    "__mod",
    "__pow",
    "__tostring",
    "__eq",
    "__lt",
    "__le",
    "__gc",
    "__len",
    "__iter",
}

local TypedEvent = require(script:WaitForChild("Event"):WaitForChild("TypedEvent"))

local NexusInstance = {}

export type TypedEvent<T...> = TypedEvent.TypedEvent<T...>

export type NexusInstanceClass<TClass, TConstructor> = {
    new: TConstructor
} & TClass

export type NexusInstance<TObject> = {
    Changed: TypedEvent<string>,
    BaseClass: any,
    Events: {TypedEvent<unknown>},
    TransformFunctions: {(Index: any, Value: any) -> (any)},
    PropertyTransformFunctions: {[string]: {(Value: any) -> (any)}},
    OnAnyPropertyChangedFunctions: {(PropertyName: any, Value: any) -> ()},
    OnPropertyChangedFunctions: {[string]: {(Value: any) -> ()}},
    HiddenPropertyChanges: {[string]: boolean},
    HiddenNextPropertyChanges: {[string]: boolean},
    PropertyChangedEvents: {[string]: TypedEvent<>},
} & typeof(NexusInstance) & TObject



--[[
Creates an instance version of the given class.
--]]
function NexusInstance.ToInstance<TClass, TConstructor>(Class: TClass): NexusInstanceClass<TClass, TConstructor>
    --Add the constructor.
    local ExtendedClass = (Class :: any) :: NexusInstanceClass<TClass, TConstructor>
    ExtendedClass.new = (function(...)
        --Prepare the object.
        local ChangedEvent = (TypedEvent.new() :: any) :: TypedEvent<string>
        local Properties = {}
        local TransformFunctions = {} :: {(Index: any, Value: any) -> (any)}
        local PropertyTransformFunctions = {} :: {[string]: {(Value: any) -> (any)}}
        local OnAnyPropertyChangedFunctions = {} :: {(PropertyName: any, Value: any) -> ()}
        local OnPropertyChangedFunctions = {} :: {[string]: {(Value: any) -> ()}}
        local HiddenPropertyChanges = {} :: {[string]: boolean}
        local HiddenNextPropertyChanges = {} :: {[string]: boolean}
        local PropertyChangedEvents = {} :: {[string]: TypedEvent<>}

        --Create the object.
        local Object = {
            Changed = ChangedEvent,
            BaseClass = Class,
            Events = {ChangedEvent},
            TransformFunctions = TransformFunctions,
            PropertyTransformFunctions = PropertyTransformFunctions,
            OnAnyPropertyChangedFunctions = OnAnyPropertyChangedFunctions,
            OnPropertyChangedFunctions = OnPropertyChangedFunctions,
            HiddenPropertyChanges = HiddenPropertyChanges,
            HiddenNextPropertyChanges = HiddenNextPropertyChanges,
            PropertyChangedEvents = PropertyChangedEvents,
        }
        local Metatable = {
            __index = function(_, Index: string): any?
                --Return the property.
                local PropertyValue = Properties[Index]
                if PropertyValue ~= nil then
                    return PropertyValue 
                end

                --Return the NexusInstance value.
                local NexusInstanceValue = (NexusInstance :: any)[Index]
                if NexusInstanceValue ~= nil then
                    return NexusInstanceValue
                end

                --Return the class's value.
                return (Class :: any)[Index]
            end,
            __newindex = function(self: any, Index: string, Value: any): ()
                --Perform the transform functions.
                for _, TransformFunction in TransformFunctions do
                    Value = TransformFunction(Index, Value)
                end
                if PropertyTransformFunctions[Index] then
                    for _, TransformFunction in PropertyTransformFunctions[Index] do
                        Value = TransformFunction(Value)
                    end
                end

                --Return if the new and old values are the same.
                if self[Index] == Value then
                    return
                end

                --Change the property.
                Properties[Index] = Value

                --Invoke that the property has changed.
                for _, ChangedCallback in OnAnyPropertyChangedFunctions do
                    ChangedCallback(Index, Value)
                end
                local PropertyChangedCallbacks = OnPropertyChangedFunctions[Index]
                if PropertyChangedCallbacks then
                    for _, ChangedCallback in PropertyChangedCallbacks do
                        ChangedCallback(Value)
                    end
                end

                --Return if the property is hidden.
                if HiddenNextPropertyChanges[Index] then
                    HiddenNextPropertyChanges[Index] = nil
                    return
                end
                if HiddenPropertyChanges[Index] then
                    return
                end

                --Invoke the changed event.
                self.Changed:Fire(Index)
                local PropertyChangedEvent = PropertyChangedEvents[Index]
                if PropertyChangedEvent then
                    PropertyChangedEvent:Fire()
                end
            end,
        }
        for _, MetatableMethod in METATABLE_METHODS do
            (Metatable :: any)[MetatableMethod] = (Class :: any)[MetatableMethod] 
        end
        local self = setmetatable(Object, Metatable)

        --Call the __new constructor of the class.
        local Constructor = (Class :: any).__new
        if Constructor then
            Constructor(self, ...)
        end

        --Return the object.
        return self
    end :: any) :: TConstructor
    
    --Return the extended class.
    return ExtendedClass 
end

--[[
Creates an event that is disconnected when the instance is destroyed.
--]]
function NexusInstance.CreateEvent<T, TEventArguments...>(self: NexusInstance<T>): TypedEvent<TEventArguments...>
    local NewEvent = TypedEvent.new() :: TypedEvent<TEventArguments...>
    table.insert(self.Events, NewEvent :: any)
    return NewEvent
end

--[[
Adds a generic property transformer.
--]]
function NexusInstance.AddGenericPropertyTransform<T>(self: NexusInstance<T>, Transform: (Index: any, Value: any) -> (any)): ()
    table.insert(self.TransformFunctions, Transform)
end

--[[
Adds a property transformer for a specific property.
--]]
function NexusInstance.AddPropertyTransform<T>(self: NexusInstance<T>, PropertyName: any, Transform: (Value: any) -> (any)): ()
    if not self.PropertyTransformFunctions[PropertyName] then
        self.PropertyTransformFunctions[PropertyName] = {}
    end
    table.insert(self.PropertyTransformFunctions[PropertyName], Transform)
end

--[[
Adds a callback when a property is changed.
This invokes immediately as opposed to using events.
--]]
function NexusInstance.OnAnyPropertyChanged<T>(self: NexusInstance<T>, Callback: (PropertyName: any, Value: any) -> ()): ()
    table.insert(self.OnAnyPropertyChangedFunctions, Callback)
end

--[[
Adds a callback when the given property is changed.
This invokes immediately as opposed to using events.
--]]
function NexusInstance.OnPropertyChanged<T>(self: NexusInstance<T>, PropertyName: string, Callback: (Value: any) -> ()): ()
    if not self.OnPropertyChangedFunctions[PropertyName] then
        self.OnPropertyChangedFunctions[PropertyName] = {}
    end
    table.insert(self.OnPropertyChangedFunctions[PropertyName], Callback)
end

--[[
Hides all changed events for a property.
--]]
function NexusInstance.HidePropertyChanges<T>(self: NexusInstance<T>, PropertyName: string): ()
    self.HiddenPropertyChanges[PropertyName] = true
end

--[[
Hides the next changed events for a property.
--]]
function NexusInstance.HideNextPropertyChange<T>(self: NexusInstance<T>, PropertyName: string): ()
    self.HiddenNextPropertyChanges[PropertyName] = true
end

--[[
Returns an event for when a property is changed.
--]]
function NexusInstance.GetPropertyChangedSignal<T>(self: NexusInstance<T>, PropertyName: string): TypedEvent<>
    if not self.PropertyChangedEvents[PropertyName] then
        self.PropertyChangedEvents[PropertyName] = self:CreateEvent()
    end
    return self.PropertyChangedEvents[PropertyName]
end

--[[
Destroys the instance.
--]]
function NexusInstance.Destroy<T>(self: NexusInstance<T>): ()
    --Call the class's destroy event.
    local DestroyFunction = (self.BaseClass :: any).Destroy
    if DestroyFunction then
        DestroyFunction(self)
    end

    --Disconnect the events.
    task.defer(function()
        for _, Event in self.Events do
            (Event :: TypedEvent<unknown>):Destroy()
        end
        self.Events = {}
    end)
end



return NexusInstance]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX725A22184D6142FE9326103D42FFC8B5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Event</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX68AC12163C744E55937DCA87E0135F61">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TypedEvent</string>
								<string name="ScriptGuid">{06EA0A8F-2CD7-441A-9CB7-A81E21CB8089}</string>
								<ProtectedString name="Source"><![CDATA[--Typed event with support for table-based payloads.
--!strict

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local TypedEventConnection = require(script.Parent:WaitForChild("TypedEventConnection"))

local TypedEvent = {}
TypedEvent.LastArguments = {} :: {[string]: any}
TypedEvent.QueuedClearArguments = {} :: {[string]: boolean}
TypedEvent.__index = TypedEvent

export type TypedEvent<T...> = {
    BindableEvent: BindableEvent,
    Connections: {[TypedEventConnection.TypedEventConnection<T...>]: RBXScriptConnection},
    CurrentWaits: number,
} & typeof(setmetatable({}, TypedEvent))



--[[
Creates a typed event.
--]]
function TypedEvent.new<T...>(): TypedEvent<T...>
    --Create the object.
    local self = setmetatable({
        BindableEvent = Instance.new("BindableEvent"),
        Connections = {},
        CurrentWaits = 0
    }, TypedEvent) :: TypedEvent<T...>

    --Return the object.
    return self
end

--[[
Establishes a function to be called when the event fires.
Returns a connection object that can be disconnected.
--]]
function TypedEvent.Connect<T...>(self: TypedEvent<T...>, Callback: (T...) -> ()): TypedEventConnection.TypedEventConnection<T...>
    --Create the connection.
    local Connection = TypedEventConnection.new(self :: any, Callback)

    --Set up the bindable event.
    local BindableEventConnection = self.BindableEvent.Event:Connect(function(UUID)
        Connection:Fire(table.unpack(self.LastArguments[UUID]))
    end)

    --Store the connections.
    self.Connections[Connection] = BindableEventConnection

    --Return the connection.
    return Connection
end

--[[
Establishes a function to be called when the event fires.
Returns a connection object that can be disconnected.
However, instead of allowing multiple events to be received by the specified function,
only the first event will be delivered. Using Once also ensures that the connection to
the function will be automatically disconnected prior the function being called.
--]]
function TypedEvent.Once<T...>(self: TypedEvent<T...>, Callback: (T...) -> ()): ()
    local Connection = nil
    Connection = self:Connect(function(...)
        if Connection then
            Connection:Disconnect()
        end
        Callback(...)
    end)
end

--[[
Yields the current thread until the signal fires and returns the arguments provided by the signal.
--]]
function TypedEvent.Wait<T...>(self: TypedEvent<T...>): T...
    --Wait for the event.
    self.CurrentWaits = self.CurrentWaits + 1
    local UUID = self.BindableEvent.Event:Wait()
    self.CurrentWaits = self.CurrentWaits - 1

    --Return the arguments.
    return table.unpack(self.LastArguments[UUID])
end

--[[
Fires the event.
--]]
function TypedEvent.Fire<T...>(self: TypedEvent<T...>, ...: T...): ()
    --Ignore if there are no connections.
    if next(self.Connections) == nil and self.CurrentWaits <= 0 then return end

    --Store the arguments.
    --For deferred events, the arguments need to be stored.
    local UUID = HttpService:GenerateGUID()
    local Arguments = table.pack(...)
    self.LastArguments[UUID] = Arguments

    --Queue clearing the arguments.
    task.defer(function()
        TypedEvent.QueuedClearArguments[UUID] = true
    end)

    --Invoke the event.
    self.BindableEvent:Fire(UUID)
end

--[[
Handles an event being disconnected.
--]]
function TypedEvent.Disconnected<T...>(self: TypedEvent<T...>, Connection: TypedEventConnection.TypedEventConnection<T...>): ()
    if not self.Connections[Connection] then return end
    self.Connections[Connection]:Disconnect()
    self.Connections[Connection] = nil
end

--[[
Destroys the event.
--]]
function TypedEvent.Destroy<T...>(self: TypedEvent<T...>): ()
    local OriginalConnections = self.Connections
    self.Connections = {}
    self.CurrentWaits = 0
    for Connection, _ in OriginalConnections do
        (Connection :: TypedEventConnection.TypedEventConnection<T...>):Disconnect()
    end
    self.BindableEvent:Destroy()
end



--Clear arguments in the background.
RunService.Heartbeat:Connect(function()
    local QueuedClearArguments = TypedEvent.QueuedClearArguments
    TypedEvent.QueuedClearArguments = {}

    for Key, _ in QueuedClearArguments do
        TypedEvent.LastArguments[Key] = nil
    end
end)



return TypedEvent]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX642A181725AD43ABB9EF5B9CB01BFA19">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TypedEventConnection</string>
								<string name="ScriptGuid">{48F1BE0E-16F5-4C71-81CC-8F070FA60366}</string>
								<ProtectedString name="Source"><![CDATA[--Connection for a typed event.
--!strict

local TypedEventConnection = {}
TypedEventConnection.__index = TypedEventConnection

export type TypedEventStub<T...> = {
    Disconnected: (TypedEventStub<T...>, TypedEventConnection<T...>) -> (),
    [any]: any,
}

export type TypedEventConnection<T...> = {
    Connected: boolean,
    ParentEvent: TypedEventStub<T...>,
    ConnectionFunction: (T...) -> (),
} & typeof(setmetatable({}, TypedEventConnection))



--[[
Creates a connection.
--]]
function TypedEventConnection.new<T...>(ParentEvent: TypedEventStub<T...>, ConnectionFunction: (T...) -> ()): TypedEventConnection<T...>
    return setmetatable({
        Connected = true,
        ParentEvent = ParentEvent,
        ConnectionFunction = ConnectionFunction,
    }, TypedEventConnection) :: TypedEventConnection<T...>
end

--[[
Fires the connection.
--]]
function TypedEventConnection.Fire<T...>(self: TypedEventConnection<T...>, ...: T...): ()
    if not self.Connected then return end
    self.ConnectionFunction(...)
end

--[[
Disconnect the connection from the event.
--]]
function TypedEventConnection.Disconnect<T...>(self: TypedEventConnection<T...>): ()
    --Set the event as disconnected.
    if not self.Connected then return end
    self.Connected = false

    --Remove the connection.
    self.ParentEvent:Disconnected(self)
end

--[[
Destroys the connection.
--]]
function TypedEventConnection.Destroy<T...>(self: TypedEventConnection<T...>): ()
    self:Disconnect()
end



return TypedEventConnection]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXB4D312CB5A334B68A2DA0BA0AB0FF60E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NexusInstance</string>
					<string name="ScriptGuid">{0BF7638A-EF85-42E0-8635-200A593749EF}</string>
					<ProtectedString name="Source"><![CDATA[--Main module for Nexus Instance.
--!strict

local METATABLE_METHODS = {
    "__call",
    "__concat",
    "__unm",
    "__add",
    "__sub",
    "__mul",
    "__div",
    "__idiv",
    "__mod",
    "__pow",
    "__tostring",
    "__eq",
    "__lt",
    "__le",
    "__gc",
    "__len",
    "__iter",
}

local TypedEvent = require(script:WaitForChild("Event"):WaitForChild("TypedEvent"))

local NexusInstance = {}

export type TypedEvent<T...> = TypedEvent.TypedEvent<T...>

export type NexusInstanceClass<TClass, TConstructor> = {
    new: TConstructor
} & TClass

export type NexusInstance<TObject> = {
    Changed: TypedEvent<string>,
    BaseClass: any,
    Events: {TypedEvent<unknown>},
    TransformFunctions: {(Index: any, Value: any) -> (any)},
    PropertyTransformFunctions: {[string]: {(Value: any) -> (any)}},
    OnAnyPropertyChangedFunctions: {(PropertyName: any, Value: any) -> ()},
    OnPropertyChangedFunctions: {[string]: {(Value: any) -> ()}},
    HiddenPropertyChanges: {[string]: boolean},
    HiddenNextPropertyChanges: {[string]: boolean},
    PropertyChangedEvents: {[string]: TypedEvent<>},
} & typeof(NexusInstance) & TObject



--[[
Creates an instance version of the given class.
--]]
function NexusInstance.ToInstance<TClass, TConstructor>(Class: TClass): NexusInstanceClass<TClass, TConstructor>
    --Add the constructor.
    local ExtendedClass = (Class :: any) :: NexusInstanceClass<TClass, TConstructor>
    ExtendedClass.new = (function(...)
        --Prepare the object.
        local ChangedEvent = (TypedEvent.new() :: any) :: TypedEvent<string>
        local Properties = {}
        local TransformFunctions = {} :: {(Index: any, Value: any) -> (any)}
        local PropertyTransformFunctions = {} :: {[string]: {(Value: any) -> (any)}}
        local OnAnyPropertyChangedFunctions = {} :: {(PropertyName: any, Value: any) -> ()}
        local OnPropertyChangedFunctions = {} :: {[string]: {(Value: any) -> ()}}
        local HiddenPropertyChanges = {} :: {[string]: boolean}
        local HiddenNextPropertyChanges = {} :: {[string]: boolean}
        local PropertyChangedEvents = {} :: {[string]: TypedEvent<>}

        --Create the object.
        local Object = {
            Changed = ChangedEvent,
            BaseClass = Class,
            Events = {ChangedEvent},
            TransformFunctions = TransformFunctions,
            PropertyTransformFunctions = PropertyTransformFunctions,
            OnAnyPropertyChangedFunctions = OnAnyPropertyChangedFunctions,
            OnPropertyChangedFunctions = OnPropertyChangedFunctions,
            HiddenPropertyChanges = HiddenPropertyChanges,
            HiddenNextPropertyChanges = HiddenNextPropertyChanges,
            PropertyChangedEvents = PropertyChangedEvents,
        }
        local Metatable = {
            __index = function(_, Index: string): any?
                --Return the property.
                local PropertyValue = Properties[Index]
                if PropertyValue ~= nil then
                    return PropertyValue 
                end

                --Return the NexusInstance value.
                local NexusInstanceValue = (NexusInstance :: any)[Index]
                if NexusInstanceValue ~= nil then
                    return NexusInstanceValue
                end

                --Return the class's value.
                return (Class :: any)[Index]
            end,
            __newindex = function(self: any, Index: string, Value: any): ()
                --Perform the transform functions.
                for _, TransformFunction in TransformFunctions do
                    Value = TransformFunction(Index, Value)
                end
                if PropertyTransformFunctions[Index] then
                    for _, TransformFunction in PropertyTransformFunctions[Index] do
                        Value = TransformFunction(Value)
                    end
                end

                --Return if the new and old values are the same.
                if self[Index] == Value then
                    return
                end

                --Change the property.
                Properties[Index] = Value

                --Invoke that the property has changed.
                for _, ChangedCallback in OnAnyPropertyChangedFunctions do
                    ChangedCallback(Index, Value)
                end
                local PropertyChangedCallbacks = OnPropertyChangedFunctions[Index]
                if PropertyChangedCallbacks then
                    for _, ChangedCallback in PropertyChangedCallbacks do
                        ChangedCallback(Value)
                    end
                end

                --Return if the property is hidden.
                if HiddenNextPropertyChanges[Index] then
                    HiddenNextPropertyChanges[Index] = nil
                    return
                end
                if HiddenPropertyChanges[Index] then
                    return
                end

                --Invoke the changed event.
                self.Changed:Fire(Index)
                local PropertyChangedEvent = PropertyChangedEvents[Index]
                if PropertyChangedEvent then
                    PropertyChangedEvent:Fire()
                end
            end,
        }
        for _, MetatableMethod in METATABLE_METHODS do
            (Metatable :: any)[MetatableMethod] = (Class :: any)[MetatableMethod] 
        end
        local self = setmetatable(Object, Metatable)

        --Call the __new constructor of the class.
        local Constructor = (Class :: any).__new
        if Constructor then
            Constructor(self, ...)
        end

        --Return the object.
        return self
    end :: any) :: TConstructor
    
    --Return the extended class.
    return ExtendedClass 
end

--[[
Creates an event that is disconnected when the instance is destroyed.
--]]
function NexusInstance.CreateEvent<T, TEventArguments...>(self: NexusInstance<T>): TypedEvent<TEventArguments...>
    local NewEvent = TypedEvent.new() :: TypedEvent<TEventArguments...>
    table.insert(self.Events, NewEvent :: any)
    return NewEvent
end

--[[
Adds a generic property transformer.
--]]
function NexusInstance.AddGenericPropertyTransform<T>(self: NexusInstance<T>, Transform: (Index: any, Value: any) -> (any)): ()
    table.insert(self.TransformFunctions, Transform)
end

--[[
Adds a property transformer for a specific property.
--]]
function NexusInstance.AddPropertyTransform<T>(self: NexusInstance<T>, PropertyName: any, Transform: (Value: any) -> (any)): ()
    if not self.PropertyTransformFunctions[PropertyName] then
        self.PropertyTransformFunctions[PropertyName] = {}
    end
    table.insert(self.PropertyTransformFunctions[PropertyName], Transform)
end

--[[
Adds a callback when a property is changed.
This invokes immediately as opposed to using events.
--]]
function NexusInstance.OnAnyPropertyChanged<T>(self: NexusInstance<T>, Callback: (PropertyName: any, Value: any) -> ()): ()
    table.insert(self.OnAnyPropertyChangedFunctions, Callback)
end

--[[
Adds a callback when the given property is changed.
This invokes immediately as opposed to using events.
--]]
function NexusInstance.OnPropertyChanged<T>(self: NexusInstance<T>, PropertyName: string, Callback: (Value: any) -> ()): ()
    if not self.OnPropertyChangedFunctions[PropertyName] then
        self.OnPropertyChangedFunctions[PropertyName] = {}
    end
    table.insert(self.OnPropertyChangedFunctions[PropertyName], Callback)
end

--[[
Hides all changed events for a property.
--]]
function NexusInstance.HidePropertyChanges<T>(self: NexusInstance<T>, PropertyName: string): ()
    self.HiddenPropertyChanges[PropertyName] = true
end

--[[
Hides the next changed events for a property.
--]]
function NexusInstance.HideNextPropertyChange<T>(self: NexusInstance<T>, PropertyName: string): ()
    self.HiddenNextPropertyChanges[PropertyName] = true
end

--[[
Returns an event for when a property is changed.
--]]
function NexusInstance.GetPropertyChangedSignal<T>(self: NexusInstance<T>, PropertyName: string): TypedEvent<>
    if not self.PropertyChangedEvents[PropertyName] then
        self.PropertyChangedEvents[PropertyName] = self:CreateEvent()
    end
    return self.PropertyChangedEvents[PropertyName]
end

--[[
Destroys the instance.
--]]
function NexusInstance.Destroy<T>(self: NexusInstance<T>): ()
    --Call the class's destroy event.
    local DestroyFunction = (self.BaseClass :: any).Destroy
    if DestroyFunction then
        DestroyFunction(self)
    end

    --Disconnect the events.
    task.defer(function()
        for _, Event in self.Events do
            (Event :: TypedEvent<unknown>):Destroy()
        end
        self.Events = {}
    end)
end



return NexusInstance]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX1A3374BC242048BB8FFBEB105EF8FBAF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Event</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX393102FF2836466B9249B407595EC9D5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TypedEvent</string>
							<string name="ScriptGuid">{97828C58-2BFD-417B-AA8F-683B4A0B6496}</string>
							<ProtectedString name="Source"><![CDATA[--Typed event with support for table-based payloads.
--!strict

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local TypedEventConnection = require(script.Parent:WaitForChild("TypedEventConnection"))

local TypedEvent = {}
TypedEvent.LastArguments = {} :: {[string]: any}
TypedEvent.QueuedClearArguments = {} :: {[string]: boolean}
TypedEvent.__index = TypedEvent

export type TypedEvent<T...> = {
    BindableEvent: BindableEvent,
    Connections: {[TypedEventConnection.TypedEventConnection<T...>]: RBXScriptConnection},
    CurrentWaits: number,
} & typeof(setmetatable({}, TypedEvent))



--[[
Creates a typed event.
--]]
function TypedEvent.new<T...>(): TypedEvent<T...>
    --Create the object.
    local self = setmetatable({
        BindableEvent = Instance.new("BindableEvent"),
        Connections = {},
        CurrentWaits = 0
    }, TypedEvent) :: TypedEvent<T...>

    --Return the object.
    return self
end

--[[
Establishes a function to be called when the event fires.
Returns a connection object that can be disconnected.
--]]
function TypedEvent.Connect<T...>(self: TypedEvent<T...>, Callback: (T...) -> ()): TypedEventConnection.TypedEventConnection<T...>
    --Create the connection.
    local Connection = TypedEventConnection.new(self :: any, Callback)

    --Set up the bindable event.
    local BindableEventConnection = self.BindableEvent.Event:Connect(function(UUID)
        Connection:Fire(table.unpack(self.LastArguments[UUID]))
    end)

    --Store the connections.
    self.Connections[Connection] = BindableEventConnection

    --Return the connection.
    return Connection
end

--[[
Establishes a function to be called when the event fires.
Returns a connection object that can be disconnected.
However, instead of allowing multiple events to be received by the specified function,
only the first event will be delivered. Using Once also ensures that the connection to
the function will be automatically disconnected prior the function being called.
--]]
function TypedEvent.Once<T...>(self: TypedEvent<T...>, Callback: (T...) -> ()): ()
    local Connection = nil
    Connection = self:Connect(function(...)
        if Connection then
            Connection:Disconnect()
        end
        Callback(...)
    end)
end

--[[
Yields the current thread until the signal fires and returns the arguments provided by the signal.
--]]
function TypedEvent.Wait<T...>(self: TypedEvent<T...>): T...
    --Wait for the event.
    self.CurrentWaits = self.CurrentWaits + 1
    local UUID = self.BindableEvent.Event:Wait()
    self.CurrentWaits = self.CurrentWaits - 1

    --Return the arguments.
    return table.unpack(self.LastArguments[UUID])
end

--[[
Fires the event.
--]]
function TypedEvent.Fire<T...>(self: TypedEvent<T...>, ...: T...): ()
    --Ignore if there are no connections.
    if next(self.Connections) == nil and self.CurrentWaits <= 0 then return end

    --Store the arguments.
    --For deferred events, the arguments need to be stored.
    local UUID = HttpService:GenerateGUID()
    local Arguments = table.pack(...)
    self.LastArguments[UUID] = Arguments

    --Queue clearing the arguments.
    task.defer(function()
        TypedEvent.QueuedClearArguments[UUID] = true
    end)

    --Invoke the event.
    self.BindableEvent:Fire(UUID)
end

--[[
Handles an event being disconnected.
--]]
function TypedEvent.Disconnected<T...>(self: TypedEvent<T...>, Connection: TypedEventConnection.TypedEventConnection<T...>): ()
    if not self.Connections[Connection] then return end
    self.Connections[Connection]:Disconnect()
    self.Connections[Connection] = nil
end

--[[
Destroys the event.
--]]
function TypedEvent.Destroy<T...>(self: TypedEvent<T...>): ()
    local OriginalConnections = self.Connections
    self.Connections = {}
    self.CurrentWaits = 0
    for Connection, _ in OriginalConnections do
        (Connection :: TypedEventConnection.TypedEventConnection<T...>):Disconnect()
    end
    self.BindableEvent:Destroy()
end



--Clear arguments in the background.
RunService.Heartbeat:Connect(function()
    local QueuedClearArguments = TypedEvent.QueuedClearArguments
    TypedEvent.QueuedClearArguments = {}

    for Key, _ in QueuedClearArguments do
        TypedEvent.LastArguments[Key] = nil
    end
end)



return TypedEvent]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4D3A4E75DFBA48DFB9666437569418DD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TypedEventConnection</string>
							<string name="ScriptGuid">{F8606250-50FA-46E2-825A-48DE96877763}</string>
							<ProtectedString name="Source"><![CDATA[--Connection for a typed event.
--!strict

local TypedEventConnection = {}
TypedEventConnection.__index = TypedEventConnection

export type TypedEventStub<T...> = {
    Disconnected: (TypedEventStub<T...>, TypedEventConnection<T...>) -> (),
    [any]: any,
}

export type TypedEventConnection<T...> = {
    Connected: boolean,
    ParentEvent: TypedEventStub<T...>,
    ConnectionFunction: (T...) -> (),
} & typeof(setmetatable({}, TypedEventConnection))



--[[
Creates a connection.
--]]
function TypedEventConnection.new<T...>(ParentEvent: TypedEventStub<T...>, ConnectionFunction: (T...) -> ()): TypedEventConnection<T...>
    return setmetatable({
        Connected = true,
        ParentEvent = ParentEvent,
        ConnectionFunction = ConnectionFunction,
    }, TypedEventConnection) :: TypedEventConnection<T...>
end

--[[
Fires the connection.
--]]
function TypedEventConnection.Fire<T...>(self: TypedEventConnection<T...>, ...: T...): ()
    if not self.Connected then return end
    self.ConnectionFunction(...)
end

--[[
Disconnect the connection from the event.
--]]
function TypedEventConnection.Disconnect<T...>(self: TypedEventConnection<T...>): ()
    --Set the event as disconnected.
    if not self.Connected then return end
    self.Connected = false

    --Remove the connection.
    self.ParentEvent:Disconnected(self)
end

--[[
Destroys the connection.
--]]
function TypedEventConnection.Destroy<T...>(self: TypedEventConnection<T...>): ()
    self:Disconnect()
end



return TypedEventConnection]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX0EED79DA41634DE68AA129502BB7B6B0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">NexusVRCore</string>
					<string name="ScriptGuid">{1B190245-1144-4192-8471-9616B5CC6B13}</string>
					<ProtectedString name="Source"><![CDATA[--Project for fetching resources of Nexus VR Core.

local NexusProject = {}



--[[
Returns a resource in Nexus VR Core.
Legacy from Nexus Project.
--]]
function NexusProject:GetResource(Path: string): any
    local Module = script
    for _, PathPart in string.split(Path, ".") do
        Module = (Module :: any)[PathPart]
    end
    return require(Module :: ModuleScript)
end



return NexusProject]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXBAC13102158647D388758F302CE0C349">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Container</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXC9A072C8BC0B4C58BF1B7672330B65AE">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BaseScreenGui</string>
							<string name="ScriptGuid">{4615A5BA-78F3-4AB6-9338-4B5327D96FA7}</string>
							<ProtectedString name="Source"><![CDATA[--Base ScreenGui instance.
--!strict

local NexusInstance = require(script.Parent.Parent:WaitForChild("NexusInstance"))

local BaseScreenGui = {}
BaseScreenGui.ClassName = "BaseScreenGui"
BaseScreenGui.__index = BaseScreenGui

export type BaseScreenGui<T> = {
    Container: T,
    RotationOffset: CFrame,
    Depth: number,
    FieldOfView: number,
    CanvasSize: Vector2,
    Easing: number,
    PointingEnabled: boolean,
    NonReplicatedProperties: {[string]: boolean},
} & typeof(setmetatable({}, BaseScreenGui)) & T
export type NexusInstanceBaseScreenGui<T> = NexusInstance.NexusInstance<BaseScreenGui<T>>



--[[
Creates the Base ScreenGui.
--]]
function BaseScreenGui.__new<T>(self: NexusInstanceBaseScreenGui<T>, Container: T): ()
    self.Container = Container

    --Modify __index.
    local NonReplicatedProperties = {}
    self.NonReplicatedProperties = NonReplicatedProperties
    local Metatable = getmetatable(self) :: any
    local OriginalIndex = Metatable.__index
    Metatable.__index = function(self, Index: any): any
        --Return the object's value.
        local ObjectValue = OriginalIndex(self, Index)
        if ObjectValue ~= nil or NonReplicatedProperties[Index] then
            return ObjectValue
        end

        --Return the instance's value.
        return (Container :: any)[Index]
    end

    --Replicate changes.
    self:OnAnyPropertyChanged(function(PropertyName, Value)
        if NonReplicatedProperties[PropertyName] then return end
        (Container :: any)[PropertyName] = Value
    end)

    --Set the properties.
    self:DisableChangeReplication("RotationOffset")
    self.RotationOffset = CFrame.identity
    self:DisableChangeReplication("Depth")
    self.Depth = 5
    self:DisableChangeReplication("FieldOfView")
    self.FieldOfView = math.rad(50)
    if not (Container :: any):IsA("SurfaceGui") then
        self:DisableChangeReplication("CanvasSize")
    end
    self.CanvasSize = Vector2.new(1000, 1000)
    self:DisableChangeReplication("Easing")
    self.Easing = 0
    self:DisableChangeReplication("PointingEnabled")
    self.PointingEnabled = true
end

--[[
Returns if the BaseScreenGui is a type of instance.
IsA is not provided in Nexus Instance V4 and is provided for backwards compatibility.
--]]
function BaseScreenGui.IsA<T>(self: NexusInstanceBaseScreenGui<T>, ClassName: string): boolean
    warn("BaseScreenGui::IsA is deprecated.")
    return ClassName == "NexusObject" or ClassName == "NexusInstance" or ClassName == "BaseScreenGui"
end

--[[
Disables a change to replicate to the container.
--]]
function BaseScreenGui.DisableChangeReplication<T>(self: NexusInstanceBaseScreenGui<T>, Name: string)
    self.NonReplicatedProperties[Name] = true
end

--[[
Returns the container of the ScreenGui.
--]]
function BaseScreenGui.GetContainer<T>(self: NexusInstanceBaseScreenGui<T>): T
    return self.Container
end

--[[
Destroys the ScreenGui.
--]]
function BaseScreenGui.Destroy<T>(self: NexusInstanceBaseScreenGui<T>): ()
    (self.Container :: any):Destroy()
end



return NexusInstance.ToInstance(BaseScreenGui) :: NexusInstance.NexusInstanceClass<typeof(BaseScreenGui), <T>(Container: T) -> (NexusInstanceBaseScreenGui<T>)>]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX2F044203D02849DEB9955A7F87EAB3EA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ScreenGui</string>
							<string name="ScriptGuid">{7F8D1B5F-B4BF-4222-AD41-E5FE8ED11313}</string>
							<ProtectedString name="Source"><![CDATA[--Contains user interface components.
--!strict

local UserInputService = game:GetService("UserInputService")

local BaseScreenGui = require(script.Parent:WaitForChild("BaseScreenGui"))
local ScreenGui3D = require(script.Parent:WaitForChild("ScreenGui3D"))
local ScreenGui2D = require(script.Parent:WaitForChild("ScreenGui2D"))



--Return the class depending on if VR is enabled or not.
if UserInputService.VREnabled then
    return ScreenGui3D :: BaseScreenGui.BaseScreenGui<LayerCollector>
else
    return ScreenGui2D :: BaseScreenGui.BaseScreenGui<LayerCollector>
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4DF81A136ADF483EA66A85B74276C8B2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ScreenGui2D</string>
							<string name="ScriptGuid">{6FBEF055-AF44-4DE7-BC5A-AA60E97730B6}</string>
							<ProtectedString name="Source"><![CDATA[--Implementation of a ScreenGui for 2D players.
--!strict

local NexusInstance = require(script.Parent.Parent:WaitForChild("NexusInstance"))
local BaseScreenGui = require(script.Parent:WaitForChild("BaseScreenGui"))

local ScreenGui2D = {}
ScreenGui2D.ClassName = "ScreenGui2D"
ScreenGui2D.__index = ScreenGui2D
setmetatable(ScreenGui2D, BaseScreenGui)

export type ScreenGui2D = typeof(setmetatable({}, ScreenGui2D)) & BaseScreenGui.BaseScreenGui<ScreenGui>
export type NexusInstanceScreenGui2D = NexusInstance.NexusInstance<ScreenGui2D>



--[[
Creates a 2D ScreenGui.
--]]
function ScreenGui2D.__new(self: NexusInstanceScreenGui2D): ()
    BaseScreenGui.__new(self, Instance.new("ScreenGui"))
end

--[[
Returns if the ScreenGui2D is a type of instance.
IsA is not provided in Nexus Instance V4 and is provided for backwards compatibility.
--]]
function ScreenGui2D.IsA(self: NexusInstanceScreenGui2D, ClassName: string): boolean
    return BaseScreenGui.IsA(self, ClassName) or ClassName == "ScreenGui2D"
end



return NexusInstance.ToInstance(ScreenGui2D) :: NexusInstance.NexusInstanceClass<typeof(ScreenGui2D), () -> (NexusInstanceScreenGui2D)>]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX60940AD107344B06A43F80EBA4356669">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ScreenGui3D</string>
							<string name="ScriptGuid">{63EEE262-1E78-4910-9CDD-EB4E2EFD8107}</string>
							<ProtectedString name="Source"><![CDATA[--Contains user interface components for a 3D user interface.
--!strict

local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local NexusInstance = require(script.Parent.Parent:WaitForChild("NexusInstance"))
local BaseScreenGui = require(script.Parent:WaitForChild("BaseScreenGui"))

local ScreenGui3D = {}
ScreenGui3D.ClassName = "ScreenGui3D"
ScreenGui3D.__index = ScreenGui3D
setmetatable(ScreenGui3D, BaseScreenGui)

export type ScreenGui3D = {
    Adornee: BasePart,
    LastRotation: CFrame,
    UpdateEvent: RBXScriptConnection,
} & typeof(setmetatable({}, ScreenGui3D)) & BaseScreenGui.BaseScreenGui<SurfaceGui>
export type NexusInstanceScreenGui3D = NexusInstance.NexusInstance<ScreenGui3D>



--[[
Creates a 3D ScreenGui.
--]]
function ScreenGui3D.__new(self: NexusInstanceScreenGui3D): ()
    BaseScreenGui.__new(self, Instance.new("SurfaceGui"))

    --Create the Adornee.
    local NexusVRCoreContainer = Workspace.CurrentCamera:FindFirstChild("NexusVRCoreContainer")
    if not NexusVRCoreContainer then
        NexusVRCoreContainer = Instance.new("Folder")
        NexusVRCoreContainer.Name = "NexusVRCoreContainer"
        NexusVRCoreContainer.Parent = Workspace.CurrentCamera
    end
    local Adornee = Instance.new("Part")
    Adornee.Transparency = 1
    Adornee.Anchored = true
    Adornee.CanCollide = false
    Adornee.Parent = NexusVRCoreContainer
    self.Adornee = Adornee
    self.Face = Enum.NormalId.Back

    --Set the properties.
    self.AlwaysOnTop = true
    self:OnPropertyChanged("PointingEnabled", function()
        self.Adornee.CanQuery = self.Enabled and self.PointingEnabled
    end)
    self:OnPropertyChanged("Enabled", function()
        self.Adornee.CanQuery = self.Enabled and self.PointingEnabled
    end)

    --Disable replication of ScreenGui properties.
    self:DisableChangeReplication("DisplayOrder")
    self:DisableChangeReplication("IgnoreGuiInset")
    self:DisableChangeReplication("LastRotation")
    self.LastRotation = CFrame.new(Workspace.CurrentCamera:GetRenderCFrame().Position):Inverse() * Workspace.CurrentCamera:GetRenderCFrame()

    --Connect updating the size.
    self:OnPropertyChanged("Depth", function()
        self:UpdateSize()
    end)
    self:OnPropertyChanged("FieldOfView", function()
        self:UpdateSize()
    end)
    self:OnPropertyChanged("CanvasSize", function(Value)
        self:UpdateSize()
    end)

    --Update the size and position.
    self:UpdateSize()
    self:DisableChangeReplication("UpdateEvent")
    self.UpdateEvent = RunService.RenderStepped:Connect(function(DeltaTime: number)
        if self.Enabled then
            self:UpdateCFrame(DeltaTime)
        end
    end)
end

--[[
Updates the size of the part.
--]]
function ScreenGui3D.UpdateSize(self: NexusInstanceScreenGui3D): ()
    local Width = 2 * math.tan(self.FieldOfView/2) * self.Depth
    local CanvasSize = self.CanvasSize :: Vector2
    if CanvasSize.Y <= CanvasSize.X then
        self.Adornee.Size = Vector3.new(Width, Width * (self.CanvasSize.Y / self.CanvasSize.X), 0)
    else
        self.Adornee.Size = Vector3.new(Width * (self.CanvasSize.X / self.CanvasSize.Y), Width, 0)
    end
    self.CanvasSize = self.CanvasSize
end

--[[
Updates the CFrame of the part.
--]]
function ScreenGui3D.UpdateCFrame(self: NexusInstanceScreenGui3D, DeltaTime: number): ()
    DeltaTime = DeltaTime or self.Easing

    --Update the rotation.
    local CameraCFrame = Workspace.CurrentCamera:GetRenderCFrame()
    local TargetCFrame = CFrame.new(CameraCFrame.Position):Inverse() * CameraCFrame
    if self.Easing == 0 then
        self.LastRotation = TargetCFrame
    else
        self.LastRotation = self.LastRotation:Lerp(TargetCFrame, math.clamp(DeltaTime / self.Easing, 0, 1))
    end

    --Set the CFrame.
    self.Adornee.CFrame = CFrame.new(CameraCFrame.Position) * self.LastRotation * self.RotationOffset * CFrame.new(0, 0, -self.Depth)
end

--[[
Destroys the ScreenGui.
--]]
function ScreenGui3D.Destroy(self: NexusInstanceScreenGui3D): ()
    BaseScreenGui.Destroy(self)
    self.UpdateEvent:Disconnect()
    self.Adornee:Destroy()
end



return NexusInstance.ToInstance(ScreenGui3D) :: NexusInstance.NexusInstanceClass<typeof(ScreenGui3D), () -> (NexusInstanceScreenGui3D)>]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX8CB727DAA544438B837EFD067A0E3C9B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Utility</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX7C8F4AD9CA4F4E21BBBCEE92F17409AE">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PartUtility</string>
							<string name="ScriptGuid">{5627074D-4AB2-4A8C-82B6-11D1165F12F1}</string>
							<ProtectedString name="Source"><![CDATA[--Utility for parts.

local PartUtility = {}



--[[
Helper function for ray casting.
--]]
function PartUtility.RaycastToFront(AimingCFrame: CFrame, Size: Vector3, FrontCFrame: CFrame): (number, number, number)
    FrontCFrame = FrontCFrame * CFrame.new(0, 0, -Size.Z / 2)

    --Convert the aiming CFrame to a local CFrame.
	local LocalTargetCFrame = FrontCFrame:Inverse() * AimingCFrame
	local LocalTarget = LocalTargetCFrame.LookVector
	
	--Determine the angle away from the normal and cast the ray to the plane.
	local LookAngle = math.atan2(((LocalTarget.X ^ 2) + (LocalTarget.Y ^ 2)) ^ 0.5, LocalTarget.Z)
	local DistanceToScreen = LocalTargetCFrame.Z / math.cos(LookAngle)
	local LocalHitPosition = (LocalTargetCFrame * CFrame.new(0, 0, DistanceToScreen)).Position
	
	--Determine and return the relative positions.
	local RelativeX = 1 - (0.5 + (LocalHitPosition.X / Size.X))
	local RelativeY = 1 - (0.5 + (LocalHitPosition.Y / Size.Y))
    local Depth = -LocalTargetCFrame.Z * (1 / LocalTarget.Z)
	return RelativeX, RelativeY, Depth
end

--[[
Helper function for projecting.
--]]
function PartUtility.ProjectToFront(Position: Vector3, Size: Vector3, FrontCFrame: CFrame): (number, number, number)
    FrontCFrame = FrontCFrame * CFrame.new(0, 0, -Size.Z / 2)
	
	--Convert the aiming CFrame to a local CFrame.
	local LocalTargetCFrame = FrontCFrame:Inverse() * CFrame.new(Position)
	
	--Determine and return the relative positions.
	local RelativeX = 1 - (0.5 + (LocalTargetCFrame.X / Size.X))
	local RelativeY = 1 - (0.5 + (LocalTargetCFrame.Y / Size.Y))
	local Depth = -LocalTargetCFrame.Z
	return RelativeX, RelativeY, Depth
end

--[[
Ray casts to a surface. Returns the relative X and Y position
of the face, and the Z for the direction (>0 is facing, <0
is not facing).
--]]
function PartUtility.Raycast(Part: BasePart, AimingCFrame: CFrame, Face: Enum.NormalId | string): (number, number, number)
    local Size = Part.Size
    if Face == Enum.NormalId.Front or Face == "Front" then
        return PartUtility.RaycastToFront(AimingCFrame, Size, Part.CFrame)
    elseif Face == Enum.NormalId.Back or Face == "Back" then
        return PartUtility.RaycastToFront(AimingCFrame, Size, Part.CFrame * CFrame.Angles(0, math.pi, 0))
    elseif Face == Enum.NormalId.Top or Face == "Top" then
        local RelativeX, RelativeY, Depth = PartUtility.RaycastToFront(AimingCFrame, Vector3.new(Size.X, Size.Z, Size.Y), Part.CFrame * CFrame.Angles(math.pi / 2, 0, 0))
        return 1 - RelativeX, RelativeY, Depth
    elseif Face == Enum.NormalId.Bottom or Face == "Bottom" then
        local RelativeX, RelativeY, Depth = PartUtility.RaycastToFront(AimingCFrame, Vector3.new(Size.X, Size.Z, Size.Y), Part.CFrame * CFrame.Angles(-math.pi / 2, 0, 0))
        return RelativeX, 1 - RelativeY, Depth
    elseif Face == Enum.NormalId.Left or Face == "Left" then
        return PartUtility.RaycastToFront(AimingCFrame, Vector3.new(Size.Z, Size.Y, Size.X), Part.CFrame * CFrame.Angles(0, math.pi / 2, 0))
    elseif Face == Enum.NormalId.Right or Face == "Right" then
        return PartUtility.RaycastToFront(AimingCFrame, Vector3.new(Size.Z, Size.Y, Size.X), Part.CFrame * CFrame.Angles(0, -math.pi / 2, 0))
    end
    error("Unknown face type: "..tostring(Face))
end

--[[
Returns the relative position that is projected onto the
plane. Returns the relative X and Y position of the face,
and the Z for the direction (>0 is before the plane, <0
is after the plane).
--]]
function PartUtility.Project(Part: BasePart, HandPosition: Vector3, Face: Enum.NormalId | string): (number, number, number)
    local Size = Part.Size
    if Face == Enum.NormalId.Front or Face == "Front" then
        return PartUtility.ProjectToFront(HandPosition, Size, Part.CFrame)
    elseif Face == Enum.NormalId.Back or Face == "Back" then
        return PartUtility.ProjectToFront(HandPosition, Size, Part.CFrame * CFrame.Angles(0, math.pi, 0))
    elseif Face == Enum.NormalId.Top or Face == "Top" then
        local RelativeX, RelativeY, Depth = PartUtility.ProjectToFront(HandPosition, Vector3.new(Size.X, Size.Z, Size.Y), Part.CFrame * CFrame.Angles(math.pi / 2, 0, 0))
        return 1 - RelativeX, RelativeY, Depth
    elseif Face == Enum.NormalId.Bottom or Face == "Bottom" then
        local RelativeX, RelativeY, Depth = PartUtility.ProjectToFront(HandPosition, Vector3.new(Size.X, Size.Z, Size.Y), Part.CFrame * CFrame.Angles(-math.pi / 2, 0, 0))
        return RelativeX, 1 - RelativeY, Depth
    elseif Face == Enum.NormalId.Left or Face == "Left" then
        return PartUtility.ProjectToFront(HandPosition, Vector3.new(Size.Z, Size.Y, Size.X), Part.CFrame * CFrame.Angles(0, math.pi / 2, 0))
    elseif Face == Enum.NormalId.Right or Face == "Right" then
        return PartUtility.ProjectToFront(HandPosition, Vector3.new(Size.Z, Size.Y, Size.X), Part.CFrame * CFrame.Angles(0, -math.pi / 2, 0))
    end
    error("Unknown face type: "..tostring(Face))
end



return PartUtility]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX30A61BD1A4E546C7B17E31BC93537F1F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">NexusInstance</string>
						<string name="ScriptGuid">{F2C66F8A-57EC-4B91-BC19-C301C0767088}</string>
						<ProtectedString name="Source"><![CDATA[--Main module for Nexus Instance.
--!strict

local METATABLE_METHODS = {
    "__call",
    "__concat",
    "__unm",
    "__add",
    "__sub",
    "__mul",
    "__div",
    "__idiv",
    "__mod",
    "__pow",
    "__tostring",
    "__eq",
    "__lt",
    "__le",
    "__gc",
    "__len",
    "__iter",
}

local TypedEvent = require(script:WaitForChild("Event"):WaitForChild("TypedEvent"))

local NexusInstance = {}

export type TypedEvent<T...> = TypedEvent.TypedEvent<T...>

export type NexusInstanceClass<TClass, TConstructor> = {
    new: TConstructor
} & TClass

export type NexusInstance<TObject> = {
    Changed: TypedEvent<string>,
    BaseClass: any,
    Events: {TypedEvent<unknown>},
    TransformFunctions: {(Index: any, Value: any) -> (any)},
    PropertyTransformFunctions: {[string]: {(Value: any) -> (any)}},
    OnAnyPropertyChangedFunctions: {(PropertyName: any, Value: any) -> ()},
    OnPropertyChangedFunctions: {[string]: {(Value: any) -> ()}},
    HiddenPropertyChanges: {[string]: boolean},
    HiddenNextPropertyChanges: {[string]: boolean},
    PropertyChangedEvents: {[string]: TypedEvent<>},
} & typeof(NexusInstance) & TObject



--[[
Creates an instance version of the given class.
--]]
function NexusInstance.ToInstance<TClass, TConstructor>(Class: TClass): NexusInstanceClass<TClass, TConstructor>
    --Add the constructor.
    local ExtendedClass = (Class :: any) :: NexusInstanceClass<TClass, TConstructor>
    ExtendedClass.new = (function(...)
        --Prepare the object.
        local ChangedEvent = (TypedEvent.new() :: any) :: TypedEvent<string>
        local Properties = {}
        local TransformFunctions = {} :: {(Index: any, Value: any) -> (any)}
        local PropertyTransformFunctions = {} :: {[string]: {(Value: any) -> (any)}}
        local OnAnyPropertyChangedFunctions = {} :: {(PropertyName: any, Value: any) -> ()}
        local OnPropertyChangedFunctions = {} :: {[string]: {(Value: any) -> ()}}
        local HiddenPropertyChanges = {} :: {[string]: boolean}
        local HiddenNextPropertyChanges = {} :: {[string]: boolean}
        local PropertyChangedEvents = {} :: {[string]: TypedEvent<>}

        --Create the object.
        local Object = {
            Changed = ChangedEvent,
            BaseClass = Class,
            Events = {ChangedEvent},
            TransformFunctions = TransformFunctions,
            PropertyTransformFunctions = PropertyTransformFunctions,
            OnAnyPropertyChangedFunctions = OnAnyPropertyChangedFunctions,
            OnPropertyChangedFunctions = OnPropertyChangedFunctions,
            HiddenPropertyChanges = HiddenPropertyChanges,
            HiddenNextPropertyChanges = HiddenNextPropertyChanges,
            PropertyChangedEvents = PropertyChangedEvents,
        }
        local Metatable = {
            __index = function(_, Index: string): any?
                --Return the property.
                local PropertyValue = Properties[Index]
                if PropertyValue ~= nil then
                    return PropertyValue 
                end

                --Return the NexusInstance value.
                local NexusInstanceValue = (NexusInstance :: any)[Index]
                if NexusInstanceValue ~= nil then
                    return NexusInstanceValue
                end

                --Return the class's value.
                return (Class :: any)[Index]
            end,
            __newindex = function(self: any, Index: string, Value: any): ()
                --Perform the transform functions.
                for _, TransformFunction in TransformFunctions do
                    Value = TransformFunction(Index, Value)
                end
                if PropertyTransformFunctions[Index] then
                    for _, TransformFunction in PropertyTransformFunctions[Index] do
                        Value = TransformFunction(Value)
                    end
                end

                --Return if the new and old values are the same.
                if self[Index] == Value then
                    return
                end

                --Change the property.
                Properties[Index] = Value

                --Invoke that the property has changed.
                for _, ChangedCallback in OnAnyPropertyChangedFunctions do
                    ChangedCallback(Index, Value)
                end
                local PropertyChangedCallbacks = OnPropertyChangedFunctions[Index]
                if PropertyChangedCallbacks then
                    for _, ChangedCallback in PropertyChangedCallbacks do
                        ChangedCallback(Value)
                    end
                end

                --Return if the property is hidden.
                if HiddenNextPropertyChanges[Index] then
                    HiddenNextPropertyChanges[Index] = nil
                    return
                end
                if HiddenPropertyChanges[Index] then
                    return
                end

                --Invoke the changed event.
                self.Changed:Fire(Index)
                local PropertyChangedEvent = PropertyChangedEvents[Index]
                if PropertyChangedEvent then
                    PropertyChangedEvent:Fire()
                end
            end,
        }
        for _, MetatableMethod in METATABLE_METHODS do
            (Metatable :: any)[MetatableMethod] = (Class :: any)[MetatableMethod] 
        end
        local self = setmetatable(Object, Metatable)

        --Call the __new constructor of the class.
        local Constructor = (Class :: any).__new
        if Constructor then
            Constructor(self, ...)
        end

        --Return the object.
        return self
    end :: any) :: TConstructor
    
    --Return the extended class.
    return ExtendedClass 
end

--[[
Creates an event that is disconnected when the instance is destroyed.
--]]
function NexusInstance.CreateEvent<T, TEventArguments...>(self: NexusInstance<T>): TypedEvent<TEventArguments...>
    local NewEvent = TypedEvent.new() :: TypedEvent<TEventArguments...>
    table.insert(self.Events, NewEvent :: any)
    return NewEvent
end

--[[
Adds a generic property transformer.
--]]
function NexusInstance.AddGenericPropertyTransform<T>(self: NexusInstance<T>, Transform: (Index: any, Value: any) -> (any)): ()
    table.insert(self.TransformFunctions, Transform)
end

--[[
Adds a property transformer for a specific property.
--]]
function NexusInstance.AddPropertyTransform<T>(self: NexusInstance<T>, PropertyName: any, Transform: (Value: any) -> (any)): ()
    if not self.PropertyTransformFunctions[PropertyName] then
        self.PropertyTransformFunctions[PropertyName] = {}
    end
    table.insert(self.PropertyTransformFunctions[PropertyName], Transform)
end

--[[
Adds a callback when a property is changed.
This invokes immediately as opposed to using events.
--]]
function NexusInstance.OnAnyPropertyChanged<T>(self: NexusInstance<T>, Callback: (PropertyName: any, Value: any) -> ()): ()
    table.insert(self.OnAnyPropertyChangedFunctions, Callback)
end

--[[
Adds a callback when the given property is changed.
This invokes immediately as opposed to using events.
--]]
function NexusInstance.OnPropertyChanged<T>(self: NexusInstance<T>, PropertyName: string, Callback: (Value: any) -> ()): ()
    if not self.OnPropertyChangedFunctions[PropertyName] then
        self.OnPropertyChangedFunctions[PropertyName] = {}
    end
    table.insert(self.OnPropertyChangedFunctions[PropertyName], Callback)
end

--[[
Hides all changed events for a property.
--]]
function NexusInstance.HidePropertyChanges<T>(self: NexusInstance<T>, PropertyName: string): ()
    self.HiddenPropertyChanges[PropertyName] = true
end

--[[
Hides the next changed events for a property.
--]]
function NexusInstance.HideNextPropertyChange<T>(self: NexusInstance<T>, PropertyName: string): ()
    self.HiddenNextPropertyChanges[PropertyName] = true
end

--[[
Returns an event for when a property is changed.
--]]
function NexusInstance.GetPropertyChangedSignal<T>(self: NexusInstance<T>, PropertyName: string): TypedEvent<>
    if not self.PropertyChangedEvents[PropertyName] then
        self.PropertyChangedEvents[PropertyName] = self:CreateEvent()
    end
    return self.PropertyChangedEvents[PropertyName]
end

--[[
Destroys the instance.
--]]
function NexusInstance.Destroy<T>(self: NexusInstance<T>): ()
    --Call the class's destroy event.
    local DestroyFunction = (self.BaseClass :: any).Destroy
    if DestroyFunction then
        DestroyFunction(self)
    end

    --Disconnect the events.
    task.defer(function()
        for _, Event in self.Events do
            (Event :: TypedEvent<unknown>):Destroy()
        end
        self.Events = {}
    end)
end



return NexusInstance]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXCB88400CC44A4D4C9CFF4DD8B5A5A0D3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Event</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX16B02FC800024441BF132F95C8042882">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TypedEvent</string>
								<string name="ScriptGuid">{B8685863-1800-4804-B176-537FD6BB4EF8}</string>
								<ProtectedString name="Source"><![CDATA[--Typed event with support for table-based payloads.
--!strict

local HttpService = game:GetService("HttpService")

local TypedEventConnection = require(script.Parent:WaitForChild("TypedEventConnection"))

local TypedEvent = {}
TypedEvent.__index = TypedEvent

export type TypedEvent<T...> = {
    BindableEvent: BindableEvent,
    LastArgumentsStrong: {[string]: any},
    LastArguments: {[string]: any},
    Connections: {[TypedEventConnection.TypedEventConnection<T...>]: RBXScriptConnection},
    CurrentWaits: number,
} & typeof(setmetatable({}, TypedEvent))



--[[
Creates a typed event.
--]]
function TypedEvent.new<T...>(): TypedEvent<T...>
    --Create the object.
    --For deferred events, the arguments need to be stored. LastArgumentsStrong will
    --keep the reference around and prevent it from being garbage collected until only
    --LastArguments references it. Ideally, they will be used at the same time if both
    --:Connect(), :Once(), and :Wait() are used.
    local self = setmetatable({
        BindableEvent = Instance.new("BindableEvent"),
        LastArgumentsStrong = {},
        LastArguments = {},
        Connections = {},
        CurrentWaits = 0
    }, TypedEvent) :: TypedEvent<T...>
    setmetatable(self.LastArguments, {__mode="v"})

    --Return the object.
    return self
end

--[[
Establishes a function to be called when the event fires.
Returns a connection object that can be disconnected.
--]]
function TypedEvent.Connect<T...>(self: TypedEvent<T...>, Callback: (T...) -> ()): TypedEventConnection.TypedEventConnection<T...>
    --Create the connection.
    local Connection = TypedEventConnection.new(self :: any, Callback)

    --Set up the bindable event.
    local BindableEventConnection = self.BindableEvent.Event:Connect(function(UUID)
        --Get the arguments.
        local Arguments = self.LastArguments[UUID]
        self.LastArgumentsStrong[UUID] = nil

        --Fire the event.
        Connection:Fire(table.unpack(Arguments))
    end)

    --Store the connections.
    self.Connections[Connection] = BindableEventConnection

    --Return the connection.
    return Connection
end

--[[
Establishes a function to be called when the event fires.
Returns a connection object that can be disconnected.
However, instead of allowing multiple events to be received by the specified function,
only the first event will be delivered. Using Once also ensures that the connection to
the function will be automatically disconnected prior the function being called.
--]]
function TypedEvent.Once<T...>(self: TypedEvent<T...>, Callback: (T...) -> ()): ()
    local Connection = nil
    Connection = self:Connect(function(...)
        if Connection then
            Connection:Disconnect()
        end
        Callback(...)
    end)
end

--[[
Yields the current thread until the signal fires and returns the arguments provided by the signal.
--]]
function TypedEvent.Wait<T...>(self: TypedEvent<T...>): T...
    --Wait for the event.
    self.CurrentWaits = self.CurrentWaits + 1
    local UUID = self.BindableEvent.Event:Wait()
    self.CurrentWaits = self.CurrentWaits - 1

    --Return the arguments.
    local Arguments = self.LastArguments[UUID]
    self.LastArgumentsStrong[UUID] = nil
    return table.unpack(Arguments)
end

--[[
Fires the event.
--]]
function TypedEvent.Fire<T...>(self: TypedEvent<T...>, ...: T...): ()
    --Ignore if there are no connections.
    --If continued, self.LastArgumentsStrong will be populated and never cleared, leading to a memory leak.
    if next(self.Connections) == nil and self.CurrentWaits <= 0 then return end

    --Store the arguments.
    local UUID = HttpService:GenerateGUID()
    local Arguments = table.pack(...)
    self.LastArgumentsStrong[UUID] = Arguments
    self.LastArguments[UUID] = Arguments

    --Invoke the event.
    self.BindableEvent:Fire(UUID)
end

--[[
Handles an event being disconnected.
--]]
function TypedEvent.Disconnected<T...>(self: TypedEvent<T...>, Connection: TypedEventConnection.TypedEventConnection<T...>): ()
    if not self.Connections[Connection] then return end
    self.Connections[Connection]:Disconnect()
    self.Connections[Connection] = nil
end

--[[
Destroys the event.
--]]
function TypedEvent.Destroy<T...>(self: TypedEvent<T...>): ()
    local OriginalConnections = self.Connections
    self.Connections = {}
    self.CurrentWaits = 0
    for Connection, _ in OriginalConnections do
        (Connection :: TypedEventConnection.TypedEventConnection<T...>):Disconnect()
    end
    self.BindableEvent:Destroy()
end



return TypedEvent]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5C02E96C1D5D45A8BCD09B59DB897794">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TypedEventConnection</string>
								<string name="ScriptGuid">{1198FCC7-E9CE-46C5-9207-28536FA0AE73}</string>
								<ProtectedString name="Source"><![CDATA[--Connection for a typed event.
--!strict

local TypedEventConnection = {}
TypedEventConnection.__index = TypedEventConnection

export type TypedEventStub<T...> = {
    Disconnected: (TypedEventStub<T...>, TypedEventConnection<T...>) -> (),
    [any]: any,
}

export type TypedEventConnection<T...> = {
    Connected: boolean,
    ParentEvent: TypedEventStub<T...>,
    ConnectionFunction: (T...) -> (),
} & typeof(setmetatable({}, TypedEventConnection))



--[[
Creates a connection.
--]]
function TypedEventConnection.new<T...>(ParentEvent: TypedEventStub<T...>, ConnectionFunction: (T...) -> ()): TypedEventConnection<T...>
    return setmetatable({
        Connected = true,
        ParentEvent = ParentEvent,
        ConnectionFunction = ConnectionFunction,
    }, TypedEventConnection) :: TypedEventConnection<T...>
end

--[[
Fires the connection.
--]]
function TypedEventConnection.Fire<T...>(self: TypedEventConnection<T...>, ...: T...): ()
    if not self.Connected then return end
    self.ConnectionFunction(...)
end

--[[
Disconnect the connection from the event.
--]]
function TypedEventConnection.Disconnect<T...>(self: TypedEventConnection<T...>): ()
    --Set the event as disconnected.
    if not self.Connected then return end
    self.Connected = false

    --Remove the connection.
    self.ParentEvent:Disconnected(self)
end

--[[
Destroys the connection.
--]]
function TypedEventConnection.Destroy<T...>(self: TypedEventConnection<T...>): ()
    self:Disconnect()
end



return TypedEventConnection]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>